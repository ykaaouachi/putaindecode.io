{"head":{"layout":"Post","comments":true,"date":"2016-02-23","title":"Toward CSS modules","tags":["css","css modules"],"authors":["thibthib"],"description":"I think that even before I ever knew what it was, I already heard someone telling me “Oh god, I HATE CSS”. This sentence is often said by…"},"body":"<blockquote>\n<p>I think that even before I ever knew what it was, I already heard someone\ntelling me “Oh god, I HATE CSS”. This sentence is often said by one of my\nbackender friends, and often for very good reasons. This post isn’t going to\ndefend nor make you embrace CSS , but as front-end tooling is quickly improving,\nI find it interesting to explain the new ways of writing it.</p>\n</blockquote>\n<h2 id=\"back-to-basics\"><a href=\"#back-to-basics\" class=\"phenomic-HeadingAnchor\">#</a>Back to basics</h2>\n<p>First, to understand what are the problems that the new tools are attempting to\nsolve, a small reminder of what CSS is: <em>Cascading Style Sheets</em>.</p>\n<p>A style sheet ? Boy, that’s easy ! It’s some code that maps some  “styles” to\nHTML elements. Cascading ? Well, sometimes more than one (or no) style can match\nfor an HTML element, and “cascading” is the set of rules that exist to determine\nwhich one to apply.</p>\n<p>Let’s see some basic CSS code: we want our h1 titles to be red.</p>\n<pre><code class=\"hljs language-css\"><span class=\"hljs-selector-tag\">h1</span> {\n  <span class=\"hljs-attribute\">color</span>: red;\n}</code></pre>\n<p>Here, we map the <strong><em>rule (or declaration)</em></strong> “color: red” to the <strong><em>selector</em></strong>\n“h1”. A selector can contain multiples rules in its declaration block.</p>\n<blockquote>\n<p>And now the delight dies as we enter the cascade hell.</p>\n</blockquote>\n<h2 id=\"the-cascading-thing\"><a href=\"#the-cascading-thing\" class=\"phenomic-HeadingAnchor\">#</a>The cascading thing</h2>\n<p>The cascade is for me the disaster that makes CSS un-maintainable without\nguidelines nor tools when writing it. I’ll show you some examples explaining the\nmain concepts of the cascade, but they will be quite simple, whereas most web\napp nowadays have huge codebases, making the cascade effects bigger.</p>\n<p>The need for such a system like the cascade comes from the fact that CSS allows\nmultiple rules to be applied on the same element, even from different origins\n(the website, but also the browser or even from the user). It is therefore\nnecessary to define what is the rule that ultimately will be applied in this\ncase.\nThe cascade gives each rule a weight, calculated from several criteria, and\napply the heaviest on the element.\nI could appear simple at first, but the calculations\ncriteria are not, at all.</p>\n<p>The rules that have the lightest cascade weight are not really an issue, but we\nhave to keep them in mind to avoid surprises:</p>\n<h3 id=\"browser-defaults\"><a href=\"#browser-defaults\" class=\"phenomic-HeadingAnchor\">#</a>Browser defaults</h3>\n<p>Here is the top of the cascade. These are the rules that makes a h1 title big\neven if it isn't specified.</p>\n<h3 id=\"parent-inheritance\"><a href=\"#parent-inheritance\" class=\"phenomic-HeadingAnchor\">#</a>Parent inheritance</h3>\n<p>Then, the rules are inherited from the parents HTML elements. Back to our h1\nelement, if there is a “color: blue” rule on the body element, the title will\ninherit it, and will therefore be blue.</p>\n<p>That being said, we now enter a more painful level of cascade weight.</p>\n<h3 id=\"rule-order\"><a href=\"#rule-order\" class=\"phenomic-HeadingAnchor\">#</a>Rule order</h3>\n<p>The position of a rule compared with others will have an influence on its\nweight. Thus, if two rules were to have the same weight if on the same position,\nit finally will be the latest that will be the heaviest, and so applied. <strong><em>The\nlatest.</em></strong> With some quite simple code, it can be easy to understand:</p>\n<pre><code class=\"hljs language-css\"><span class=\"hljs-selector-tag\">h1</span> {\n  <span class=\"hljs-attribute\">color</span>: red;\n  <span class=\"hljs-attribute\">color</span>: blue;\n}</code></pre>\n<p>Easy, right ? The h1 will be blue ! But if there is a “color: red” rule in one\nCSS file named <em>foo.css</em>, a “color: blue” rule in another file named <em>bar.css</em>,\nthat the <em>foo.css</em> loading takes more time than <em>bar.css</em>, but that the\n<em>foo.css</em> HTML tag is before the <em>bar.css</em> one, which rule is applied ? Well,\nit’s quite harder to know. <em>(hint: the loading time is not taken into account)</em></p>\n<h3 id=\"selector-specificity\"><a href=\"#selector-specificity\" class=\"phenomic-HeadingAnchor\">#</a>Selector specificity</h3>\n<p>This one is a level of complexity higher, <a href=\"https://specificity.keegan.st\">some people even made calculators to\nsimplify it</a>. I will not enter into much details,\nbut know that the weight of a selector is equal to the sum of all the weights of\nthe selectors composing it. And that all selectors does’t weigh the same.</p>\n<pre><code class=\"hljs language-css\"><span class=\"hljs-selector-class\">.title</span> {\n  <span class=\"hljs-attribute\">color</span>: red;\n}\n\n<span class=\"hljs-selector-tag\">body</span> <span class=\"hljs-selector-tag\">header</span> <span class=\"hljs-selector-tag\">h1</span> {\n  <span class=\"hljs-attribute\">color</span>: blue;\n}</code></pre>\n<p>In this example, the first selector’s weight is 10 because it only contains a\nCSS class selector which weigh 10. The second selector’s weight is 3, because it\ncontains three tag selectors, weighing each 1. So, as 10 > 3, the h1 title will\nbe red !</p>\n<h3 id=\"inline-styles\"><a href=\"#inline-styles\" class=\"phenomic-HeadingAnchor\">#</a>Inline styles</h3>\n<p>The rules that are in the “style” attribute on a HTML element are heavier than\nany selector previously defined. Here is a blue title:</p>\n<pre><code class=\"hljs language-css\"><span class=\"hljs-selector-tag\">h1</span> {\n  <span class=\"hljs-attribute\">color</span>: red;\n}</code></pre>\n<pre><code class=\"hljs language-html\"><span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">h1</span> <span class=\"hljs-attr\">style</span>=<span class=\"hljs-string\">\"color: blue;\"</span>></span>Title<span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">h1</span>></span></code></pre>\n<h3 id=\"importance\"><a href=\"#importance\" class=\"phenomic-HeadingAnchor\">#</a>Importance</h3>\n<p>And last but not least, the God Mode, the crusher of all styles, the\n<strong><em>!important</em></strong> keyword. When we REALLY want our title to be red:</p>\n<pre><code class=\"hljs language-css\"><span class=\"hljs-selector-tag\">h1</span> {\n  <span class=\"hljs-attribute\">color</span>: red <span class=\"hljs-meta\">!important</span>;\n}</code></pre>\n<pre><code class=\"hljs language-html\"><span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">h1</span> <span class=\"hljs-attr\">style</span>=<span class=\"hljs-string\">\"color: blue;\"</span>></span>Title<span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">h1</span>></span></code></pre>\n<p>As all this cascade is about weight, if two rules are marked as !important, the\nrest of the criteria is still taken into account to calculate which one is the\nheavier, and so applied.</p>\n<p><strong>…And that is as bad as it gets.</strong> Now, imagine thousands and thousands of\nselectors cascading over themselves to style a website, and you’ll understand\nthe hell CSS can be. So, some fellow CSS developers imagined several\nmethodologies and tools to prevent this nightmare to happen !</p>\n<h2 id=\"tooling-evolution\"><a href=\"#tooling-evolution\" class=\"phenomic-HeadingAnchor\">#</a>Tooling evolution</h2>\n<p>Now I’ll present to you how my way of writing CSS evolved over time. Do not\nexpect a complete timeline of all the tools invented since the first release of\nCSS in 1996 (I was 6 years old !), but a description of how I worked with (or\naround) the cascade in my short personal experience.</p>\n<h3 id=\"pre-processors\"><a href=\"#pre-processors\" class=\"phenomic-HeadingAnchor\">#</a>Pre-processors</h3>\n<p>I began developing web applications in 2012, in the golden age of the\npre-processors. They already had appeared a few years back, as CSS itself wasn’t\nenough to build complex websites. Pre-processors are compilers that generate CSS\nfrom slightly different languages, like <a href=\"http://sass-lang.com\">Sass</a> or\n<a href=\"http://lesscss.org\">LESS</a>. These new languages added some fantastic new\nfeatures as variables or nesting, among other wonders.</p>\n<p>We could transform some old and un-easy to maintain CSS:</p>\n<pre><code class=\"hljs language-css\"><span class=\"hljs-selector-tag\">body</span> {\n  <span class=\"hljs-attribute\">background</span>: <span class=\"hljs-number\">#E5E5E5</span>;\n}\n\n<span class=\"hljs-selector-tag\">body</span> <span class=\"hljs-selector-tag\">h1</span> {\n  <span class=\"hljs-attribute\">color</span>: <span class=\"hljs-number\">#333333</span>;\n}</code></pre>\n<p>into this much <em>better</em> version:</p>\n<pre><code class=\"hljs language-scss\"><span class=\"hljs-variable\">$textColor</span>: <span class=\"hljs-number\">#333333</span>;\n\n<span class=\"hljs-selector-tag\">body</span> {\n  <span class=\"hljs-attribute\">background</span>: lighten(<span class=\"hljs-variable\">$textColor</span>, <span class=\"hljs-number\">90%</span>);\n\n  <span class=\"hljs-selector-tag\">h1</span> {\n    <span class=\"hljs-attribute\">color</span>: <span class=\"hljs-variable\">$textColor</span>\n  }\n}</code></pre>\n<p>With these new tools, and to prevent rules to collide in the cascade, we started\nnesting and replicating the whole HTML structure into our Sass or LESS code. Our\nCSS ended up with super long and heavy selectors matching only and exactly our\nelement, like this one:</p>\n<blockquote>\n<p>.searchPage .sideBar .refinements.default .category .star input</p>\n</blockquote>\n<p>And this worked pretty well for a time ! But these selectors weren’t the more\nefficient, and the HTML structure being doubled, any change in it must be passed\non the styles. So I moved on.</p>\n<h3 id=\"css-methodologies\"><a href=\"#css-methodologies\" class=\"phenomic-HeadingAnchor\">#</a>CSS Methodologies</h3>\n<p>By this time, some new CSS writing guidelines began to drew my attention. They\nweren’t exclusive with pre-processors, and aimed to avoid cascade collision\n(just like nesting) with some rules, like on the selector naming.</p>\n<p>These methodologies came by the time I started to split my developments into\ncomponents. The nesting didn’t work well with these, as the purpose was to\ncreate bits of code usable everywhere in my web app, like a button for example.\nThe one I use (still today) is named <a href=\"https://en.bem.info/method/\">BEM, for Block Element\nModifier</a>, but there are others with the same aim:\neach HTML element of my component has to have an unique CSS class. This way, no\nnesting is needed, and no cascade collision !</p>\n<p>And this pre-processed code:</p>\n<pre><code class=\"hljs language-scss\"><span class=\"hljs-selector-tag\">h1</span> {\n  <span class=\"hljs-attribute\">color</span>: <span class=\"hljs-variable\">$textColor</span>\n\n  img {\n    border: <span class=\"hljs-number\">1px</span> solid black;\n  }\n}</code></pre>\n<p>was transformed into:</p>\n<pre><code class=\"hljs language-css\"><span class=\"hljs-selector-class\">.Title</span> {\n  <span class=\"hljs-attribute\">color</span>: $textColor\n}\n\n<span class=\"hljs-selector-class\">.Title-icon</span> {\n  <span class=\"hljs-attribute\">border</span>: <span class=\"hljs-number\">1px</span> solid black;\n}</code></pre>\n<p>Obviously, the HTML code needed to be updated with the new classes, but the\nselectors are now short and self-explanatory ! Without any chance of cascade\ncollision.</p>\n<p>Now, and to better explain a final tool, the one I think will solve all our\nproblems (for now), I must show you another approach of this “working around”\nthe cascade:</p>\n<h3 id=\"css-frameworks\"><a href=\"#css-frameworks\" class=\"phenomic-HeadingAnchor\">#</a>CSS Frameworks</h3>\n<p>Here, to prevent our CSS to collide, we… stop writing our own ! CSS frameworks\nare already written styles that we can use with specific CSS classes. There is\ntwo different approaches here:</p>\n<ul>\n<li>\n<p>“Final” styles framework as <a href=\"http://getbootstrap.com\">Bootstrap</a>: a simple\n<em>“btn”</em> class on a HTML element and… tada ! Now it is a magnificent button.\nBesides, some variables are available to customize the frameworks’ look.\nUtility styles framework, like <a href=\"http://tachyons.io\">Tachyons</a>. Here, there\naren’t any pre-defined style, but a lot of utility CSS classes are available,\nlike <em>“pam”</em> to make an element have a <em>medium padding</em>, or <em>“ba”</em> to make it\nhave a <em>border all</em> around it.</p>\n</li>\n<li>\n<p>The second one is quite interesting, as our final CSS file will only weigh\n10kB and never more, even if the  website grows ! But the HTML will have a lot\nof gibberish classes.\nIt’s comparable with having all the styles inline, with a\nweight optimization comparable with minification, as <em>“ba”</em> is shorter than\n<em>“border-style: solid; border-width: 1px;”</em>.</p>\n</li>\n</ul>\n<p>These frameworks will keep us from complex CSS cascade calculations ! But I\nquite didn’t like the fact to use a framework, and to have a lot of quite\nunreadable CSS classes in my HTML. But the full re-usability and modularity of\nthe styles, without any cascade problems, are awesome.</p>\n<p>This bring us to this amazing tool, directly forged with the best JavaScript\nmagic:</p>\n<h3 id=\"css-modules\"><a href=\"#css-modules\" class=\"phenomic-HeadingAnchor\">#</a>CSS Modules</h3>\n<p>This concept first took shape from a simple observation: nowadays, the CSS code\nis compiled from other languages to make its writing way easier, and for the\nsame reason HTML code is mainly generated with JavaScript templating tools. But\nthe CSS selectors, the link between the elements and the styles, the ones for\nwhich the coder really needs to cogitate to prevent them to collide, are not\ntooled at all.</p>\n<p>And so <a href=\"https://github.com/css-modules/css-modules\">CSS Modules</a> was created.\nThe first awesome feature is the CSS class names automatic generation. No more\nworries about their uniqueness, we can name them as we want, the final one\ngenerated on the HTML element will be unique. Promise. This allows to rewrite\nthis previous CSS BEM and HTML code:</p>\n<pre><code class=\"hljs language-css\"><span class=\"hljs-selector-class\">.Title</span> {\n  <span class=\"hljs-attribute\">color</span>: $textColor;\n}</code></pre>\n<pre><code class=\"hljs language-html\"><span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">h1</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"Title\"</span>></span><span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">h1</span>></span></code></pre>\n<p>into this CSS and JS template code:</p>\n<pre><code class=\"hljs language-css\"><span class=\"hljs-selector-class\">.styleName</span> {\n  <span class=\"hljs-attribute\">color</span>: $textColor\n}</code></pre>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">import</span> styles <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'./style.css'</span>;\n<span class=\"hljs-string\">`&#x3C;h1 class=<span class=\"hljs-subst\">${styles.styleName}</span>>&#x3C;/h1>`</span></code></pre>\n<p>And when compiled, this code will generate something like this !</p>\n<pre><code class=\"hljs language-css\"><span class=\"hljs-selector-class\">.styleName__abc5436</span> {\n  <span class=\"hljs-attribute\">color</span>: <span class=\"hljs-number\">#333333</span>;\n}</code></pre>\n<pre><code class=\"hljs language-html\"><span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">h1</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"styleName__abc5436\"</span>></span><span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">h1</span>></span></code></pre>\n<p>A casc-what ? I don’t know what this is ! ❤️</p>\n<p>The second main feature, which is directly inspired by modular CSS frameworks\nlike Tachyons, is the styles composition. Just like it allowed to style HTML\nelements with some common utility classes, CSS modules allows to compose our\nclasses with common styles. Let me show you !</p>\n<pre><code class=\"hljs language-css\"><span class=\"hljs-selector-class\">.titleColor</span> {\n  <span class=\"hljs-attribute\">color</span>: <span class=\"hljs-number\">#333333</span>;\n}\n\n<span class=\"hljs-selector-class\">.bigTitle</span> {\n  <span class=\"hljs-attribute\">composes</span>: titleColor;\n  <span class=\"hljs-attribute\">font-size</span>: <span class=\"hljs-number\">24px</span>;\n}\n\n<span class=\"hljs-selector-class\">.mediumTitle</span> {\n  <span class=\"hljs-attribute\">composes</span>: titleColor;\n  <span class=\"hljs-attribute\">font-size</span>: <span class=\"hljs-number\">16px</span>;\n}</code></pre>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">import</span> styles <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'./style.css'</span>;\n<span class=\"hljs-string\">`&#x3C;h1 class=<span class=\"hljs-subst\">${styles.bigTitle}</span>>&#x3C;/h1>\n &#x3C;h2 class=<span class=\"hljs-subst\">${styles.mediumTitle}</span>>&#x3C;/h2>`</span></code></pre>\n<p>will compile into:</p>\n<pre><code class=\"hljs language-css\"><span class=\"hljs-selector-class\">.titleColor__abc5436</span> {\n  <span class=\"hljs-attribute\">color</span>: <span class=\"hljs-number\">#333333</span>;\n}\n\n<span class=\"hljs-selector-class\">.bigTitle__def6547</span> {\n  <span class=\"hljs-attribute\">font-size</span>: <span class=\"hljs-number\">24px</span>;\n}\n\n<span class=\"hljs-selector-class\">.mediumTitle__1638bcd</span> {\n  <span class=\"hljs-attribute\">font-size</span>: <span class=\"hljs-number\">16px</span>;\n}</code></pre>\n<pre><code class=\"hljs language-js\">&#x3C;h1 <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span></span>=<span class=\"hljs-string\">\"titleColor__abc5436 bigTitle__def6547\"</span>><span class=\"xml\"><span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">h1</span>></span></span>\n&#x3C;h2 <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span></span>=<span class=\"hljs-string\">\"titleColor__abc5436 mediumTitle__1638bcd\"</span>><span class=\"xml\"><span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">h2</span>></span></span></code></pre>\n<p>And that, Sir, is pretty awesome. Styles are composable and modularizable, and\nnot with a lot of gibberish utility classes but directly in the stylesheet. And\nstyles colliding are just an old nightmare.</p>\n<p>That’s how I’ve been playing around with CSS and its cascade until now. I expect\nthe months and years to come to surprise me with new and better tools or\nmethodologies, and I’ll be happy to learn and test them 👍.</p>\n","rawBody":"\n> I think that even before I ever knew what it was, I already heard someone\ntelling me “Oh god, I HATE CSS”. This sentence is often said by one of my\nbackender friends, and often for very good reasons. This post isn’t going to\ndefend nor make you embrace CSS , but as front-end tooling is quickly improving,\nI find it interesting to explain the new ways of writing it.\n\n## Back to basics\n\nFirst, to understand what are the problems that the new tools are attempting to\nsolve, a small reminder of what CSS is: *Cascading Style Sheets*.\n\nA style sheet ? Boy, that’s easy ! It’s some code that maps some  “styles” to\nHTML elements. Cascading ? Well, sometimes more than one (or no) style can match\nfor an HTML element, and “cascading” is the set of rules that exist to determine\nwhich one to apply.\n\nLet’s see some basic CSS code: we want our h1 titles to be red.\n\n```css\nh1 {\n  color: red;\n}\n```\n\nHere, we map the ***rule (or declaration)*** “color: red” to the ***selector***\n“h1”. A selector can contain multiples rules in its declaration block.\n\n> And now the delight dies as we enter the cascade hell.\n\n## The cascading thing\n\nThe cascade is for me the disaster that makes CSS un-maintainable without\nguidelines nor tools when writing it. I’ll show you some examples explaining the\nmain concepts of the cascade, but they will be quite simple, whereas most web\napp nowadays have huge codebases, making the cascade effects bigger.\n\nThe need for such a system like the cascade comes from the fact that CSS allows\nmultiple rules to be applied on the same element, even from different origins\n(the website, but also the browser or even from the user). It is therefore\nnecessary to define what is the rule that ultimately will be applied in this\ncase.\nThe cascade gives each rule a weight, calculated from several criteria, and\napply the heaviest on the element.\nI could appear simple at first, but the calculations\ncriteria are not, at all.\n\nThe rules that have the lightest cascade weight are not really an issue, but we\nhave to keep them in mind to avoid surprises:\n\n### Browser defaults\n\nHere is the top of the cascade. These are the rules that makes a h1 title big\neven if it isn't specified.\n\n### Parent inheritance\n\nThen, the rules are inherited from the parents HTML elements. Back to our h1\nelement, if there is a “color: blue” rule on the body element, the title will\ninherit it, and will therefore be blue.\n\nThat being said, we now enter a more painful level of cascade weight.\n\n### Rule order\n\nThe position of a rule compared with others will have an influence on its\nweight. Thus, if two rules were to have the same weight if on the same position,\nit finally will be the latest that will be the heaviest, and so applied. ***The\nlatest.*** With some quite simple code, it can be easy to understand:\n\n```css\nh1 {\n  color: red;\n  color: blue;\n}\n```\n\nEasy, right ? The h1 will be blue ! But if there is a “color: red” rule in one\nCSS file named *foo.css*, a “color: blue” rule in another file named *bar.css*,\nthat the *foo.css* loading takes more time than *bar.css*, but that the\n*foo.css* HTML tag is before the *bar.css* one, which rule is applied ? Well,\nit’s quite harder to know. *(hint: the loading time is not taken into account)*\n\n### Selector specificity\n\nThis one is a level of complexity higher, [some people even made calculators to\nsimplify it](https://specificity.keegan.st). I will not enter into much details,\nbut know that the weight of a selector is equal to the sum of all the weights of\nthe selectors composing it. And that all selectors does’t weigh the same.\n\n```css\n.title {\n  color: red;\n}\n\nbody header h1 {\n  color: blue;\n}\n```\n\nIn this example, the first selector’s weight is 10 because it only contains a\nCSS class selector which weigh 10. The second selector’s weight is 3, because it\ncontains three tag selectors, weighing each 1. So, as 10 > 3, the h1 title will\nbe red !\n\n### Inline styles\n\nThe rules that are in the “style” attribute on a HTML element are heavier than\nany selector previously defined. Here is a blue title:\n\n```css\nh1 {\n  color: red;\n}\n```\n```html\n<h1 style=\"color: blue;\">Title</h1>\n```\n\n### Importance\n\nAnd last but not least, the God Mode, the crusher of all styles, the\n***!important*** keyword. When we REALLY want our title to be red:\n\n```css\nh1 {\n  color: red !important;\n}\n```\n```html\n<h1 style=\"color: blue;\">Title</h1>\n```\n\nAs all this cascade is about weight, if two rules are marked as !important, the\nrest of the criteria is still taken into account to calculate which one is the\nheavier, and so applied.\n\n**…And that is as bad as it gets.** Now, imagine thousands and thousands of\nselectors cascading over themselves to style a website, and you’ll understand\nthe hell CSS can be. So, some fellow CSS developers imagined several\nmethodologies and tools to prevent this nightmare to happen !\n\n## Tooling evolution\n\nNow I’ll present to you how my way of writing CSS evolved over time. Do not\nexpect a complete timeline of all the tools invented since the first release of\nCSS in 1996 (I was 6 years old !), but a description of how I worked with (or\naround) the cascade in my short personal experience.\n\n### Pre-processors\n\nI began developing web applications in 2012, in the golden age of the\npre-processors. They already had appeared a few years back, as CSS itself wasn’t\nenough to build complex websites. Pre-processors are compilers that generate CSS\nfrom slightly different languages, like [Sass](http://sass-lang.com) or\n[LESS](http://lesscss.org). These new languages added some fantastic new\nfeatures as variables or nesting, among other wonders.\n\nWe could transform some old and un-easy to maintain CSS:\n\n```css\nbody {\n  background: #E5E5E5;\n}\n\nbody h1 {\n  color: #333333;\n}\n```\n\ninto this much *better* version:\n\n```scss\n$textColor: #333333;\n\nbody {\n  background: lighten($textColor, 90%);\n\n  h1 {\n    color: $textColor\n  }\n}\n```\n\nWith these new tools, and to prevent rules to collide in the cascade, we started\nnesting and replicating the whole HTML structure into our Sass or LESS code. Our\nCSS ended up with super long and heavy selectors matching only and exactly our\nelement, like this one:\n\n> .searchPage .sideBar .refinements.default .category .star input\n\nAnd this worked pretty well for a time ! But these selectors weren’t the more\nefficient, and the HTML structure being doubled, any change in it must be passed\non the styles. So I moved on.\n\n### CSS Methodologies\n\nBy this time, some new CSS writing guidelines began to drew my attention. They\nweren’t exclusive with pre-processors, and aimed to avoid cascade collision\n(just like nesting) with some rules, like on the selector naming.\n\nThese methodologies came by the time I started to split my developments into\ncomponents. The nesting didn’t work well with these, as the purpose was to\ncreate bits of code usable everywhere in my web app, like a button for example.\nThe one I use (still today) is named [BEM, for Block Element\nModifier](https://en.bem.info/method/), but there are others with the same aim:\neach HTML element of my component has to have an unique CSS class. This way, no\nnesting is needed, and no cascade collision !\n\nAnd this pre-processed code:\n\n```scss\nh1 {\n  color: $textColor\n\n  img {\n    border: 1px solid black;\n  }\n}\n```\n\nwas transformed into:\n\n```css\n.Title {\n  color: $textColor\n}\n\n.Title-icon {\n  border: 1px solid black;\n}\n```\n\nObviously, the HTML code needed to be updated with the new classes, but the\nselectors are now short and self-explanatory ! Without any chance of cascade\ncollision.\n\nNow, and to better explain a final tool, the one I think will solve all our\nproblems (for now), I must show you another approach of this “working around”\nthe cascade:\n\n### CSS Frameworks\n\nHere, to prevent our CSS to collide, we… stop writing our own ! CSS frameworks\nare already written styles that we can use with specific CSS classes. There is\ntwo different approaches here:\n\n* “Final” styles framework as [Bootstrap](http://getbootstrap.com): a simple\n *“btn”* class on a HTML element and… tada ! Now it is a magnificent button.\n Besides, some variables are available to customize the frameworks’ look.\n Utility styles framework, like [Tachyons](http://tachyons.io). Here, there\n aren’t any pre-defined style, but a lot of utility CSS classes are available,\n like *“pam”* to make an element have a *medium padding*, or *“ba”* to make it\n have a *border all* around it.\n\n* The second one is quite interesting, as our final CSS file will only weigh\n 10kB and never more, even if the  website grows ! But the HTML will have a lot\n of gibberish classes.\n It’s comparable with having all the styles inline, with a\n weight optimization comparable with minification, as *“ba”* is shorter than\n *“border-style: solid; border-width: 1px;”*.\n\nThese frameworks will keep us from complex CSS cascade calculations ! But I\nquite didn’t like the fact to use a framework, and to have a lot of quite\nunreadable CSS classes in my HTML. But the full re-usability and modularity of\nthe styles, without any cascade problems, are awesome.\n\nThis bring us to this amazing tool, directly forged with the best JavaScript\nmagic:\n\n### CSS Modules\n\nThis concept first took shape from a simple observation: nowadays, the CSS code\nis compiled from other languages to make its writing way easier, and for the\nsame reason HTML code is mainly generated with JavaScript templating tools. But\nthe CSS selectors, the link between the elements and the styles, the ones for\nwhich the coder really needs to cogitate to prevent them to collide, are not\ntooled at all.\n\nAnd so [CSS Modules](https://github.com/css-modules/css-modules) was created.\nThe first awesome feature is the CSS class names automatic generation. No more\nworries about their uniqueness, we can name them as we want, the final one\ngenerated on the HTML element will be unique. Promise. This allows to rewrite\nthis previous CSS BEM and HTML code:\n\n```css\n.Title {\n  color: $textColor;\n}\n```\n\n```html\n<h1 class=\"Title\"></h1>\n```\n\ninto this CSS and JS template code:\n\n```css\n.styleName {\n  color: $textColor\n}\n```\n\n```js\nimport styles from './style.css';\n`<h1 class=${styles.styleName}></h1>`\n```\n\nAnd when compiled, this code will generate something like this !\n\n```css\n.styleName__abc5436 {\n  color: #333333;\n}\n```\n\n```html\n<h1 class=\"styleName__abc5436\"></h1>\n```\n\nA casc-what ? I don’t know what this is ! ❤️\n\nThe second main feature, which is directly inspired by modular CSS frameworks\nlike Tachyons, is the styles composition. Just like it allowed to style HTML\nelements with some common utility classes, CSS modules allows to compose our\nclasses with common styles. Let me show you !\n\n```css\n.titleColor {\n  color: #333333;\n}\n\n.bigTitle {\n  composes: titleColor;\n  font-size: 24px;\n}\n\n.mediumTitle {\n  composes: titleColor;\n  font-size: 16px;\n}\n```\n\n```js\nimport styles from './style.css';\n`<h1 class=${styles.bigTitle}></h1>\n <h2 class=${styles.mediumTitle}></h2>`\n```\n\nwill compile into:\n\n```css\n.titleColor__abc5436 {\n  color: #333333;\n}\n\n.bigTitle__def6547 {\n  font-size: 24px;\n}\n\n.mediumTitle__1638bcd {\n  font-size: 16px;\n}\n```\n\n```js\n<h1 class=\"titleColor__abc5436 bigTitle__def6547\"></h1>\n<h2 class=\"titleColor__abc5436 mediumTitle__1638bcd\"></h2>\n```\n\nAnd that, Sir, is pretty awesome. Styles are composable and modularizable, and\nnot with a lot of gibberish utility classes but directly in the stylesheet. And\nstyles colliding are just an old nightmare.\n\nThat’s how I’ve been playing around with CSS and its cascade until now. I expect\nthe months and years to come to surprise me with new and better tools or\nmethodologies, and I’ll be happy to learn and test them 👍.\n","__filename":"en/articles/css/modules/index.md","__url":"/en/articles/css/modules/","__resourceUrl":"/en/articles/css/modules/index.html","__dataUrl":"/en/articles/css/modules/index.html.05bb62d6899a54e3d48817c9dcef6e85.json"}