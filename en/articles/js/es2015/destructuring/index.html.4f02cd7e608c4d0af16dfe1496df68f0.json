{"head":{"layout":"Post","comments":true,"date":"2015-12-02","title":"ES6, ES2015 : the destructuring","tags":["javascript","ES6","ES2015"],"authors":["bloodyowl"],"translators":["MoOx"],"description":"The destructuring is a feature that helps you assign variables from an object or an array based on their structure. Different syntaxesâ€¦"},"body":"<p>The destructuring is a feature that helps you assign variables from an object or\nan array based on their structure.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// Let's consider this object `myObject`</span>\n<span class=\"hljs-keyword\">var</span> myObject = {\n  <span class=\"hljs-attr\">foo</span>: <span class=\"hljs-number\">1</span>,\n  <span class=\"hljs-attr\">bar</span>: <span class=\"hljs-number\">2</span>,\n}\n\n<span class=\"hljs-comment\">// With ES5, you need to do</span>\n<span class=\"hljs-keyword\">var</span> foo = myObject.foo\n<span class=\"hljs-keyword\">var</span> bar = myObject.bar\n\nfoo <span class=\"hljs-comment\">// 1</span>\nbar <span class=\"hljs-comment\">// 2</span>\n\n<span class=\"hljs-comment\">// With ES6, you can write the same with</span>\n<span class=\"hljs-keyword\">const</span> { foo, bar } = myObject\nfoo <span class=\"hljs-comment\">// 1</span>\nbar <span class=\"hljs-comment\">// 2</span>\n\n<span class=\"hljs-comment\">// We can even destructure the value returned by a function (if this one</span>\n<span class=\"hljs-comment\">// returns a function or an array)</span>\n<span class=\"hljs-keyword\">const</span> getMyObject = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) </span>{\n  <span class=\"hljs-keyword\">return</span> {\n    <span class=\"hljs-attr\">foo</span>: <span class=\"hljs-number\">1</span>,\n    <span class=\"hljs-attr\">bar</span>: <span class=\"hljs-number\">2</span>,\n  }\n}\n<span class=\"hljs-keyword\">const</span> { foo, bar } = getMyObject()\nfoo <span class=\"hljs-comment\">// 1</span>\nbar <span class=\"hljs-comment\">// 2</span></code></pre>\n<h2 id=\"different-syntaxes\"><a href=\"#different-syntaxes\" class=\"phenomic-HeadingAnchor\">#</a>Different syntaxes</h2>\n<h3 id=\"array\"><a href=\"#array\" class=\"phenomic-HeadingAnchor\">#</a>Array</h3>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// For an array, we can use a syntax that is similar to a literal declaration</span>\n<span class=\"hljs-comment\">// of an array</span>\n<span class=\"hljs-comment\">// You might notice that you can ignore an item by just put nothing between the</span>\n<span class=\"hljs-comment\">// commas</span>\n<span class=\"hljs-keyword\">const</span> [ first, second, , fourth ] = [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>]\nfirst <span class=\"hljs-comment\">// 1</span>\nsecond <span class=\"hljs-comment\">// 2</span>\nfourth <span class=\"hljs-comment\">// 4</span></code></pre>\n<h3 id=\"use-a-different-name-for-the-key\"><a href=\"#use-a-different-name-for-the-key\" class=\"phenomic-HeadingAnchor\">#</a>Use a different name for the key</h3>\n<p>For an object, the default behavior is that the name of a variable will match\nthe name of the key.\nSo if you have already a variable with this name, you can choose another one.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">var</span> myObject = {\n  <span class=\"hljs-attr\">foo</span>: <span class=\"hljs-number\">1</span>,\n  <span class=\"hljs-attr\">bar</span>: <span class=\"hljs-number\">2</span>\n}\n<span class=\"hljs-keyword\">const</span> { <span class=\"hljs-attr\">foo</span>: renamedFoo } = myObject\nrenamedFoo <span class=\"hljs-comment\">// 1</span></code></pre>\n<p>This syntax doesn't offer a good readability.</p>\n<h3 id=\"function-arguments\"><a href=\"#function-arguments\" class=\"phenomic-HeadingAnchor\">#</a>Function arguments</h3>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// We can use destructuring directing in a function declaration</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">myFunction</span>(<span class=\"hljs-params\">{ title, text }</span>) </span>{\n\t<span class=\"hljs-keyword\">return</span> title + <span class=\"hljs-string\">\": \"</span> + text\n}\n\nmyFunction({ <span class=\"hljs-attr\">title</span>: <span class=\"hljs-string\">\"foo\"</span>, <span class=\"hljs-attr\">text</span>: <span class=\"hljs-string\">\"bar\"</span> }) <span class=\"hljs-comment\">// \"foo: bar\"</span></code></pre>\n<h3 id=\"nested-destructuring\"><a href=\"#nested-destructuring\" class=\"phenomic-HeadingAnchor\">#</a>Nested destructuring</h3>\n<p>We can also nest the assignments.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">var</span> myObject = {\n  <span class=\"hljs-attr\">foo</span>: {\n    <span class=\"hljs-attr\">bar</span>: <span class=\"hljs-number\">1</span>,\n  },\n}\n<span class=\"hljs-keyword\">const</span> { <span class=\"hljs-attr\">foo</span>: { bar } } = myObject\nbar <span class=\"hljs-comment\">// 1</span></code></pre>\n<p>Be careful, if the destructuring of the first level should return <code>undefined</code>\n(if the value doesn't exist), be sure that you will have a nesting error, since\na value will try to be retrieved from an <code>undefined</code> property.\nTo prevent this issue, you will need to define\n<a href=\"/en/articles/js/es2015/defaults/\">defaults</a> values.</p>\n","rawBody":"\nThe destructuring is a feature that helps you assign variables from an object or\nan array based on their structure.\n\n```js\n// Let's consider this object `myObject`\nvar myObject = {\n  foo: 1,\n  bar: 2,\n}\n\n// With ES5, you need to do\nvar foo = myObject.foo\nvar bar = myObject.bar\n\nfoo // 1\nbar // 2\n\n// With ES6, you can write the same with\nconst { foo, bar } = myObject\nfoo // 1\nbar // 2\n\n// We can even destructure the value returned by a function (if this one\n// returns a function or an array)\nconst getMyObject = function() {\n  return {\n    foo: 1,\n    bar: 2,\n  }\n}\nconst { foo, bar } = getMyObject()\nfoo // 1\nbar // 2\n```\n\n## Different syntaxes\n\n### Array\n\n```js\n// For an array, we can use a syntax that is similar to a literal declaration\n// of an array\n// You might notice that you can ignore an item by just put nothing between the\n// commas\nconst [ first, second, , fourth ] = [1, 2, 3, 4]\nfirst // 1\nsecond // 2\nfourth // 4\n```\n\n### Use a different name for the key\n\nFor an object, the default behavior is that the name of a variable will match\nthe name of the key.\nSo if you have already a variable with this name, you can choose another one.\n\n```js\nvar myObject = {\n  foo: 1,\n  bar: 2\n}\nconst { foo: renamedFoo } = myObject\nrenamedFoo // 1\n```\n\nThis syntax doesn't offer a good readability.\n\n### Function arguments\n\n```js\n// We can use destructuring directing in a function declaration\nfunction myFunction({ title, text }) {\n\treturn title + \": \" + text\n}\n\nmyFunction({ title: \"foo\", text: \"bar\" }) // \"foo: bar\"\n```\n\n### Nested destructuring\n\nWe can also nest the assignments.\n\n```js\nvar myObject = {\n  foo: {\n    bar: 1,\n  },\n}\nconst { foo: { bar } } = myObject\nbar // 1\n```\n\nBe careful, if the destructuring of the first level should return `undefined`\n(if the value doesn't exist), be sure that you will have a nesting error, since\na value will try to be retrieved from an `undefined` property.\nTo prevent this issue, you will need to define\n[defaults](/en/articles/js/es2015/defaults/) values.\n","__filename":"en/articles/js/es2015/destructuring.md","__url":"/en/articles/js/es2015/destructuring/","__resourceUrl":"/en/articles/js/es2015/destructuring/index.html","__dataUrl":"/en/articles/js/es2015/destructuring/index.html.4f02cd7e608c4d0af16dfe1496df68f0.json"}