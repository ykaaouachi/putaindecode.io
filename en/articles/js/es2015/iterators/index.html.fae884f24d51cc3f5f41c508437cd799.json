{"head":{"layout":"Post","comments":true,"date":"2015-12-09","title":"ES6, ES2015 : Iteration protocol","tags":["javascript","ES6","ES2015","iterators"],"authors":["ffesseler"],"translators":["MoOx"],"description":"Imagine something so big, that if you remove it from the language, you will need to remove lots of others features like spread operator,…"},"body":"<p>Imagine something so big, that if you remove it from the language, you will need\nto remove lots of others features like spread operator, destructuring,\ngenerators, for of...\nThis thing is just a protocol: the iterator protocol.</p>\n<p>The principle is just a convention in the language which allow to standardise\nhow we can iterate on some data.</p>\n<p>First good news, this protocol is pretty simple to understand and use 2\n\"interfaces\" (quotes are just to warn you that we cannot really call that\n<em>Interface</em>, since we don't have this \"thing\" in JavaScript).</p>\n<p>The first interface, <strong>Iterator</strong>, allow to an object to produce sequences of\nvalues. An object is an iterator when it implements a <code>next()</code> function\nwhich return an object that contains two properties :</p>\n<ul>\n<li><code>value</code>: current value of the current execution</li>\n<li><code>done</code> : a boolean that indicates whether the iteration is finished or not</li>\n</ul>\n<p>Successif calls of the <code>next()</code> method of an iterator will allow to get all\nthe value of an object.\nLet's see how we can iterate on a simple array <code>[\"a\", \"b\"]</code> :</p>\n<pre><code class=\"hljs language-js\">iteratorArray.next()\n<span class=\"hljs-comment\">// -> Object {value: \"a\", done: false}</span>\niteratorArray.next()\n<span class=\"hljs-comment\">// -> Object {value: \"b\", done: false}</span>\niteratorArray.next()\n<span class=\"hljs-comment\">// -> Object {value: undefined, done: true}</span></code></pre>\n<p>So you will probably now ask \"How to get this Iterator?\".\nThat's the second interface,  <strong>Iterable</strong>.\nAn iterable object implements a particular method which is going to return an\niterator.\nThis method (called <em>@@iterator</em> in the spec) must be defined using the\nSymbol <code>[Symbol.iterator]</code>.\n(Symbol will be explained in a dedicated).</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> arr = [<span class=\"hljs-string\">\"a\"</span>, <span class=\"hljs-string\">\"b\"</span>]\n<span class=\"hljs-keyword\">const</span> iteratorArray = arr[<span class=\"hljs-built_in\">Symbol</span>.iterator]()\niteratorArray.next()\n<span class=\"hljs-comment\">// -> Object {value: \"a\", done: false}</span>\niteratorArray.next()\n<span class=\"hljs-comment\">// -> Object {value: \"b\", done: false}</span>\niteratorArray.next()\n<span class=\"hljs-comment\">// -> Object {value: undefined, done: true}</span></code></pre>\n<p>Now you know how to use the array iterator implementation.\nNot really useful right?\nHere is another example to loop on an array following this protocol :</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> arr = [<span class=\"hljs-string\">\"a\"</span>, <span class=\"hljs-string\">\"b\"</span>]\n<span class=\"hljs-keyword\">const</span> iterator = arr[<span class=\"hljs-built_in\">Symbol</span>.iterator]()\n\n<span class=\"hljs-keyword\">const</span> result = iterator.next()\n<span class=\"hljs-keyword\">while</span> (!result.done) {\n  <span class=\"hljs-built_in\">console</span>.log(result.value)\n  result = iterator.next()\n}\n<span class=\"hljs-comment\">// 'a'</span>\n<span class=\"hljs-comment\">// 'b'</span></code></pre>\n<p>Let's recap: when an object which implements the iteration protocol is traversed\nits <em>@@iterator</em> method is called once and the iterator is returned to be used\nto loop an all values.</p>\n<h1 id=\"iterable-consumers\"><a href=\"#iterable-consumers\" class=\"phenomic-HeadingAnchor\">#</a>Iterable consumers</h1>\n<p>Second good new is that a lots of concept of JavaScript benefits of this\nprotocol :</p>\n<ul>\n<li>Some syntaxes expect to get iterables</li>\n</ul>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> arr = [<span class=\"hljs-string\">\"a\"</span>, <span class=\"hljs-string\">\"b\"</span>]\n\n<span class=\"hljs-comment\">// for...of has been precisely made to loop on custom iterables</span>\n<span class=\"hljs-keyword\">for</span> (val <span class=\"hljs-keyword\">of</span> arr) {\n    <span class=\"hljs-built_in\">console</span>.log(val)\n}\n\n<span class=\"hljs-comment\">// spred operator will use it too</span>\n[<span class=\"hljs-string\">'0'</span>, ...arr, <span class=\"hljs-string\">'1'</span>] <span class=\"hljs-comment\">// 0, a, b, 1</span>\n\n<span class=\"hljs-comment\">// yield also needs an iterator</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>* <span class=\"hljs-title\">gen</span>(<span class=\"hljs-params\"></span>)</span>{\n  <span class=\"hljs-keyword\">yield</span>* arr\n}\ngen().next() <span class=\"hljs-comment\">// { value:\"a\", done:false }</span>\n\n<span class=\"hljs-comment\">// same for destructuring</span>\n<span class=\"hljs-keyword\">const</span> [x, y] = arr <span class=\"hljs-comment\">// x = 'a',  y = \"b\"</span></code></pre>\n<ul>\n<li>Some APIs acccepts iterables</li>\n</ul>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> arr = [<span class=\"hljs-string\">\"a\"</span>, <span class=\"hljs-string\">\"b\"</span>, <span class=\"hljs-string\">\"b\"</span>]\n\n<span class=\"hljs-comment\">// Set and Weakset accepts iterables</span>\n<span class=\"hljs-keyword\">const</span> set = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Set</span>(arr)\nset.has(<span class=\"hljs-string\">\"b\"</span>) <span class=\"hljs-comment\">// true</span>\n<span class=\"hljs-comment\">// same for Map and WeakMap</span>\n<span class=\"hljs-keyword\">const</span> map = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Map</span>(arr.entries()) <span class=\"hljs-comment\">// Not that a (weak)map needs a [key, value] combo</span>\nmap.get(<span class=\"hljs-number\">0</span>) <span class=\"hljs-comment\">// 'a'</span>\n\n\n<span class=\"hljs-comment\">// MOAR APIs</span>\n\n<span class=\"hljs-built_in\">Array</span>.from(iterable) <span class=\"hljs-comment\">// tunr anything into an array !</span>\n<span class=\"hljs-built_in\">Promise</span>.all(iterableCollectionDePromises) <span class=\"hljs-comment\">// any iterable that will contains a set of Promises</span>\n<span class=\"hljs-built_in\">Promise</span>.race(iterableCollectionDePromises) <span class=\"hljs-comment\">// same</span></code></pre>\n<h1 id=\"built-in-iterable\"><a href=\"#built-in-iterable\" class=\"phenomic-HeadingAnchor\">#</a>Built-in Iterable</h1>\n<p>Third good news: a lot's of objects already implement this protocol :</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// obviously, arrays</span>\n<span class=\"hljs-keyword\">const</span> arr = [<span class=\"hljs-string\">\"l\"</span>, <span class=\"hljs-string\">\"o\"</span>, <span class=\"hljs-string\">\"l\"</span>]\n<span class=\"hljs-keyword\">for</span> (v <span class=\"hljs-keyword\">of</span> arr) {\n  <span class=\"hljs-built_in\">console</span>.log(v)\n  <span class=\"hljs-comment\">// 'l'</span>\n  <span class=\"hljs-comment\">// 'o'</span>\n  <span class=\"hljs-comment\">// 'l'</span>\n}\n\n<span class=\"hljs-comment\">// strings too</span>\n<span class=\"hljs-keyword\">const</span> str = <span class=\"hljs-string\">\"lol\"</span>\n<span class=\"hljs-keyword\">for</span> (v <span class=\"hljs-keyword\">of</span> str) {\n  <span class=\"hljs-built_in\">console</span>.log(v)\n  <span class=\"hljs-comment\">// 'l'</span>\n  <span class=\"hljs-comment\">// 'o'</span>\n  <span class=\"hljs-comment\">// 'l'</span>\n}\n\n<span class=\"hljs-comment\">// Map and Set (BUT NOT WeakMap and WeakSet)</span>\n<span class=\"hljs-keyword\">const</span> map = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Map</span>().set(<span class=\"hljs-string\">'l'</span>, <span class=\"hljs-number\">1</span>).set(<span class=\"hljs-string\">'o'</span>, <span class=\"hljs-number\">2</span>)\n<span class=\"hljs-keyword\">for</span> (v <span class=\"hljs-keyword\">of</span> map) {\n  <span class=\"hljs-built_in\">console</span>.log(v)\n  <span class=\"hljs-comment\">// [\"l\", 1]</span>\n  <span class=\"hljs-comment\">// [\"o\", 2]</span>\n}\n<span class=\"hljs-keyword\">const</span> set = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Set</span>().add(<span class=\"hljs-string\">'l'</span>).add(<span class=\"hljs-string\">'o'</span>)\n<span class=\"hljs-keyword\">for</span> (v <span class=\"hljs-keyword\">of</span> map) {\n  <span class=\"hljs-built_in\">console</span>.log(v)\n  <span class=\"hljs-comment\">// 'l'</span>\n  <span class=\"hljs-comment\">// 'o'</span>\n}\n\n<span class=\"hljs-comment\">// TypedArray that you use EVERY SINGLE DAYS</span>\n<span class=\"hljs-keyword\">const</span> int16 = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Int16Array</span>(<span class=\"hljs-number\">2</span>)\nint16[<span class=\"hljs-number\">0</span>] = <span class=\"hljs-number\">42</span>\n<span class=\"hljs-keyword\">for</span> (v <span class=\"hljs-keyword\">of</span> int16) {\n  <span class=\"hljs-built_in\">console</span>.log(v)\n  <span class=\"hljs-comment\">// 42</span>\n  <span class=\"hljs-comment\">// 0</span>\n}\n\n<span class=\"hljs-comment\">// Even the special `argument` object</span>\n<span class=\"hljs-comment\">// (that you will probably stop to use in es6, thanks to spread operator)</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">test</span>(<span class=\"hljs-params\"></span>) </span>{\n  <span class=\"hljs-keyword\">for</span> (v <span class=\"hljs-keyword\">of</span> <span class=\"hljs-built_in\">arguments</span>) {\n    <span class=\"hljs-built_in\">console</span>.log(v)\n    <span class=\"hljs-comment\">// 'l'</span>\n    <span class=\"hljs-comment\">// 'o'</span>\n    <span class=\"hljs-comment\">// 'l'</span>\n  }\n}\ntest(<span class=\"hljs-string\">'l'</span>, <span class=\"hljs-string\">'o'</span>, <span class=\"hljs-string\">'l'</span>)\n\n<span class=\"hljs-comment\">// NodeList returned by DOM APIs</span>\n<span class=\"hljs-keyword\">const</span> matches = <span class=\"hljs-built_in\">document</span>.querySelectorAll(<span class=\"hljs-string\">'div'</span>)\n<span class=\"hljs-keyword\">for</span> (m <span class=\"hljs-keyword\">of</span> matches) {\n  <span class=\"hljs-built_in\">console</span>.log(m)\n  <span class=\"hljs-comment\">// &#x3C;div id=\"topSection\"></span>\n  <span class=\"hljs-comment\">// &#x3C;div id=\"brandLogo\"></span>\n  <span class=\"hljs-comment\">// ...</span>\n}</code></pre>\n<p>Another detail: Array, TypedArray, Map, Set are iterables but also define\nmethods which also return iterables (...Are you still with us ?) :</p>\n<ul>\n<li>entries() returns a set of key/values</li>\n<li>keys() returns keys</li>\n<li>values() returns values</li>\n</ul>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">for</span> (cleVals <span class=\"hljs-keyword\">of</span> arr.entries()) {\n  <span class=\"hljs-built_in\">console</span>.log(cleVals)\n  <span class=\"hljs-comment\">// [0, \"l\"]</span>\n  <span class=\"hljs-comment\">// [1, \"o\"]</span>\n  <span class=\"hljs-comment\">// [2, \"l\"]</span>\n}</code></pre>\n<p>Important note: <code>Object</code> is not an iterable (but we might get in ES2016\nentries(), keys() and values() on <code>Object</code>\n(<a href=\"https://github.com/tc39/proposal-object-values-entries\">spec proposal</a>).</p>\n<h1 id=\"conclusion\"><a href=\"#conclusion\" class=\"phenomic-HeadingAnchor\">#</a>Conclusion</h1>\n<p>We have seen that a lots of interesting syntaxes and features use the iterable\nprotocol, so we hope that you will use all of that in your libraries.\nThat's important to rely on commons patterns so we can reach an agreement.</p>\n<p>Libraries can do that by :</p>\n<ul>\n<li>offering data that implements this protocol</li>\n<li>use this protocol directly (eg: for a sorting algorithm)</li>\n</ul>\n<h1 id=\"one-last-thing\"><a href=\"#one-last-thing\" class=\"phenomic-HeadingAnchor\">#</a>One last thing...</h1>\n<p>The following post will allow you to deep dive into this subject :</p>\n<ul>\n<li><a href=\"http://www.2ality.com/2015/02/es6-iteration.html\">Iterables and iterators in ECMAScript 6</a></li>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols\">Iteration Protocols</a></li>\n<li><a href=\"https://hacks.mozilla.org/2015/04/es6-in-depth-iterators-and-the-for-of-loop/\">ES6 in depth : iterators and the for of loop</a></li>\n<li><a href=\"https://ponyfoo.com/articles/es6-iterators-in-depth\">ES6 iterators in depth</a></li>\n</ul>\n<p>The practice remains the best way to train yourself, so take a look to\n<a href=\"http://es6katas.org/\">ES6 Katas</a> which has been made for that.</p>\n","rawBody":"\nImagine something so big, that if you remove it from the language, you will need\nto remove lots of others features like spread operator, destructuring,\ngenerators, for of...\nThis thing is just a protocol: the iterator protocol.\n\nThe principle is just a convention in the language which allow to standardise\nhow we can iterate on some data.\n\nFirst good news, this protocol is pretty simple to understand and use 2\n\"interfaces\" (quotes are just to warn you that we cannot really call that\n_Interface_, since we don't have this \"thing\" in JavaScript).\n\nThe first interface, **Iterator**, allow to an object to produce sequences of\nvalues. An object is an iterator when it implements a ``next()`` function\nwhich return an object that contains two properties :\n\n* ``value``: current value of the current execution\n* ``done`` : a boolean that indicates whether the iteration is finished or not\n\nSuccessif calls of the ``next()`` method of an iterator will allow to get all\nthe value of an object.\nLet's see how we can iterate on a simple array ``[\"a\", \"b\"]`` :\n\n```js\niteratorArray.next()\n// -> Object {value: \"a\", done: false}\niteratorArray.next()\n// -> Object {value: \"b\", done: false}\niteratorArray.next()\n// -> Object {value: undefined, done: true}\n```\n\nSo you will probably now ask \"How to get this Iterator?\".\nThat's the second interface,  **Iterable**.\nAn iterable object implements a particular method which is going to return an\niterator.\nThis method (called *@@iterator* in the spec) must be defined using the\nSymbol ``[Symbol.iterator]``.\n(Symbol will be explained in a dedicated).\n\n```js\nconst arr = [\"a\", \"b\"]\nconst iteratorArray = arr[Symbol.iterator]()\niteratorArray.next()\n// -> Object {value: \"a\", done: false}\niteratorArray.next()\n// -> Object {value: \"b\", done: false}\niteratorArray.next()\n// -> Object {value: undefined, done: true}\n```\n\nNow you know how to use the array iterator implementation.\nNot really useful right?\nHere is another example to loop on an array following this protocol :\n\n```js\nconst arr = [\"a\", \"b\"]\nconst iterator = arr[Symbol.iterator]()\n\nconst result = iterator.next()\nwhile (!result.done) {\n  console.log(result.value)\n  result = iterator.next()\n}\n// 'a'\n// 'b'\n```\n\nLet's recap: when an object which implements the iteration protocol is traversed\nits *@@iterator* method is called once and the iterator is returned to be used\nto loop an all values.\n\n# Iterable consumers\n\nSecond good new is that a lots of concept of JavaScript benefits of this\nprotocol :\n\n* Some syntaxes expect to get iterables\n\n```js\nconst arr = [\"a\", \"b\"]\n\n// for...of has been precisely made to loop on custom iterables\nfor (val of arr) {\n    console.log(val)\n}\n\n// spred operator will use it too\n['0', ...arr, '1'] // 0, a, b, 1\n\n// yield also needs an iterator\nfunction* gen(){\n  yield* arr\n}\ngen().next() // { value:\"a\", done:false }\n\n// same for destructuring\nconst [x, y] = arr // x = 'a',  y = \"b\"\n```\n\n* Some APIs acccepts iterables\n\n```js\nconst arr = [\"a\", \"b\", \"b\"]\n\n// Set and Weakset accepts iterables\nconst set = new Set(arr)\nset.has(\"b\") // true\n// same for Map and WeakMap\nconst map = new Map(arr.entries()) // Not that a (weak)map needs a [key, value] combo\nmap.get(0) // 'a'\n\n\n// MOAR APIs\n\nArray.from(iterable) // tunr anything into an array !\nPromise.all(iterableCollectionDePromises) // any iterable that will contains a set of Promises\nPromise.race(iterableCollectionDePromises) // same\n```\n\n# Built-in Iterable\n\nThird good news: a lot's of objects already implement this protocol :\n\n```js\n// obviously, arrays\nconst arr = [\"l\", \"o\", \"l\"]\nfor (v of arr) {\n  console.log(v)\n  // 'l'\n  // 'o'\n  // 'l'\n}\n\n// strings too\nconst str = \"lol\"\nfor (v of str) {\n  console.log(v)\n  // 'l'\n  // 'o'\n  // 'l'\n}\n\n// Map and Set (BUT NOT WeakMap and WeakSet)\nconst map = new Map().set('l', 1).set('o', 2)\nfor (v of map) {\n  console.log(v)\n  // [\"l\", 1]\n  // [\"o\", 2]\n}\nconst set = new Set().add('l').add('o')\nfor (v of map) {\n  console.log(v)\n  // 'l'\n  // 'o'\n}\n\n// TypedArray that you use EVERY SINGLE DAYS\nconst int16 = new Int16Array(2)\nint16[0] = 42\nfor (v of int16) {\n  console.log(v)\n  // 42\n  // 0\n}\n\n// Even the special `argument` object\n// (that you will probably stop to use in es6, thanks to spread operator)\nfunction test() {\n  for (v of arguments) {\n    console.log(v)\n    // 'l'\n    // 'o'\n    // 'l'\n  }\n}\ntest('l', 'o', 'l')\n\n// NodeList returned by DOM APIs\nconst matches = document.querySelectorAll('div')\nfor (m of matches) {\n  console.log(m)\n  // <div id=\"topSection\">\n  // <div id=\"brandLogo\">\n  // ...\n}\n```\n\nAnother detail: Array, TypedArray, Map, Set are iterables but also define\nmethods which also return iterables (...Are you still with us ?) :\n\n- entries() returns a set of key/values\n- keys() returns keys\n- values() returns values\n\n```js\nfor (cleVals of arr.entries()) {\n  console.log(cleVals)\n  // [0, \"l\"]\n  // [1, \"o\"]\n  // [2, \"l\"]\n}\n```\n\nImportant note: ``Object`` is not an iterable (but we might get in ES2016\nentries(), keys() and values() on ``Object``\n([spec proposal](https://github.com/tc39/proposal-object-values-entries)).\n\n# Conclusion\n\nWe have seen that a lots of interesting syntaxes and features use the iterable\nprotocol, so we hope that you will use all of that in your libraries.\nThat's important to rely on commons patterns so we can reach an agreement.\n\nLibraries can do that by :\n\n* offering data that implements this protocol\n* use this protocol directly (eg: for a sorting algorithm)\n\n# One last thing...\n\nThe following post will allow you to deep dive into this subject :\n\n* [Iterables and iterators in ECMAScript 6](http://www.2ality.com/2015/02/es6-iteration.html)\n* [Iteration Protocols](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols)\n* [ES6 in depth : iterators and the for of loop](https://hacks.mozilla.org/2015/04/es6-in-depth-iterators-and-the-for-of-loop/)\n* [ES6 iterators in depth](https://ponyfoo.com/articles/es6-iterators-in-depth)\n\n\nThe practice remains the best way to train yourself, so take a look to\n[ES6 Katas](http://es6katas.org/) which has been made for that.\n","__filename":"en/articles/js/es2015/iterators.md","__url":"/en/articles/js/es2015/iterators/","__resourceUrl":"/en/articles/js/es2015/iterators/index.html","__dataUrl":"/en/articles/js/es2015/iterators/index.html.fae884f24d51cc3f5f41c508437cd799.json"}