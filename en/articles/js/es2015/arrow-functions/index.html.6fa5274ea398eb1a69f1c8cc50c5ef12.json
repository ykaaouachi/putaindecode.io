{"head":{"layout":"Post","comments":true,"date":"2015-12-15","title":"ES6, ES2015 : Arrow functions","tags":["JavaScript","ES6","ES2015"],"authors":["MoOx"],"description":"ES2015 brings us some new syntax sugar that will likely make you stop using Function.prototype.bind(). Arrow functions are just a function…"},"body":"<p>ES2015 brings us some new syntax sugar that will likely make you stop using\n<code>Function.prototype.bind()</code>.</p>\n<p>Arrow functions are just a function shorthand using the <code>=></code> syntax.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// es5</span>\n<span class=\"hljs-keyword\">var</span> myFn = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">x</span>) </span>{\n    <span class=\"hljs-keyword\">return</span> x + <span class=\"hljs-number\">1</span>\n}\n\n<span class=\"hljs-comment\">// es6</span>\n<span class=\"hljs-keyword\">const</span> myFn = <span class=\"hljs-function\">(<span class=\"hljs-params\">x</span>) =></span> {\n  <span class=\"hljs-keyword\">return</span> x + <span class=\"hljs-number\">1</span>\n}</code></pre>\n<p>Arrow functions are syntactically similar to the related feature that exists in\nother languages like CoffeeScript, Java (8+), C#…</p>\n<p>They support both expression and statement bodies.\nIn our example above, we have seen a classic statement.\nBut for simple function, we can use an simple expression, to make things shorter.\nThat means that the previous example can be also written like this:</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> myFn = <span class=\"hljs-function\">(<span class=\"hljs-params\">x</span>) =></span> x + <span class=\"hljs-number\">1</span></code></pre>\n<p>Note that when you have only one argument, you can omit parenthesis around it.\nSo we can also wrote the example like this</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> myFn = <span class=\"hljs-function\"><span class=\"hljs-params\">x</span> =></span> x + <span class=\"hljs-number\">1</span></code></pre>\n<p>And you can also wrap the body in parenthesis if you want to make a multiline expression</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> myFn = <span class=\"hljs-function\"><span class=\"hljs-params\">x</span> =></span> (\n  x +\n  <span class=\"hljs-number\">1</span> <span class=\"hljs-comment\">// that can be multilines, you can imagine some JSX here ;)</span>\n)</code></pre>\n<p>So this examples are all the same :</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> myFn = <span class=\"hljs-function\">(<span class=\"hljs-params\">x</span>) =></span> {\n  <span class=\"hljs-keyword\">return</span> x + <span class=\"hljs-number\">1</span>\n}\n<span class=\"hljs-comment\">// ===</span>\n<span class=\"hljs-keyword\">const</span> myFn = <span class=\"hljs-function\">(<span class=\"hljs-params\">x</span>) =></span> x + <span class=\"hljs-number\">1</span>\n<span class=\"hljs-comment\">// ===</span>\n<span class=\"hljs-keyword\">const</span> myFn = <span class=\"hljs-function\"><span class=\"hljs-params\">x</span> =></span> x + <span class=\"hljs-number\">1</span>\n<span class=\"hljs-comment\">// ===</span>\n<span class=\"hljs-keyword\">const</span> myFn = <span class=\"hljs-function\"><span class=\"hljs-params\">x</span> =></span> (x + <span class=\"hljs-number\">1</span>)</code></pre>\n<p>In practice you will use this small functions in method like Array\nreduce/filter/map etc.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> nums = [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">5</span>]\n<span class=\"hljs-keyword\">const</span> odds = nums.filter(<span class=\"hljs-function\"><span class=\"hljs-params\">v</span> =></span> v%<span class=\"hljs-number\">2</span>) <span class=\"hljs-comment\">// [1, 3, 5]</span>\n<span class=\"hljs-keyword\">const</span> oddsSum = odds.reduce(<span class=\"hljs-function\">(<span class=\"hljs-params\">sum, v</span>) =></span> sum+v, <span class=\"hljs-number\">0</span>) <span class=\"hljs-comment\">// 9</span></code></pre>\n<h2 id=\"arrow-functions-dont-have-a-this\"><a href=\"#arrow-functions-dont-have-a-this\" class=\"phenomic-HeadingAnchor\">#</a>Arrow functions don’t have a <code>this</code></h2>\n<p>Yes your read correctly: unlike functions, arrows function share the same lexical this as their surrounding code.\nSo that means the <code>this</code> you might use use in the body of an arrow function refer to the parent scope:</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> Someone = {\n  <span class=\"hljs-attr\">name</span>: “MoOx”,\n  <span class=\"hljs-attr\">friends</span>: [], <span class=\"hljs-comment\">// he got no friends atm :(</span>\n  printFriends() {\n    <span class=\"hljs-keyword\">this</span>._friends.forEach(<span class=\"hljs-function\"><span class=\"hljs-params\">f</span> =></span>\n      <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-keyword\">this</span>._name + <span class=\"hljs-string\">\" knows \"</span> + f)\n      <span class=\"hljs-comment\">// `this` is not the function of the forEach !</span>\n    )\n  }\n}</code></pre>\n<p>By reading this code, you might understand that you are likely to stop using\n<code>bind()</code>:</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">import</span> React, { Component } <span class=\"hljs-keyword\">from</span> “react”\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Stuff</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">Component</span> </span>{\n\n  <span class=\"hljs-comment\">// old way</span>\n  onClick(e) {\n    <span class=\"hljs-keyword\">this</span>.setState({ <span class=\"hljs-attr\">omg</span>: <span class=\"hljs-literal\">false</span> })\n  }\n\n  render() {\n    <span class=\"hljs-keyword\">return</span> (\n      <span class=\"xml\"><span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">div</span>></span>\n        { /* old way */ }\n        </span>&#x3C;button onClick={ this.onClick.bind(this) }>\n          Old binded call\n        &#x3C;/button><span class=\"xml\">\n\n        { /* LOOK MA', NO BIND ! */ }\n        </span>&#x3C;button onClick={ (e) => this.onClick(e) }>\n          I don’t need `bind` anymore !\n        &#x3C;/button><span class=\"xml\">\n\n        { /* Simpler way */ }\n        </span>&#x3C;button onClick={ (e) => this.setState({ omg: true }) }>\n          Hell yeah\n        &#x3C;/button><span class=\"xml\">\n      <span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">div</span>></span></span>\n    )\n  }\n}</code></pre>\n<h2 id=\"note-about-expression-body-and-object\"><a href=\"#note-about-expression-body-and-object\" class=\"phenomic-HeadingAnchor\">#</a>Note about expression body and Object</h2>\n<p>If you want to return an object you might be surprised to get <code>undefined</code>\nwith this code:</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> aFn = <span class=\"hljs-function\">(<span class=\"hljs-params\">obj</span>) =></span> {<span class=\"hljs-attr\">key</span>: obj.value}</code></pre>\n<p>Indeed the above snippet could be translated into ES5 this way:</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">var</span> aFn = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">obj</span>) </span>{\n  key:         <span class=\"hljs-comment\">// Defines a label named `key`</span>\n    obj.value  <span class=\"hljs-comment\">// Gets `obj.value`</span>\n               <span class=\"hljs-comment\">// Implicit returns `undefined`</span>\n}</code></pre>\n<p>Keep in mind that in this context, a brace is to start a statement body, not an\nobject.\nSo you will need this:</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> aFn = <span class=\"hljs-function\">(<span class=\"hljs-params\">obj</span>) =></span> { <span class=\"hljs-keyword\">return</span> {<span class=\"hljs-attr\">key</span>: obj.value} }</code></pre>\n<p>But wait, there is a trick: a stupid couple of parenthesis.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> aFn = <span class=\"hljs-function\">(<span class=\"hljs-params\">obj</span>) =></span> ({<span class=\"hljs-attr\">key</span>: obj.value}) <span class=\"hljs-comment\">// It works!</span></code></pre>\n<h2 id=\"conclusion\"><a href=\"#conclusion\" class=\"phenomic-HeadingAnchor\">#</a>Conclusion</h2>\n<p>Take a look to the\n<a href=\"https://kangax.github.io/compat-table/es6/#test-arrow_functions\">compatibility table</a>.\nYou will see that arrow functions are already supported by most browsers but you\nmight need <a href=\"http://babeljs.io\">Babel</a> to use it today.</p>\n<p>You will probably use this more and more.\nEven if <code>function</code> keyword is not dead, arrow functions <code>=></code> are probably\ngoing to be a thing !</p>\n","rawBody":"\nES2015 brings us some new syntax sugar that will likely make you stop using\n``Function.prototype.bind()``.\n\nArrow functions are just a function shorthand using the `=>` syntax.\n\n```js\n// es5\nvar myFn = function(x) {\n    return x + 1\n}\n\n// es6\nconst myFn = (x) => {\n  return x + 1\n}\n```\n\nArrow functions are syntactically similar to the related feature that exists in\nother languages like CoffeeScript, Java (8+), C#…\n\nThey support both expression and statement bodies.\nIn our example above, we have seen a classic statement.\nBut for simple function, we can use an simple expression, to make things shorter.\nThat means that the previous example can be also written like this:\n\n```js\nconst myFn = (x) => x + 1\n```\n\nNote that when you have only one argument, you can omit parenthesis around it.\nSo we can also wrote the example like this\n\n```js\nconst myFn = x => x + 1\n```\n\nAnd you can also wrap the body in parenthesis if you want to make a multiline expression\n\n```js\nconst myFn = x => (\n  x +\n  1 // that can be multilines, you can imagine some JSX here ;)\n)\n```\n\nSo this examples are all the same :\n\n```js\nconst myFn = (x) => {\n  return x + 1\n}\n// ===\nconst myFn = (x) => x + 1\n// ===\nconst myFn = x => x + 1\n// ===\nconst myFn = x => (x + 1)\n```\n\nIn practice you will use this small functions in method like Array\nreduce/filter/map etc.\n\n```js\nconst nums = [1, 2, 3, 4, 5]\nconst odds = nums.filter(v => v%2) // [1, 3, 5]\nconst oddsSum = odds.reduce((sum, v) => sum+v, 0) // 9\n```\n\n## Arrow functions don’t have a `this`\n\nYes your read correctly: unlike functions, arrows function share the same lexical this as their surrounding code.\nSo that means the `this` you might use use in the body of an arrow function refer to the parent scope:\n\n```js\nconst Someone = {\n  name: “MoOx”,\n  friends: [], // he got no friends atm :(\n  printFriends() {\n    this._friends.forEach(f =>\n      console.log(this._name + \" knows \" + f)\n      // `this` is not the function of the forEach !\n    )\n  }\n}\n```\n\nBy reading this code, you might understand that you are likely to stop using\n``bind()``:\n\n```js\nimport React, { Component } from “react”\nclass Stuff extends Component {\n\n  // old way\n  onClick(e) {\n    this.setState({ omg: false })\n  }\n\n  render() {\n    return (\n      <div>\n        { /* old way */ }\n        <button onClick={ this.onClick.bind(this) }>\n          Old binded call\n        </button>\n\n        { /* LOOK MA', NO BIND ! */ }\n        <button onClick={ (e) => this.onClick(e) }>\n          I don’t need `bind` anymore !\n        </button>\n\n        { /* Simpler way */ }\n        <button onClick={ (e) => this.setState({ omg: true }) }>\n          Hell yeah\n        </button>\n      </div>\n    )\n  }\n}\n```\n\n## Note about expression body and Object\n\nIf you want to return an object you might be surprised to get `undefined`\nwith this code:\n\n```js\nconst aFn = (obj) => {key: obj.value}\n```\n\nIndeed the above snippet could be translated into ES5 this way:\n\n```js\nvar aFn = function (obj) {\n  key:         // Defines a label named `key`\n    obj.value  // Gets `obj.value`\n               // Implicit returns `undefined`\n}\n```\n\nKeep in mind that in this context, a brace is to start a statement body, not an\nobject.\nSo you will need this:\n\n```js\nconst aFn = (obj) => { return {key: obj.value} }\n```\n\nBut wait, there is a trick: a stupid couple of parenthesis.\n\n```js\nconst aFn = (obj) => ({key: obj.value}) // It works!\n```\n\n## Conclusion\n\nTake a look to the\n[compatibility table](https://kangax.github.io/compat-table/es6/#test-arrow_functions).\nYou will see that arrow functions are already supported by most browsers but you\nmight need [Babel](http://babeljs.io) to use it today.\n\nYou will probably use this more and more.\nEven if `function` keyword is not dead, arrow functions `=>` are probably\ngoing to be a thing !\n","__filename":"en/articles/js/es2015/arrow-functions.md","__url":"/en/articles/js/es2015/arrow-functions/","__resourceUrl":"/en/articles/js/es2015/arrow-functions/index.html","__dataUrl":"/en/articles/js/es2015/arrow-functions/index.html.6fa5274ea398eb1a69f1c8cc50c5ef12.json"}