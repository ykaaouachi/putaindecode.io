{"head":{"layout":"Post","comments":true,"date":"2015-12-10","title":"ES6, ES2015 : iterators and generators","tags":["JavaScript","ES6","ES2015"],"authors":["naholyr"],"translators":["MoOx"],"description":"ES2015 brings a lot of syntax sugar but not a lot of new real features. Generators are a new feature to generate iterators that follow the…"},"body":"<p>ES2015 brings a lot of syntax sugar but not a lot of new real features.\nGenerators are a new feature to generate iterators that follow the\n<a href=\"/en/articles/js/es2015/iterators/\">iterator protocol</a>.\nThey allow to take control of the execution of a function from the outside.</p>\n<h2 id=\"idle-function\"><a href=\"#idle-function\" class=\"phenomic-HeadingAnchor\">#</a>Idle function</h2>\n<p>A function followed by an asterisk (<code>function*</code>) is never executed directly\nand instead calling it will return an iterator.\nA generator is able to pause itself (and will do that by default).\nIt's also capable of continue where it was paused: the iterator returned is an\nobject that contains a <code>next</code> method which allows (when you call it) to\ncontinue the execution of the generator where it was paused.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> * <span class=\"hljs-title\">idleFunction</span> (<span class=\"hljs-params\"></span>) </span>{\n  <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'World'</span>)\n}\n\n<span class=\"hljs-keyword\">const</span> iterator = idleFunction()\n<span class=\"hljs-comment\">// The execution is paused, and is waiting to be continued</span>\n<span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'Hello'</span>)\niterator.next() <span class=\"hljs-comment\">// The execution will now continue and will log \"World\"</span></code></pre>\n<p>Note that this is not <strong>blocking</strong> code: the function is paused, the execution\ncan continue later, but meanwhile, the <em>event-loop</em> is still running.</p>\n<h2 id=\"emitting-new-values-with-yield\"><a href=\"#emitting-new-values-with-yield\" class=\"phenomic-HeadingAnchor\">#</a>Emitting new values with <code>yield</code></h2>\n<p>Following the <a href=\"/en/articles/js/es2015/iterators/\">iterator protocol</a>, the\n<code>next()</code> method will returns an object with 2 properties :</p>\n<ul>\n<li><code>done</code> is equal to <code>true</code> when generator has finished its job exécution</li>\n<li><code>value</code> is the value emitted by the generator when it become idle</li>\n</ul>\n<p>How to emit a value ? The keyword <code>yield</code> is made for this:\nit will returns a value and idle the execution of the function.\nThe thing is: you are going to use yield multiple times in the same function.\nOtherwise a generator does not make sense, and a simple function with <code>return</code>\nis enough.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> * <span class=\"hljs-title\">numbers</span> (<span class=\"hljs-params\"></span>) </span>{\n  <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-number\">1</span>\n  <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-number\">2</span>\n}\n\n<span class=\"hljs-keyword\">const</span> iterator = numbers()\niterator.next() <span class=\"hljs-comment\">// { value: 1, done: false }</span>\niterator.next() <span class=\"hljs-comment\">// { value: 2, done: false }</span>\niterator.next() <span class=\"hljs-comment\">// { value: undefined, done: true }</span></code></pre>\n<p>Note: if our generator <code>return</code>s a value, it will be affected to the <code>value</code>\nof the last iteration.</p>\n<h3 id=\"use-case-infinite-lists\"><a href=\"#use-case-infinite-lists\" class=\"phenomic-HeadingAnchor\">#</a><em>Use case</em> : infinite lists</h3>\n<p>At this stage, the first interesting use case is to handle an infinite list.\nWe can loop on a list that do not have a precise length.\nHere is an example with the Fibonacci sequence to get all results lower than\n100 :</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> * <span class=\"hljs-title\">fibo</span> (<span class=\"hljs-params\"></span>) </span>{\n  <span class=\"hljs-keyword\">let</span> [a, b] = [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">1</span>]\n  <span class=\"hljs-keyword\">while</span> (<span class=\"hljs-literal\">true</span>) { <span class=\"hljs-comment\">// Who can stop me?</span>\n    [a, b] = [b, a + b]\n    <span class=\"hljs-keyword\">yield</span> a\n  }\n}\n\n<span class=\"hljs-keyword\">const</span> iterator = fibo()\n<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> n <span class=\"hljs-keyword\">of</span> iterator) {\n  <span class=\"hljs-keyword\">if</span> (n >= <span class=\"hljs-number\">100</span>) {\n    <span class=\"hljs-keyword\">break</span> <span class=\"hljs-comment\">// *I* can stop you</span>\n  }\n  <span class=\"hljs-built_in\">console</span>.log(n)\n}\n<span class=\"hljs-comment\">// 1 2 3 5 8 13 21 34 55 89</span></code></pre>\n<p>Note : The <code>for … of</code> will be explained in another article.</p>\n<h2 id=\"sending-value-to-the-generator\"><a href=\"#sending-value-to-the-generator\" class=\"phenomic-HeadingAnchor\">#</a>Sending value to the generator</h2>\n<p>We have seen that <code>yield</code> allows to emit a value from the generator.\nThe opposite is possible too : <code>next</code> accepts a value that will be returned by\n<code>yield</code> :</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> * <span class=\"hljs-title\">math</span> (<span class=\"hljs-params\"></span>) </span>{\n  <span class=\"hljs-comment\">// the first next() will \"start\" the generator</span>\n  <span class=\"hljs-keyword\">const</span> x = <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-comment\">// the first value will be undefined</span>\n  <span class=\"hljs-comment\">// x = the argument of the other next() call</span>\n  <span class=\"hljs-keyword\">const</span> y = <span class=\"hljs-keyword\">yield</span> x + <span class=\"hljs-number\">1</span> <span class=\"hljs-comment\">// value of the second iteration : x + 1</span>\n  <span class=\"hljs-comment\">// y = third call of next()</span>\n  <span class=\"hljs-keyword\">yield</span> y <span class=\"hljs-comment\">// value of the last iteration : y</span>\n  <span class=\"hljs-comment\">// the fourth call and the others will return { value: undefined, done: true }</span>\n}\n\n<span class=\"hljs-keyword\">const</span> iterator = math()\niterator.next(<span class=\"hljs-number\">42</span>) <span class=\"hljs-comment\">// { value: undefined, done: false }</span>\n<span class=\"hljs-comment\">// Passer un paramètre au premier appel à next() n'est pas utile : cette valeur</span>\n<span class=\"hljs-comment\">// n'est pas accessible dans le générateur car aucun \"yield\" correspondant</span>\n\niterator.next(<span class=\"hljs-number\">33</span>) <span class=\"hljs-comment\">// { value: 34, done: false }, x = 33 dans le générateur</span>\niterator.next(<span class=\"hljs-number\">27</span>) <span class=\"hljs-comment\">// { value: 27, done: false }, y = 27 dans le générateur</span>\niterator.next() <span class=\"hljs-comment\">// { value: undefined, done: true }</span></code></pre>\n<p>This might sound not really useful, but keep in mind that you can send any type\nof data to <code>next()</code> : a function, an object, another iterator...\nPossiblities are limitless ! Let's take a look to an example using promises.</p>\n<h3 id=\"use-case-co-routines\"><a href=\"#use-case-co-routines\" class=\"phenomic-HeadingAnchor\">#</a><em>Use case</em> : co-routines</h3>\n<p>The code of the generator itself cannot be async: call to <code>yield</code> follow each\nothers synchronously.\nThe main controller can still be free to call <code>next()</code> when it wants to.</p>\n<p>So we have functions that we can play and pause whenever we want.\nWhat if our generator emitted a promise? In order to tell when it's time to\ncontinue.\nWhat if the controller, when it knows it got a promise wait for it to be\nresolved in order to send back the value to the generator?\nThis way, the generator will be able to run synchronous code in an non blocking\nway when handling async operations :</p>\n<pre><code class=\"hljs language-js\">execAsync(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> * (<span class=\"hljs-params\"></span>) </span>{\n  <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">\"Ajax request…\"</span>)\n  <span class=\"hljs-keyword\">var</span> rows = <span class=\"hljs-keyword\">yield</span> fetch(<span class=\"hljs-string\">\"http://my.api/get\"</span>)\n  <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">\"Work…\"</span>)\n  <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">\"Save…\"</span>)\n  <span class=\"hljs-keyword\">yield</span> fetch(<span class=\"hljs-string\">\"http://my.api/post\"</span>)\n  <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">\"OK.\"</span>)\n}) <span class=\"hljs-comment\">// Ajax request… Work… Save… OK.</span></code></pre>\n<p>How cool is that? This is clearly the most interesting use case for us and is\nactually pretty simple :</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">execAsync</span> (<span class=\"hljs-params\">promiseGenerator</span>) </span>{\n  <span class=\"hljs-keyword\">const</span> iter = promiseGenerator() <span class=\"hljs-comment\">// pause…</span>\n\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">loop</span> (<span class=\"hljs-params\">iteration</span>) </span>{\n    <span class=\"hljs-keyword\">if</span> (iteration.done) { <span class=\"hljs-comment\">// That's the part to detect the last return</span>\n      <span class=\"hljs-keyword\">return</span> iteration.value\n    }\n\n    <span class=\"hljs-comment\">// this is a generator of promise, we we wait for the resolution</span>\n    <span class=\"hljs-keyword\">return</span> iteration.value.then(<span class=\"hljs-function\"><span class=\"hljs-params\">result</span> =></span> {\n      <span class=\"hljs-comment\">// promise is resolved so we can send back the value to the generator</span>\n      <span class=\"hljs-keyword\">const</span> nextIteration = iter.next(result) <span class=\"hljs-comment\">// this value is returned by the</span>\n      <span class=\"hljs-comment\">// same \"yield\" which emitted the promise, how convenient is that?</span>\n\n      <span class=\"hljs-comment\">// NEXXXTTTT</span>\n      <span class=\"hljs-keyword\">return</span> next(nextIteration)\n    })\n  }\n\n  <span class=\"hljs-keyword\">const</span> promiseIteration = iter.next()\n  <span class=\"hljs-comment\">// we continue the execution until the next \"yield\"</span>\n  <span class=\"hljs-comment\">// the generator will be paused again until the next call to \"iter.next\"</span>\n\n  <span class=\"hljs-comment\">// We run the first iteration it and return it</span>\n  <span class=\"hljs-keyword\">return</span> loop(promiseIteration)\n}</code></pre>\n<h2 id=\"more-more-more\"><a href=\"#more-more-more\" class=\"phenomic-HeadingAnchor\">#</a>More! more! more!</h2>\n<h3 id=\"error-handling\"><a href=\"#error-handling\" class=\"phenomic-HeadingAnchor\">#</a>Error handling</h3>\n<p>Errors, like everything, can be emitted in both directions.\nThe generator can <code>throw</code> (the code is synchronous) :</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> * <span class=\"hljs-title\">fail</span> (<span class=\"hljs-params\"></span>) </span>{\n  <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-number\">1</span>\n  <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Error</span>(<span class=\"hljs-string\">'oops'</span>)\n  <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-number\">2</span>\n}\n\n<span class=\"hljs-keyword\">const</span> iterator = fail()\niterator.next() <span class=\"hljs-comment\">// { value: 1, done: false }</span>\n<span class=\"hljs-keyword\">try</span> {\n  iterator.next() <span class=\"hljs-comment\">// throws</span>\n} <span class=\"hljs-keyword\">catch</span> (e) {\n  e <span class=\"hljs-comment\">// Error('oops')</span>\n}</code></pre>\n<p>The controller can also emit an error inside with the <code>throw</code> method of the\niterator :</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> * <span class=\"hljs-title\">fail</span> (<span class=\"hljs-params\"></span>) </span>{\n  <span class=\"hljs-keyword\">try</span> {\n    <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-number\">1</span>\n  } <span class=\"hljs-keyword\">catch</span> (e) {\n    <span class=\"hljs-built_in\">console</span>.error(e)\n  }\n  <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-number\">2</span>\n}\n\n<span class=\"hljs-keyword\">const</span> iterator = fail()\niterator.next() <span class=\"hljs-comment\">// { value: 1, done: false }</span>\niterator.throw(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Error</span>(<span class=\"hljs-string\">\"nope\"</span>)) <span class=\"hljs-comment\">// \"[Error: nope]\"</span>\niterator.next() <span class=\"hljs-comment\">// { value: 2, done: false }</span>\niterator.next() <span class=\"hljs-comment\">// { value: undefined, done: true }</span></code></pre>\n<p>Note: you need to keep in mind that the first <code>next</code> is used to unlock\nthe execution of the generator, until the first <code>yield</code>, evaluate the emitted\nexpression, and send it in the <code>next()</code>, and pause the function.\nThat's the second <code>yield</code> that will continue <strong>from the <code>yield 1</code></strong>.\nThis is a part not really intuitive that can be hard to understand.</p>\n<h3 id=\"delegation\"><a href=\"#delegation\" class=\"phenomic-HeadingAnchor\">#</a>Delegation</h3>\n<p>The <code>yield*</code> operator allow to emit value from another iterator :</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> * <span class=\"hljs-title\">oneToThree</span> (<span class=\"hljs-params\"></span>) </span>{\n  <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-number\">1</span>\n  <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-number\">2</span>\n  <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-number\">3</span>\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> * <span class=\"hljs-title\">zeroToFour</span> (<span class=\"hljs-params\"></span>) </span>{\n  <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-number\">0</span>\n  <span class=\"hljs-keyword\">yield</span> * oneToThree()\n  <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-number\">4</span>\n}</code></pre>\n<p>That works with all <a href=\"/en/articles/js/es2015/iterators/\"><em>iterables</em></a> :\nfor example <code>yield * [1, 2, 3]</code> is valid.</p>\n<h3 id=\"anticipated-return\"><a href=\"#anticipated-return\" class=\"phenomic-HeadingAnchor\">#</a>Anticipated return</h3>\n<p>It's possible to end an operation of a generator from the controller using the\n<code>return</code> method of the iterator.\nEverything will happen like if the generator was ending immediately with the\nreturned value.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> * <span class=\"hljs-title\">numbers</span> (<span class=\"hljs-params\"></span>) </span>{\n  <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-number\">1</span>\n  <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-number\">2</span>\n  <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-number\">3</span>\n}\n\n<span class=\"hljs-keyword\">const</span> iterator = numbers()\niterator.next() <span class=\"hljs-comment\">// { value: 1, done: false }</span>\niterator.return(<span class=\"hljs-number\">4</span>) <span class=\"hljs-comment\">// { value: 4, done: true } → yield 2 and yield 3 are skipped</span>\niterator.next() <span class=\"hljs-comment\">// { value: undefined, done: true }</span></code></pre>\n<h2 id=\"conclusion\"><a href=\"#conclusion\" class=\"phenomic-HeadingAnchor\">#</a>Conclusion</h2>\n<p>Take a look to the\n<a href=\"https://kangax.github.io/compat-table/es6/#test-generators\">compatibility table</a>.</p>\n<p>Generators bring us a new bundle of feature that allow us to inverse\nresponsibility : the code that calling the generator can take over the way the\ncalled function will be executed.\nThey represent a new concept that will probably really change the way we will\ncode in the incoming months/years :\nasync function, observables... take their roots in generators.\nUnderstanding generators will helps you to work with those other new features.</p>\n","rawBody":"\nES2015 brings a lot of syntax sugar but not a lot of new real features.\nGenerators are a new feature to generate iterators that follow the\n[iterator protocol](/en/articles/js/es2015/iterators/).\nThey allow to take control of the execution of a function from the outside.\n\n## Idle function\n\nA function followed by an asterisk (``function*``) is never executed directly\nand instead calling it will return an iterator.\nA generator is able to pause itself (and will do that by default).\nIt's also capable of continue where it was paused: the iterator returned is an\nobject that contains a ``next`` method which allows (when you call it) to\ncontinue the execution of the generator where it was paused.\n\n```js\nfunction * idleFunction () {\n  console.log('World')\n}\n\nconst iterator = idleFunction()\n// The execution is paused, and is waiting to be continued\nconsole.log('Hello')\niterator.next() // The execution will now continue and will log \"World\"\n```\n\nNote that this is not **blocking** code: the function is paused, the execution\ncan continue later, but meanwhile, the *event-loop* is still running.\n\n## Emitting new values with ``yield``\n\nFollowing the [iterator protocol](/en/articles/js/es2015/iterators/), the\n``next()`` method will returns an object with 2 properties :\n\n* ``done`` is equal to ``true`` when generator has finished its job exécution\n* ``value`` is the value emitted by the generator when it become idle\n\nHow to emit a value ? The keyword ``yield`` is made for this:\nit will returns a value and idle the execution of the function.\nThe thing is: you are going to use yield multiple times in the same function.\nOtherwise a generator does not make sense, and a simple function with ``return``\nis enough.\n\n```js\nfunction * numbers () {\n  yield 1\n  yield 2\n}\n\nconst iterator = numbers()\niterator.next() // { value: 1, done: false }\niterator.next() // { value: 2, done: false }\niterator.next() // { value: undefined, done: true }\n```\n\nNote: if our generator ``return``s a value, it will be affected to the ``value``\nof the last iteration.\n\n### _Use case_ : infinite lists\n\nAt this stage, the first interesting use case is to handle an infinite list.\nWe can loop on a list that do not have a precise length.\nHere is an example with the Fibonacci sequence to get all results lower than\n100 :\n\n```js\nfunction * fibo () {\n  let [a, b] = [1, 1]\n  while (true) { // Who can stop me?\n    [a, b] = [b, a + b]\n    yield a\n  }\n}\n\nconst iterator = fibo()\nfor (let n of iterator) {\n  if (n >= 100) {\n    break // *I* can stop you\n  }\n  console.log(n)\n}\n// 1 2 3 5 8 13 21 34 55 89\n```\n\nNote : The ``for … of`` will be explained in another article.\n\n## Sending value to the generator\n\nWe have seen that ``yield`` allows to emit a value from the generator.\nThe opposite is possible too : ``next`` accepts a value that will be returned by\n``yield`` :\n\n```js\nfunction * math () {\n  // the first next() will \"start\" the generator\n  const x = yield // the first value will be undefined\n  // x = the argument of the other next() call\n  const y = yield x + 1 // value of the second iteration : x + 1\n  // y = third call of next()\n  yield y // value of the last iteration : y\n  // the fourth call and the others will return { value: undefined, done: true }\n}\n\nconst iterator = math()\niterator.next(42) // { value: undefined, done: false }\n// Passer un paramètre au premier appel à next() n'est pas utile : cette valeur\n// n'est pas accessible dans le générateur car aucun \"yield\" correspondant\n\niterator.next(33) // { value: 34, done: false }, x = 33 dans le générateur\niterator.next(27) // { value: 27, done: false }, y = 27 dans le générateur\niterator.next() // { value: undefined, done: true }\n```\n\nThis might sound not really useful, but keep in mind that you can send any type\nof data to ``next()`` : a function, an object, another iterator...\nPossiblities are limitless ! Let's take a look to an example using promises.\n\n### _Use case_ : co-routines\n\nThe code of the generator itself cannot be async: call to ``yield`` follow each\nothers synchronously.\nThe main controller can still be free to call ``next()`` when it wants to.\n\nSo we have functions that we can play and pause whenever we want.\nWhat if our generator emitted a promise? In order to tell when it's time to\ncontinue.\nWhat if the controller, when it knows it got a promise wait for it to be\nresolved in order to send back the value to the generator?\nThis way, the generator will be able to run synchronous code in an non blocking\nway when handling async operations :\n\n```js\nexecAsync(function * () {\n  console.log(\"Ajax request…\")\n  var rows = yield fetch(\"http://my.api/get\")\n  console.log(\"Work…\")\n  console.log(\"Save…\")\n  yield fetch(\"http://my.api/post\")\n  console.log(\"OK.\")\n}) // Ajax request… Work… Save… OK.\n```\n\nHow cool is that? This is clearly the most interesting use case for us and is\nactually pretty simple :\n\n```js\nfunction execAsync (promiseGenerator) {\n  const iter = promiseGenerator() // pause…\n\n  function loop (iteration) {\n    if (iteration.done) { // That's the part to detect the last return\n      return iteration.value\n    }\n\n    // this is a generator of promise, we we wait for the resolution\n    return iteration.value.then(result => {\n      // promise is resolved so we can send back the value to the generator\n      const nextIteration = iter.next(result) // this value is returned by the\n      // same \"yield\" which emitted the promise, how convenient is that?\n\n      // NEXXXTTTT\n      return next(nextIteration)\n    })\n  }\n\n  const promiseIteration = iter.next()\n  // we continue the execution until the next \"yield\"\n  // the generator will be paused again until the next call to \"iter.next\"\n\n  // We run the first iteration it and return it\n  return loop(promiseIteration)\n}\n```\n\n## More! more! more!\n\n### Error handling\n\nErrors, like everything, can be emitted in both directions.\nThe generator can ``throw`` (the code is synchronous) :\n\n```js\nfunction * fail () {\n  yield 1\n  throw new Error('oops')\n  yield 2\n}\n\nconst iterator = fail()\niterator.next() // { value: 1, done: false }\ntry {\n  iterator.next() // throws\n} catch (e) {\n  e // Error('oops')\n}\n```\n\nThe controller can also emit an error inside with the ``throw`` method of the\niterator :\n\n```js\nfunction * fail () {\n  try {\n    yield 1\n  } catch (e) {\n    console.error(e)\n  }\n  yield 2\n}\n\nconst iterator = fail()\niterator.next() // { value: 1, done: false }\niterator.throw(new Error(\"nope\")) // \"[Error: nope]\"\niterator.next() // { value: 2, done: false }\niterator.next() // { value: undefined, done: true }\n```\n\nNote: you need to keep in mind that the first ``next`` is used to unlock\nthe execution of the generator, until the first ``yield``, evaluate the emitted\nexpression, and send it in the ``next()``, and pause the function.\nThat's the second ``yield`` that will continue **from the ``yield 1``**.\nThis is a part not really intuitive that can be hard to understand.\n\n### Delegation\n\nThe ``yield*`` operator allow to emit value from another iterator :\n\n```js\nfunction * oneToThree () {\n  yield 1\n  yield 2\n  yield 3\n}\n\nfunction * zeroToFour () {\n  yield 0\n  yield * oneToThree()\n  yield 4\n}\n```\n\nThat works with all [*iterables*](/en/articles/js/es2015/iterators/) :\nfor example ``yield * [1, 2, 3]`` is valid.\n\n### Anticipated return\n\nIt's possible to end an operation of a generator from the controller using the\n``return`` method of the iterator.\nEverything will happen like if the generator was ending immediately with the\nreturned value.\n\n```js\nfunction * numbers () {\n  yield 1\n  yield 2\n  yield 3\n}\n\nconst iterator = numbers()\niterator.next() // { value: 1, done: false }\niterator.return(4) // { value: 4, done: true } → yield 2 and yield 3 are skipped\niterator.next() // { value: undefined, done: true }\n```\n\n## Conclusion\n\nTake a look to the\n[compatibility table](https://kangax.github.io/compat-table/es6/#test-generators).\n\nGenerators bring us a new bundle of feature that allow us to inverse\nresponsibility : the code that calling the generator can take over the way the\ncalled function will be executed.\nThey represent a new concept that will probably really change the way we will\ncode in the incoming months/years :\nasync function, observables... take their roots in generators.\nUnderstanding generators will helps you to work with those other new features.\n","__filename":"en/articles/js/es2015/generators.md","__url":"/en/articles/js/es2015/generators/","__resourceUrl":"/en/articles/js/es2015/generators/index.html","__dataUrl":"/en/articles/js/es2015/generators/index.html.590b0f721cefa23582a550be6076d3a8.json"}