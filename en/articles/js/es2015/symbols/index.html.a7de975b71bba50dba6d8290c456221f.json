{"head":{"layout":"Post","comments":true,"date":"2015-12-17","title":"ES6, ES2015 : symbols","tags":["javascript","ES6","ES2015"],"authors":["divarvel"],"description":"Following its goal of enriching primitive types, ES6 introduces symbols. Familiar to developers in many langages, especially Ruby, symbols…"},"body":"<p>Following its goal of enriching primitive types, ES6 introduces symbols.\nFamiliar to developers in many langages, especially Ruby, symbols bring us a\nstep further towards the eradication of <em>stringly-typed programming</em>. Symbols\nprovide us with a more robust way to encode identifiers.</p>\n<h2 id=\"creating-symbols\"><a href=\"#creating-symbols\" class=\"phenomic-HeadingAnchor\">#</a>Creating Symbols</h2>\n<p>The <code>Symbol()</code> function lets us create new symbols:</p>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-comment\">// A simple symbol</span>\n<span class=\"hljs-keyword\">const</span> mySymbol = <span class=\"hljs-built_in\">Symbol</span>();\n<span class=\"hljs-keyword\">typeof</span> mySymbol === <span class=\"hljs-string\">'symbol'</span> <span class=\"hljs-comment\">// true</span>\n\n<span class=\"hljs-comment\">// A symbol with a label</span>\n<span class=\"hljs-keyword\">const</span> myOtherSymbol = <span class=\"hljs-built_in\">Symbol</span>(<span class=\"hljs-string\">\"label\"</span>);\n\n\n<span class=\"hljs-comment\">// Each symbol is unique</span>\n<span class=\"hljs-keyword\">const</span> yetAnotherSymbol = <span class=\"hljs-built_in\">Symbol</span>(<span class=\"hljs-string\">\"label\"</span>);\nyetAnotherSymbol === myOtherSymbol; <span class=\"hljs-comment\">// false</span></code></pre>\n<p>Each symbol created with <code>Symbol</code> is both unique and immutable. This allows to\navoid collisions: it's impossible to mistakenly have two identical symbols.</p>\n<h2 id=\"implement-an-enum-with-symbols\"><a href=\"#implement-an-enum-with-symbols\" class=\"phenomic-HeadingAnchor\">#</a>Implement an <em>enum</em> with symbols</h2>\n<p>Instead of using strings as possible values for an <em>enum</em>, it's possible to\nuse symbols.</p>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-keyword\">const</span> ANIMAL_DOG = <span class=\"hljs-built_in\">Symbol</span>();\n<span class=\"hljs-keyword\">const</span> ANIMAL_CAT = <span class=\"hljs-built_in\">Symbol</span>();\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">getDescription</span>(<span class=\"hljs-params\">animal</span>) </span>{\n  <span class=\"hljs-keyword\">switch</span>(animal) {\n    <span class=\"hljs-keyword\">case</span> ANIMAL_DOG:\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">\"Loving animal\"</span>;\n    <span class=\"hljs-keyword\">case</span> ANIMAL_CAT:\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">\"Evil, sadistic animal\"</span>;\n  }\n}</code></pre>\n<p>This way, there is no risk of mistakenly mixing a user-provided string with an\n<em>enum</em>. This forces the value through a verifying and parsing stage.</p>\n<h2 id=\"symbols-as-keys\"><a href=\"#symbols-as-keys\" class=\"phenomic-HeadingAnchor\">#</a>Symbols as keys</h2>\n<p>We can use symbols as a key in an object or in a class.</p>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-keyword\">const</span> myKey = <span class=\"hljs-built_in\">Symbol</span>(<span class=\"hljs-string\">\"MY_KEY\"</span>);\n\n<span class=\"hljs-keyword\">const</span> myMutableObject = {};\nmyMutableObject[myKey] = <span class=\"hljs-string\">\"a value\"</span>;\n\n<span class=\"hljs-comment\">// With *computed property keys*</span>\n<span class=\"hljs-keyword\">const</span> myObj = {\n    [myKey]: <span class=\"hljs-string\">\"a value\"</span>\n}</code></pre>\n<p>Due to symbols unicity, no more collisions between the keys of an object.\nThe user can extend objects without having properties overriden by mistake.</p>\n<p>For instance, the iterator on an object (used by <code>for..of</code>), is a property\nwhose key is a symbol, available through <code>Symbol.iterator</code>.</p>\n<p>For instance, an object's iterator (used by <code>for..of</code>) is made available as\nthe property indexed by <code>Symbol.iterator</code>, a symbol devised for this use.</p>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-keyword\">const</span> myIterableObject = {\n  * [<span class=\"hljs-built_in\">Symbol</span>.iterator]() {\n    <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-string\">\"One\"</span>;\n    <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-string\">\"Two\"</span>;\n    <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-string\">\"Three\"</span>;\n  }\n}\n\n<span class=\"hljs-comment\">// Displays One, Two and Three</span>\n<span class=\"hljs-keyword\">for</span>(x <span class=\"hljs-keyword\">of</span> myIterableObject) {\n  <span class=\"hljs-built_in\">console</span>.log(x);\n}\n\n<span class=\"hljs-comment\">// Blows up with 'TypeError: undefined is not a function'</span>\n<span class=\"hljs-keyword\">for</span>(x <span class=\"hljs-keyword\">of</span> {}) {}</code></pre>\n<p>Several symbols (called <em>well-known symbols</em>) index behaviour defining\nobject properties: <code>Symbol.iterator</code> for the iterator on an object's\nvalues, <code>Symbol.hasInstance</code> to alter the result of <code>instanceof</code>, …</p>\n<p>These properties are therefore protected against tampering.</p>\n<h3 id=\"differences-between-symbol-keys-and-string-keys\"><a href=\"#differences-between-symbol-keys-and-string-keys\" class=\"phenomic-HeadingAnchor\">#</a>Differences between symbol keys and string keys</h3>\n<p>Properties indexed by symbols are not available from the commonly used key or\nvalues functions.</p>\n<h4 id=\"list-symbol-keys\"><a href=\"#list-symbol-keys\" class=\"phenomic-HeadingAnchor\">#</a>List symbol keys</h4>\n<p>Properties indexed by symbols are not visited by <code>for..in</code>, nor listed by\n<code>Object.keys</code>, or <code>Object.getOwnPropertyNames</code>. However, they are listed by\n<code>Object.getOwnPropertySymbols</code>.</p>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-keyword\">const</span> myObject = {\n  [<span class=\"hljs-built_in\">Symbol</span>()]: <span class=\"hljs-string\">\"symbol-keyed value\"</span>,\n  <span class=\"hljs-string\">\"key\"</span>: <span class=\"hljs-string\">\"string-keyed value\"</span>\n}\n\n<span class=\"hljs-built_in\">Object</span>.getOwnPropertyNames(myObject) <span class=\"hljs-comment\">// [ \"key\" ]</span>\n<span class=\"hljs-built_in\">Object</span>.getOwnPropertySymbols(myObject) <span class=\"hljs-comment\">// [ Symbol() ]</span></code></pre>\n<p>This way, a piece of code written with <code>Object.getOwnPropertyNames</code> -- and\nexpecting strings -- won't be broken by the use of symbols as keys.</p>\n<h4 id=\"jsonstringify\"><a href=\"#jsonstringify\" class=\"phenomic-HeadingAnchor\">#</a><code>JSON.stringify</code></h4>\n<p>Symbol-indexed properties are ignored by <code>JSON.stringify</code>.</p>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-built_in\">JSON</span>.stringify({\n  [<span class=\"hljs-built_in\">Symbol</span>()]: <span class=\"hljs-string\">\"symbol-keyed value\"</span>,\n  <span class=\"hljs-string\">\"key\"</span>: <span class=\"hljs-string\">\"string-keyed value\"</span>\n}) <span class=\"hljs-comment\">// '{\"key\":\"string-keyed value\"}'</span></code></pre>\n<h2 id=\"global-symbol-registry\"><a href=\"#global-symbol-registry\" class=\"phenomic-HeadingAnchor\">#</a>Global symbol registry</h2>\n<p>Symbols being unique, one cannot create a new symbol that is equal to an\nalready existing one. To be useful, a symbol must be somehow accessible. It's\nalso possible to create a symbol in a global registry with <code>Symbol.for</code>, to\nmake it available from anywhere.</p>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-comment\">// Returns a symbol, creating it if it doesn't already exist</span>\n<span class=\"hljs-keyword\">const</span> mySymbol = <span class=\"hljs-built_in\">Symbol</span>.for(<span class=\"hljs-string\">\"mySymbol\"</span>)\n\nmySymbol === <span class=\"hljs-built_in\">Symbol</span>.for(<span class=\"hljs-string\">\"mySymbol\"</span>) <span class=\"hljs-comment\">// true</span>\n\n<span class=\"hljs-comment\">// It's possible to get the key indexing a symbol in the registry</span>\n<span class=\"hljs-built_in\">Symbol</span>.keyFor(mySymbol) <span class=\"hljs-comment\">// 'mySymbol'</span>\n\n<span class=\"hljs-comment\">// Symbols not created in the registry are not available in it</span>\n<span class=\"hljs-built_in\">Symbol</span>.keyFor(<span class=\"hljs-built_in\">Symbol</span>()) <span class=\"hljs-comment\">// undefined</span></code></pre>\n<p><code>Symbol.for</code> allows to share symbols everywhere in the code, including\ndifferent execution contexts (different frames).</p>\n<h2 id=\"support\"><a href=\"#support\" class=\"phenomic-HeadingAnchor\">#</a>Support</h2>\n<p>In browsers, symbols are supported since Chrome 38, Firefox 36, Opera 25 and\nSafari 9. Nothing in Internet Explorer. Babel support is limited.</p>\n<p>In Node.js, symbols are supported since version <code>0.12</code>.</p>\n<p>Some <em>well-known symbols</em> are not available on all platforms. This depends on\nimplemented features support.</p>\n<h2 id=\"round-up\"><a href=\"#round-up\" class=\"phenomic-HeadingAnchor\">#</a>Round up</h2>\n<p>Symbols are a way to create unique tokens, which is way more robust than\nusing strings. Using symbols to implement <em>enums</em> prevents collisions and\nunwanted mix-up with unqualified data.</p>\n<p>Lastly, symbols as object keys prevent collisions and lets us have\n<em>meta-properties</em> cleanly separated from regular, string-indexed properties.\nProperties indexed with symbols can't be read, modified or listed by mistake.\nThis offers some protection against tampering.</p>\n<h2 id=\"further-reading\"><a href=\"#further-reading\" class=\"phenomic-HeadingAnchor\">#</a>Further reading</h2>\n<ul>\n<li><a href=\"https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Symbol\">MDN documentation on symbols</a></li>\n<li><a href=\"http://www.2ality.com/2014/12/es6-symbols.html\">Thorough article on how symbols work and how they can be used</a></li>\n</ul>\n","rawBody":"\nFollowing its goal of enriching primitive types, ES6 introduces symbols.\nFamiliar to developers in many langages, especially Ruby, symbols bring us a\nstep further towards the eradication of *stringly-typed programming*. Symbols\nprovide us with a more robust way to encode identifiers.\n\n## Creating Symbols\n\nThe `Symbol()` function lets us create new symbols:\n\n```javascript\n// A simple symbol\nconst mySymbol = Symbol();\ntypeof mySymbol === 'symbol' // true\n\n// A symbol with a label\nconst myOtherSymbol = Symbol(\"label\");\n\n\n// Each symbol is unique\nconst yetAnotherSymbol = Symbol(\"label\");\nyetAnotherSymbol === myOtherSymbol; // false\n```\n\nEach symbol created with `Symbol` is both unique and immutable. This allows to\navoid collisions: it's impossible to mistakenly have two identical symbols.\n\n## Implement an *enum* with symbols\n\nInstead of using strings as possible values for an *enum*, it's possible to\nuse symbols.\n\n```javascript\nconst ANIMAL_DOG = Symbol();\nconst ANIMAL_CAT = Symbol();\n\nfunction getDescription(animal) {\n  switch(animal) {\n    case ANIMAL_DOG:\n        return \"Loving animal\";\n    case ANIMAL_CAT:\n        return \"Evil, sadistic animal\";\n  }\n}\n```\n\nThis way, there is no risk of mistakenly mixing a user-provided string with an\n*enum*. This forces the value through a verifying and parsing stage.\n\n## Symbols as keys\n\nWe can use symbols as a key in an object or in a class.\n\n```javascript\nconst myKey = Symbol(\"MY_KEY\");\n\nconst myMutableObject = {};\nmyMutableObject[myKey] = \"a value\";\n\n// With *computed property keys*\nconst myObj = {\n    [myKey]: \"a value\"\n}\n```\n\nDue to symbols unicity, no more collisions between the keys of an object.\nThe user can extend objects without having properties overriden by mistake.\n\nFor instance, the iterator on an object (used by `for..of`), is a property\nwhose key is a symbol, available through `Symbol.iterator`.\n\nFor instance, an object's iterator (used by `for..of`) is made available as\nthe property indexed by `Symbol.iterator`, a symbol devised for this use.\n\n```javascript\nconst myIterableObject = {\n  * [Symbol.iterator]() {\n    yield \"One\";\n    yield \"Two\";\n    yield \"Three\";\n  }\n}\n\n// Displays One, Two and Three\nfor(x of myIterableObject) {\n  console.log(x);\n}\n\n// Blows up with 'TypeError: undefined is not a function'\nfor(x of {}) {}\n```\n\nSeveral symbols (called *well-known symbols*) index behaviour defining\nobject properties: `Symbol.iterator` for the iterator on an object's\nvalues, `Symbol.hasInstance` to alter the result of `instanceof`, …\n\nThese properties are therefore protected against tampering.\n\n### Differences between symbol keys and string keys\n\nProperties indexed by symbols are not available from the commonly used key or\nvalues functions.\n\n#### List symbol keys\n\nProperties indexed by symbols are not visited by `for..in`, nor listed by\n`Object.keys`, or `Object.getOwnPropertyNames`. However, they are listed by\n`Object.getOwnPropertySymbols`.\n\n```javascript\nconst myObject = {\n  [Symbol()]: \"symbol-keyed value\",\n  \"key\": \"string-keyed value\"\n}\n\nObject.getOwnPropertyNames(myObject) // [ \"key\" ]\nObject.getOwnPropertySymbols(myObject) // [ Symbol() ]\n```\n\nThis way, a piece of code written with `Object.getOwnPropertyNames` -- and\nexpecting strings -- won't be broken by the use of symbols as keys.\n\n#### `JSON.stringify`\n\nSymbol-indexed properties are ignored by `JSON.stringify`.\n\n\n```javascript\nJSON.stringify({\n  [Symbol()]: \"symbol-keyed value\",\n  \"key\": \"string-keyed value\"\n}) // '{\"key\":\"string-keyed value\"}'\n```\n\n## Global symbol registry\n\nSymbols being unique, one cannot create a new symbol that is equal to an\nalready existing one. To be useful, a symbol must be somehow accessible. It's\nalso possible to create a symbol in a global registry with `Symbol.for`, to\nmake it available from anywhere.\n\n```javascript\n// Returns a symbol, creating it if it doesn't already exist\nconst mySymbol = Symbol.for(\"mySymbol\")\n\nmySymbol === Symbol.for(\"mySymbol\") // true\n\n// It's possible to get the key indexing a symbol in the registry\nSymbol.keyFor(mySymbol) // 'mySymbol'\n\n// Symbols not created in the registry are not available in it\nSymbol.keyFor(Symbol()) // undefined\n```\n\n`Symbol.for` allows to share symbols everywhere in the code, including\ndifferent execution contexts (different frames).\n\n\n## Support\n\nIn browsers, symbols are supported since Chrome 38, Firefox 36, Opera 25 and\nSafari 9. Nothing in Internet Explorer. Babel support is limited.\n\nIn Node.js, symbols are supported since version `0.12`.\n\nSome *well-known symbols* are not available on all platforms. This depends on\nimplemented features support.\n\n## Round up\n\nSymbols are a way to create unique tokens, which is way more robust than\nusing strings. Using symbols to implement *enums* prevents collisions and\nunwanted mix-up with unqualified data.\n\nLastly, symbols as object keys prevent collisions and lets us have\n*meta-properties* cleanly separated from regular, string-indexed properties.\nProperties indexed with symbols can't be read, modified or listed by mistake.\nThis offers some protection against tampering.\n\n## Further reading\n\n - [MDN documentation on symbols](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Symbol)\n - [Thorough article on how symbols work and how they can be used](http://www.2ality.com/2014/12/es6-symbols.html)\n","__filename":"en/articles/js/es2015/symbols.md","__url":"/en/articles/js/es2015/symbols/","__resourceUrl":"/en/articles/js/es2015/symbols/index.html","__dataUrl":"/en/articles/js/es2015/symbols/index.html.a7de975b71bba50dba6d8290c456221f.json"}