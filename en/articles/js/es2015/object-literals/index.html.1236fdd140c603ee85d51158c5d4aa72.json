{"head":{"layout":"Post","comments":true,"date":"2015-12-08","title":"ES6, ES2015 : Object literals","tags":["JavaScript","ES6","ES2015"],"authors":["lionelB"],"translators":["MoOx"],"description":"Again, ES6 brings us more syntax sugar, that you might appreciate when creating new object. Shorter property name When you create anâ€¦"},"body":"<p>Again, ES6 brings us more syntax sugar, that you might appreciate when\ncreating new object.</p>\n<h2 id=\"shorter-property-name\"><a href=\"#shorter-property-name\" class=\"phenomic-HeadingAnchor\">#</a>Shorter property name</h2>\n<p>When you create an object, you might create a variable and then reuse it to\ndefine a property of an object that have the same name.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">var</span> firstname = <span class=\"hljs-string\">\"Robert\"</span>\n<span class=\"hljs-keyword\">var</span> lastname = <span class=\"hljs-string\">\"Laiponje\"</span>\n\n<span class=\"hljs-keyword\">return</span> {\n  <span class=\"hljs-attr\">firstname</span>: firstname,\n  <span class=\"hljs-attr\">lastname</span>: lastname,\n}</code></pre>\n<p>Thanks to ES6, you can directly write:</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> firstname = <span class=\"hljs-string\">\"Robert\"</span>\n<span class=\"hljs-keyword\">const</span> lastname = <span class=\"hljs-string\">\"Laiponje\"</span>\n\n<span class=\"hljs-keyword\">return</span> {\n  firstname,\n  lastname,\n}\n<span class=\"hljs-comment\">// { firstname: \"Robert\", lastname: \"Laiponje\" }</span></code></pre>\n<p>In the same spirit, you will be able to declare methods without the <code>function</code>\nkeyword (this also apply for <em>getter</em> and <em>setter</em>).</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> obj = {\n  get email() {\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">this</span>.email()\n  },\n  set email(email) {\n    <span class=\"hljs-keyword\">this</span>.email = email\n  },\n  validateEmail(email) {\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>\n  },\n}</code></pre>\n<h2 id=\"dynamic-property-name\"><a href=\"#dynamic-property-name\" class=\"phenomic-HeadingAnchor\">#</a>Dynamic property name</h2>\n<p>One last thing for <em>objects literal</em> will allow you to create dynamic property\nname using an expression, directly when you create an object.\nWith ES5 you have to do that in two steps:</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">action</span>(<span class=\"hljs-params\">type, data</span>) </span>{\n  <span class=\"hljs-keyword\">var</span> payload = {}\n  payload[type] = data\n  <span class=\"hljs-keyword\">return</span> payload\n}</code></pre>\n<p>Now with ES6, you can do:</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">action</span>(<span class=\"hljs-params\">type, data</span>) </span>{\n  <span class=\"hljs-keyword\">return</span> {\n    [type]: data\n  }\n}</code></pre>\n<p><strong>Note:</strong> with dynamic properties, declaring multiples properties with the same\nname is accepted and do not throw an error. Keep in mind that only the last\nvalue will be kept.</p>\n","rawBody":"\nAgain, ES6 brings us more syntax sugar, that you might appreciate when\ncreating new object.\n\n## Shorter property name\n\nWhen you create an object, you might create a variable and then reuse it to\ndefine a property of an object that have the same name.\n\n```js\nvar firstname = \"Robert\"\nvar lastname = \"Laiponje\"\n\nreturn {\n  firstname: firstname,\n  lastname: lastname,\n}\n```\n\nThanks to ES6, you can directly write:\n\n```js\nconst firstname = \"Robert\"\nconst lastname = \"Laiponje\"\n\nreturn {\n  firstname,\n  lastname,\n}\n// { firstname: \"Robert\", lastname: \"Laiponje\" }\n```\n\nIn the same spirit, you will be able to declare methods without the `function`\nkeyword (this also apply for *getter* and *setter*).\n\n```js\nconst obj = {\n  get email() {\n    return this.email()\n  },\n  set email(email) {\n    this.email = email\n  },\n  validateEmail(email) {\n    return true\n  },\n}\n```\n\n## Dynamic property name\n\nOne last thing for *objects literal* will allow you to create dynamic property\nname using an expression, directly when you create an object.\nWith ES5 you have to do that in two steps:\n\n```js\nfunction action(type, data) {\n  var payload = {}\n  payload[type] = data\n  return payload\n}\n```\n\nNow with ES6, you can do:\n\n```js\nfunction action(type, data) {\n  return {\n    [type]: data\n  }\n}\n```\n\n**Note:** with dynamic properties, declaring multiples properties with the same\nname is accepted and do not throw an error. Keep in mind that only the last\nvalue will be kept.\n","__filename":"en/articles/js/es2015/object-literals.md","__url":"/en/articles/js/es2015/object-literals/","__resourceUrl":"/en/articles/js/es2015/object-literals/index.html","__dataUrl":"/en/articles/js/es2015/object-literals/index.html.1236fdd140c603ee85d51158c5d4aa72.json"}