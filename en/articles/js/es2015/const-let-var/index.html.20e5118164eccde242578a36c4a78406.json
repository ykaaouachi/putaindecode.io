{"head":{"layout":"Post","comments":true,"date":"2015-12-01","title":"ES6, ES2015: declaring variables with const, let and var","tags":["JavaScript","ES6","ES2015"],"authors":["Nyalab"],"translators":["MoOx"],"description":"ES6 (also known as ES2015) brings you new ways to declare your variables thanks to let and const, but also keeps var in the languageâ€¦"},"body":"<p>ES6 (also known as ES2015) brings you new ways to declare your variables thanks\nto <code>let</code> and <code>const</code>, but also keeps <code>var</code> in the language specification.</p>\n<p>The first thing you need to do: forget everything you know about <code>var</code>.</p>\n<h1 id=\"declarations\"><a href=\"#declarations\" class=\"phenomic-HeadingAnchor\">#</a>Declarations</h1>\n<h2 id=\"const\"><a href=\"#const\" class=\"phenomic-HeadingAnchor\">#</a>const</h2>\n<p><code>const</code> allows you to declare a single assignment variable lexically bound.\nSounds posh right? That just means that you can only assign once a value in a\nvariable, scoped at the block level.</p>\n<p>If you have already read stuff about <code>const</code>, be careful: this is not a way to\ndeclare immutable variables. Only the assigned reference is immutable, not the\nvalue. This means that the content of an array or an object declared using\n<code>const</code> can evolve but the re-assignment of the reference is impossible.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">fn</span>(<span class=\"hljs-params\"></span>) </span>{\n  <span class=\"hljs-keyword\">const</span> foo = <span class=\"hljs-string\">\"bar\"</span>\n  <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-literal\">true</span>) {\n    <span class=\"hljs-keyword\">const</span> foo <span class=\"hljs-comment\">// SyntaxError, variable needs to be assigned to something</span>\n    <span class=\"hljs-keyword\">const</span> foo = <span class=\"hljs-string\">\"qux\"</span>\n    foo = <span class=\"hljs-string\">\"norf\"</span> <span class=\"hljs-comment\">// SyntaxError, variable cannot be re-assigned</span>\n    <span class=\"hljs-built_in\">console</span>.log(foo)\n    <span class=\"hljs-comment\">// \"qux\", variable belongs to the scope of the current block (the \"if\" one)</span>\n  }\n  <span class=\"hljs-built_in\">console</span>.log(foo)\n  <span class=\"hljs-comment\">// \"bar\", variable belongs to the scope of the \"fn\" function</span>\n}</code></pre>\n<p>Just a fancy trick using <code>const</code> with an iterator:</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">fn</span>(<span class=\"hljs-params\"></span>) </span>{\n  <span class=\"hljs-keyword\">const</span> arr = [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>]\n  <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">const</span> el <span class=\"hljs-keyword\">of</span> arr) {\n    <span class=\"hljs-built_in\">console</span>.log(el)\n  }\n}</code></pre>\n<p>You might think a <code>let</code> should be used here but the declaration is evaluated\non each iteration, so <code>const</code> fits better here.</p>\n<h2 id=\"let\"><a href=\"#let\" class=\"phenomic-HeadingAnchor\">#</a>let</h2>\n<p><code>let</code> allows you to do the same as <code>const</code> without the single assignment\nconstraint. So you can understand here that the use-cases are the same as for\nits ancestor, <code>var</code>.\nBy the way, you might have been told that <em><code>let</code> is the new <code>var</code></em>.\nIt is partly true because it can do the same, but even better if we consider\nthe ability of the variable to be scoped to the block level.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">fn</span>(<span class=\"hljs-params\"></span>) </span>{\n  <span class=\"hljs-keyword\">let</span> foo = <span class=\"hljs-string\">\"bar\"</span>\n  <span class=\"hljs-keyword\">var</span> foo2 = <span class=\"hljs-string\">\"bar\"</span>\n  <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-literal\">true</span>) {\n    <span class=\"hljs-keyword\">let</span> foo <span class=\"hljs-comment\">// that's ok (foo === undefined)</span>\n    <span class=\"hljs-keyword\">var</span> foo2\n    <span class=\"hljs-comment\">// Be careful, `var` statements are not scoped to the block level</span>\n    <span class=\"hljs-comment\">// so previous foo2 is overwritten!</span>\n    foo = <span class=\"hljs-string\">\"qux\"</span>\n    foo2 = <span class=\"hljs-string\">\"qux\"</span>\n    <span class=\"hljs-built_in\">console</span>.log(foo)\n    <span class=\"hljs-comment\">// \"qux\", variable belongs to the scope of the current block (the \"if\" one)</span>\n    <span class=\"hljs-built_in\">console</span>.log(foo2)\n    <span class=\"hljs-comment\">// \"qux\"</span>\n  }\n  <span class=\"hljs-built_in\">console</span>.log(foo)\n  <span class=\"hljs-comment\">// \"bar\", variable belongs to the scope of its block (the \"fn\" function)</span>\n  <span class=\"hljs-built_in\">console</span>.log(foo2)\n  <span class=\"hljs-comment\">// \"qux\"</span>\n}</code></pre>\n<p>You can use <code>let</code> in loops, the variable used for the iteration will be scoped\nto the block of the loop, not the (parent) scope of the code that contains the\nloop. This resolves any issues that you may have had with <code>i</code> already defined in\nthe upper scope!</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">fn2</span>(<span class=\"hljs-params\"></span>) </span>{\n  <span class=\"hljs-keyword\">let</span> i = <span class=\"hljs-number\">0</span>\n  <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> i=i; i&#x3C;<span class=\"hljs-number\">10</span>; i++) {\n    <span class=\"hljs-built_in\">console</span>.log(i)\n  }\n  <span class=\"hljs-built_in\">console</span>.log(i)\n  <span class=\"hljs-comment\">// 0</span>\n\n  <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> j=i; j&#x3C;<span class=\"hljs-number\">10</span>; j++) {}\n  <span class=\"hljs-built_in\">console</span>.log(j)\n  <span class=\"hljs-comment\">// j is not defined</span>\n}\nfn2() <span class=\"hljs-comment\">// 0, 1, 2, 3, 4, 5, 6, 7, 8, 9</span></code></pre>\n<p>Note: the example with <code>const</code> used in the <code>for ... of</code> loop cannot be\nreproduced here.\nThe classic <code>for</code> loop is imperative, and the declaration is only made once when\nthe loop starts. <code>const</code> is not relevant in this case.</p>\n<h2 id=\"var\"><a href=\"#var\" class=\"phenomic-HeadingAnchor\">#</a>var</h2>\n<p>With <code>const</code> and <code>let</code>, there is no more space for <code>var</code> anymore.\n<a href=\"https://twitter.com/getify/status/658662478528643072\">Maybe in a <code>try</code>/<code>catch</code>\ncontext</a>.</p>\n<h1 id=\"hoisting-and-tdz-temporal-dead-zone-issues\"><a href=\"#hoisting-and-tdz-temporal-dead-zone-issues\" class=\"phenomic-HeadingAnchor\">#</a>Hoisting and TDZ (Temporal Dead Zone) issues</h1>\n<p>As a reminder, JavaScript does have a hoisting mechanism. For example, you can\nwrite:</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">fn</span>(<span class=\"hljs-params\"></span>) </span>{\n  <span class=\"hljs-built_in\">console</span>.log(foo) <span class=\"hljs-comment\">// undefined (no ReferenceError)</span>\n  <span class=\"hljs-keyword\">var</span> foo = <span class=\"hljs-string\">\"bar\"</span>\n}</code></pre>\n<p>JavaScript engine will read all <code>var</code> declarations and virtually move those at\nthe start of your function scope.</p>\n<p><code>let</code> and <code>const</code> do not benefit from variable hoisting, and therefore can\ncreate TDZ (Temporal Dead Zone) issues; these occur when a variable does not\nexist yet.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">fn</span>(<span class=\"hljs-params\"></span>) </span>{\n  <span class=\"hljs-built_in\">console</span>.log(foo)\n  <span class=\"hljs-comment\">// ReferenceError, we are in the TDZ of \"foo\"</span>\n  <span class=\"hljs-keyword\">let</span> foo = <span class=\"hljs-string\">\"bar\"</span>\n}</code></pre>\n<h1 id=\"outro\"><a href=\"#outro\" class=\"phenomic-HeadingAnchor\">#</a>Outro</h1>\n<p>So, let's recap:</p>\n<ul>\n<li>Use <code>const</code> (might be relevant 99% of the time)</li>\n<li>If during you development you happen to have to change the value of this\nvariable, switch to <code>let</code> (that might happen 1% of the time)</li>\n<li>If you are in the worst use-case of the world, use <code>var</code> (you can do the math)</li>\n</ul>\n","rawBody":"\nES6 (also known as ES2015) brings you new ways to declare your variables thanks\nto `let` and `const`, but also keeps `var` in the language specification.\n\nThe first thing you need to do: forget everything you know about `var`.\n\n# Declarations\n\n## const\n\n`const` allows you to declare a single assignment variable lexically bound.\nSounds posh right? That just means that you can only assign once a value in a\nvariable, scoped at the block level.\n\nIf you have already read stuff about `const`, be careful: this is not a way to\ndeclare immutable variables. Only the assigned reference is immutable, not the\nvalue. This means that the content of an array or an object declared using\n`const` can evolve but the re-assignment of the reference is impossible.\n\n```js\nfunction fn() {\n  const foo = \"bar\"\n  if (true) {\n    const foo // SyntaxError, variable needs to be assigned to something\n    const foo = \"qux\"\n    foo = \"norf\" // SyntaxError, variable cannot be re-assigned\n    console.log(foo)\n    // \"qux\", variable belongs to the scope of the current block (the \"if\" one)\n  }\n  console.log(foo)\n  // \"bar\", variable belongs to the scope of the \"fn\" function\n}\n```\n\nJust a fancy trick using `const` with an iterator:\n\n```js\nfunction fn() {\n  const arr = [1, 2, 3]\n  for (const el of arr) {\n    console.log(el)\n  }\n}\n```\n\nYou might think a `let` should be used here but the declaration is evaluated\non each iteration, so `const` fits better here.\n\n## let\n\n`let` allows you to do the same as `const` without the single assignment\nconstraint. So you can understand here that the use-cases are the same as for\nits ancestor, `var`.\nBy the way, you might have been told that *`let` is the new `var`*.\nIt is partly true because it can do the same, but even better if we consider\nthe ability of the variable to be scoped to the block level.\n\n```js\nfunction fn() {\n  let foo = \"bar\"\n  var foo2 = \"bar\"\n  if (true) {\n    let foo // that's ok (foo === undefined)\n    var foo2\n    // Be careful, `var` statements are not scoped to the block level\n    // so previous foo2 is overwritten!\n    foo = \"qux\"\n    foo2 = \"qux\"\n    console.log(foo)\n    // \"qux\", variable belongs to the scope of the current block (the \"if\" one)\n    console.log(foo2)\n    // \"qux\"\n  }\n  console.log(foo)\n  // \"bar\", variable belongs to the scope of its block (the \"fn\" function)\n  console.log(foo2)\n  // \"qux\"\n}\n```\n\nYou can use `let` in loops, the variable used for the iteration will be scoped\nto the block of the loop, not the (parent) scope of the code that contains the\nloop. This resolves any issues that you may have had with `i` already defined in\nthe upper scope!\n\n```js\nfunction fn2() {\n  let i = 0\n  for (let i=i; i<10; i++) {\n    console.log(i)\n  }\n  console.log(i)\n  // 0\n\n  for (let j=i; j<10; j++) {}\n  console.log(j)\n  // j is not defined\n}\nfn2() // 0, 1, 2, 3, 4, 5, 6, 7, 8, 9\n```\n\nNote: the example with `const` used in the `for ... of` loop cannot be\nreproduced here.\nThe classic `for` loop is imperative, and the declaration is only made once when\nthe loop starts. `const` is not relevant in this case.\n\n## var\n\nWith `const` and `let`, there is no more space for `var` anymore.\n[Maybe in a `try`/`catch`\ncontext](https://twitter.com/getify/status/658662478528643072).\n\n# Hoisting and TDZ (Temporal Dead Zone) issues\n\nAs a reminder, JavaScript does have a hoisting mechanism. For example, you can\nwrite:\n\n```js\nfunction fn() {\n  console.log(foo) // undefined (no ReferenceError)\n  var foo = \"bar\"\n}\n```\n\nJavaScript engine will read all `var` declarations and virtually move those at\nthe start of your function scope.\n\n`let` and `const` do not benefit from variable hoisting, and therefore can\ncreate TDZ (Temporal Dead Zone) issues; these occur when a variable does not\nexist yet.\n\n```js\nfunction fn() {\n  console.log(foo)\n  // ReferenceError, we are in the TDZ of \"foo\"\n  let foo = \"bar\"\n}\n```\n\n# Outro\n\nSo, let's recap:\n\n- Use `const` (might be relevant 99% of the time)\n- If during you development you happen to have to change the value of this\nvariable, switch to `let` (that might happen 1% of the time)\n- If you are in the worst use-case of the world, use `var` (you can do the math)\n","__filename":"en/articles/js/es2015/const-let-var.md","__url":"/en/articles/js/es2015/const-let-var/","__resourceUrl":"/en/articles/js/es2015/const-let-var/index.html","__dataUrl":"/en/articles/js/es2015/const-let-var/index.html.20e5118164eccde242578a36c4a78406.json"}