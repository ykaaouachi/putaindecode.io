{"head":{"layout":"Post","comments":true,"date":"2014-06-04","title":"Introduction to ReactJS","tags":["javascript","reactjs"],"authors":["bloodyowl"],"translators":["skinnyfoetusboy"],"description":"It's been quite some time since ReactJS has been open-sourced by facebook. Let's take it as an opportunity to introduce the last-born child…"},"body":"<p>It's been quite some time since ReactJS has been open-sourced by facebook.\nLet's take it as an opportunity to introduce the last-born child of the MV* trend.</p>\n<h2 id=\"different-takes-on-ui\"><a href=\"#different-takes-on-ui\" class=\"phenomic-HeadingAnchor\">#</a>Different takes on UI</h2>\n<h3 id=\"backbone\"><a href=\"#backbone\" class=\"phenomic-HeadingAnchor\">#</a>Backbone</h3>\n<p><a href=\"http://backbonejs.org\">Backbone</a> brings a simplification in events declaration,\nbut doesn't handle that much rendering.\nMaking the developer the sole master of <code>Backbone.View</code>\nis positive for several kinds of projects, but makes\nDOM manipulation tedious.</p>\n<p>On the subject of data-binding, <code>Backbone</code> doesn't actually come\nwith any in-house solutions and you're stuck with using mixins to\nimplement it without resorting to gnawing your own legs off.</p>\n<p>Moreover, it's usually a templating engine <em>à la</em> Handlebars or Jade\nthat creates the original view. Thus, you find yourself with some sort\nof <code>this.$el.html(this.template(data))</code> in your <code>render()</code> method which\nwill leave you with a few UX aberrations like your pictures re-rendering\nthemselves or videos playing back from the start.</p>\n<p>In a nutshell, Backbone is pretty useful to help you structure your code, but it is absolutely lackluster in\ndiminishing DOM-related complexity concerning the UI of your app.</p>\n<h3 id=\"angular\"><a href=\"#angular\" class=\"phenomic-HeadingAnchor\">#</a>Angular</h3>\n<p><a href=\"https://angularjs.org\">Angular</a> brings a more in-depth approach\nby imposing its own templating engine (which allows preprocessing)\nand making you able to declare data-bindings with a <code>{{mustache}}</code>-like\nsyntax.</p>\n<p>Events are declarated in much the same way, using <code>ng-{eventName}</code> attributes.</p>\n<p>Basically, Angular is technically really interesting (but don't get me started\non dirty checking).</p>\n<h3 id=\"ember\"><a href=\"#ember\" class=\"phenomic-HeadingAnchor\">#</a>Ember</h3>\n<p><a href=\"http://emberjs.com\">Ember</a> is a well-thought and well-developed framework.\nIt integrates <code>data-binding</code> thanks to <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/range\">DOM Ranges</a>.\nIt also has strong design patterns and contrary to what people commonly\nthink, it's actually pretty straightforward.\nSubviews are also pretty easy to use thanks to <code>{{outlet}}</code>.</p>\n<p>In other words, Ember and Angular both come bundled with real\nsolutions for UI management. But they also share the same way to\ndo it:</p>\n<ul>\n<li><em>rendering</em> (creating and inserting DOM nodes) once</li>\n<li>updating the bindings</li>\n</ul>\n<h3 id=\"react\"><a href=\"#react\" class=\"phenomic-HeadingAnchor\">#</a>React</h3>\n<p><a href=\"http://facebook.github.io/react/\">React</a> brings a completely different approach.\nIt has one simple way of going about stuff:\nmanaging the DOM state is a bloody mess.</p>\n<p>Okay, let's just say we call <code>.render()</code> everytime anything changes.\nSounds dumb, right? Actually not that much.</p>\n<p>React implements a <strong>virtual DOM</strong>,\na blazing-fast internal representation of the DOM. It comes with its own events system\nwhich allows React to bring a consistent event system to browsers that don't have\n<code>EventTarget</code> (looking at you, IE8).</p>\n<p>The <code>render</code> method returns objects corresponding to the internal representation\nof the virtual DOM.</p>\n<p>React classes are defined by their <code>state</code>.\nWhen creating a class, you specify a <code>getInitialState</code> method which\nwill return the initial state.</p>\n<p>After that, the only way to modify the state is to pass the values\nof the state which have changed to <code>this.setState</code> so that it can update\nthe DOM.</p>\n<p>A React class takes properties when it's instanciated: they're called <code>props</code>.\nThey shouldn't be confused with the <code>state</code>, their content should only be manipulated\nfrom <em>outside</em> the class (even though it can still get default values by\nspecifying a <code>getDefaultProps</code> method which will return them).</p>\n<p>The <code>state</code>, however, should only be modified by the class' own methods.</p>\n<p>The main advantage to this is that you're always sure, thanks to the systematic\ncall to <code>render</code>, that your React component will have the expected representation.</p>\n<p>Another advantage to React is its in-house diff algorithm.\nThe virtual DOM gets diffed against the previous one (which is the one you actually see),\nand React works out the smallest amount of operations needed in order to update the\nDOM.</p>\n<p>This solves a few issues like keeping track of the caret's position in a text\nfield that uses two-way data-binding: since the algorithm doesn't see any reason\nto update it, the text field doesn't get re-rendered and you keep the focus.\nIn the same way, if you've got a gif looping somewhere in your page, it will keep\nplaying as it normally would.</p>\n<p>React plays very well with JSX, a superset of JS which\nallows you to write your templates with an XML syntax (see example below),\nallowing beginners to get stuff done with it quickly.</p>\n<h2 id=\"lets-create-a-react-component\"><a href=\"#lets-create-a-react-component\" class=\"phenomic-HeadingAnchor\">#</a>Let's create a React component:</h2>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-keyword\">var</span> View = React.createClass({\n  <span class=\"hljs-attr\">getInitialState</span> : <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>)</span>{\n    <span class=\"hljs-comment\">// initial state</span>\n    <span class=\"hljs-keyword\">return</span> {\n      <span class=\"hljs-attr\">checked</span> : <span class=\"hljs-literal\">false</span>\n    }\n  },\n  <span class=\"hljs-attr\">getDefaultProps</span> : <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>)</span>{\n    <span class=\"hljs-comment\">// if `this.props.label` isn't defined, then `\"?\"` will be used</span>\n    <span class=\"hljs-keyword\">return</span> {\n      <span class=\"hljs-attr\">label</span> : <span class=\"hljs-string\">\"?\"</span>\n    }\n  },\n  <span class=\"hljs-attr\">toggle</span> : <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>)</span>{\n    <span class=\"hljs-comment\">// creates a new state (React states are immutable)</span>\n    <span class=\"hljs-comment\">// and we trigger the rendering</span>\n    <span class=\"hljs-keyword\">this</span>.setState({\n      <span class=\"hljs-attr\">checked</span> : !<span class=\"hljs-keyword\">this</span>.state.checked\n    })\n  },\n  <span class=\"hljs-attr\">render</span> : <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>)</span>{\n    <span class=\"hljs-comment\">// little addon that makes life easier</span>\n    <span class=\"hljs-keyword\">var</span> classes = React.addons.classSet({\n      <span class=\"hljs-string\">\"list-item\"</span> : <span class=\"hljs-literal\">true</span>,\n      <span class=\"hljs-string\">\"list-item--valid\"</span> : <span class=\"hljs-keyword\">this</span>.state.checked\n    })\n    <span class=\"hljs-keyword\">return</span> (\n      <span class=\"xml\"><span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">className</span>=<span class=\"hljs-string\">{classes}</span>></span>\n        {/* our binding, simple as that*/}\n        </span>&#x3C;input checked={this.state.checked} type=\"checkbox\" onChange={this.toggle} />\n        {this.props.label}\n      &#x3C;/div><span class=\"xml\">\n    )\n  }\n})\n\n// we mount the component and pass the label to it\nvar view = React.render(</span>&#x3C;View label=\"helloworld\" />, document.getElementById(\"id\"))\n// and voilà!\nview.toggle()</code></pre>\n<h2 id=\"sum-up-of-reacts-advantages\"><a href=\"#sum-up-of-reacts-advantages\" class=\"phenomic-HeadingAnchor\">#</a>Sum up of React's advantages</h2>\n<p>React has this figured out:</p>\n<ul>\n<li>the DOM is slow, particularly when it comes to writing, and it is crucial to limit interactions with it;</li>\n<li>we should not always have to be thinking about the state the DOM at a specific point in time while developing the UI of our component;</li>\n<li>immutability (objects don't change, a new one gets created every time you need to change something in it) and composition (composing a class of several functionnalities without having to create deep and complex chains of inheritance) are really useful and not used nearly as much as they should be in front-end development.</li>\n</ul>\n<p>As a bonus, React, while not imposing a specific library for data and module communication, offers an approach to it, called <a href=\"http://facebook.github.io/flux/docs/overview.html\">flux</a> which is really interesting and gives you a hand to design an app while keeping the React paradigms in mind.</p>\n<p>Last but not least, you can even render your React component from the server, and it will be clever enough to actually recognize your already-generated components and to keep track of their state from then on.\nPretty neat, huh?</p>\n","rawBody":"\nIt's been quite some time since ReactJS has been open-sourced by facebook.\nLet's take it as an opportunity to introduce the last-born child of the MV* trend.\n\n## Different takes on UI\n\n### Backbone\n\n[Backbone](http://backbonejs.org) brings a simplification in events declaration,\nbut doesn't handle that much rendering.\nMaking the developer the sole master of `Backbone.View`\nis positive for several kinds of projects, but makes\nDOM manipulation tedious.\n\nOn the subject of data-binding, `Backbone` doesn't actually come\nwith any in-house solutions and you're stuck with using mixins to\nimplement it without resorting to gnawing your own legs off.\n\nMoreover, it's usually a templating engine *à la* Handlebars or Jade\nthat creates the original view. Thus, you find yourself with some sort\nof `this.$el.html(this.template(data))` in your `render()` method which\nwill leave you with a few UX aberrations like your pictures re-rendering\nthemselves or videos playing back from the start.\n\nIn a nutshell, Backbone is pretty useful to help you structure your code, but it is absolutely lackluster in\ndiminishing DOM-related complexity concerning the UI of your app.\n\n### Angular\n\n[Angular](https://angularjs.org) brings a more in-depth approach\nby imposing its own templating engine (which allows preprocessing)\nand making you able to declare data-bindings with a `{{mustache}}`-like\nsyntax.\n\nEvents are declarated in much the same way, using `ng-{eventName}` attributes.\n\nBasically, Angular is technically really interesting (but don't get me started\non dirty checking).\n\n### Ember\n\n[Ember](http://emberjs.com) is a well-thought and well-developed framework.\nIt integrates `data-binding` thanks to [DOM Ranges](https://developer.mozilla.org/en-US/docs/Web/API/range).\nIt also has strong design patterns and contrary to what people commonly\nthink, it's actually pretty straightforward.\nSubviews are also pretty easy to use thanks to `{{outlet}}`.\n\nIn other words, Ember and Angular both come bundled with real\nsolutions for UI management. But they also share the same way to\ndo it:\n\n- _rendering_ (creating and inserting DOM nodes) once\n- updating the bindings\n\n### React\n\n[React](http://facebook.github.io/react/) brings a completely different approach.\nIt has one simple way of going about stuff:\nmanaging the DOM state is a bloody mess.\n\nOkay, let's just say we call `.render()` everytime anything changes.\nSounds dumb, right? Actually not that much.\n\nReact implements a __virtual DOM__,\na blazing-fast internal representation of the DOM. It comes with its own events system\nwhich allows React to bring a consistent event system to browsers that don't have\n`EventTarget` (looking at you, IE8).\n\nThe `render` method returns objects corresponding to the internal representation\nof the virtual DOM.\n\nReact classes are defined by their `state`.\nWhen creating a class, you specify a `getInitialState` method which\nwill return the initial state.\n\nAfter that, the only way to modify the state is to pass the values\nof the state which have changed to `this.setState` so that it can update\nthe DOM.\n\nA React class takes properties when it's instanciated: they're called `props`.\nThey shouldn't be confused with the `state`, their content should only be manipulated\nfrom _outside_ the class (even though it can still get default values by\nspecifying a `getDefaultProps` method which will return them).\n\nThe `state`, however, should only be modified by the class' own methods.\n\nThe main advantage to this is that you're always sure, thanks to the systematic\ncall to `render`, that your React component will have the expected representation.\n\nAnother advantage to React is its in-house diff algorithm.\nThe virtual DOM gets diffed against the previous one (which is the one you actually see),\nand React works out the smallest amount of operations needed in order to update the\nDOM.\n\nThis solves a few issues like keeping track of the caret's position in a text\nfield that uses two-way data-binding: since the algorithm doesn't see any reason\nto update it, the text field doesn't get re-rendered and you keep the focus.\nIn the same way, if you've got a gif looping somewhere in your page, it will keep\nplaying as it normally would.\n\nReact plays very well with JSX, a superset of JS which\nallows you to write your templates with an XML syntax (see example below),\nallowing beginners to get stuff done with it quickly.\n\n## Let's create a React component:\n\n\n```javascript\nvar View = React.createClass({\n  getInitialState : function(){\n    // initial state\n    return {\n      checked : false\n    }\n  },\n  getDefaultProps : function(){\n    // if `this.props.label` isn't defined, then `\"?\"` will be used\n    return {\n      label : \"?\"\n    }\n  },\n  toggle : function(){\n    // creates a new state (React states are immutable)\n    // and we trigger the rendering\n    this.setState({\n      checked : !this.state.checked\n    })\n  },\n  render : function(){\n    // little addon that makes life easier\n    var classes = React.addons.classSet({\n      \"list-item\" : true,\n      \"list-item--valid\" : this.state.checked\n    })\n    return (\n      <div className={classes}>\n        {/* our binding, simple as that*/}\n        <input checked={this.state.checked} type=\"checkbox\" onChange={this.toggle} />\n        {this.props.label}\n      </div>\n    )\n  }\n})\n\n// we mount the component and pass the label to it\nvar view = React.render(<View label=\"helloworld\" />, document.getElementById(\"id\"))\n// and voilà!\nview.toggle()\n```\n\n## Sum up of React's advantages\n\nReact has this figured out:\n\n- the DOM is slow, particularly when it comes to writing, and it is crucial to limit interactions with it;\n- we should not always have to be thinking about the state the DOM at a specific point in time while developing the UI of our component;\n- immutability (objects don't change, a new one gets created every time you need to change something in it) and composition (composing a class of several functionnalities without having to create deep and complex chains of inheritance) are really useful and not used nearly as much as they should be in front-end development.\n\nAs a bonus, React, while not imposing a specific library for data and module communication, offers an approach to it, called [flux](http://facebook.github.io/flux/docs/overview.html) which is really interesting and gives you a hand to design an app while keeping the React paradigms in mind.\n\nLast but not least, you can even render your React component from the server, and it will be clever enough to actually recognize your already-generated components and to keep track of their state from then on.\nPretty neat, huh?\n","__filename":"en/articles/js/react/index.md","__url":"/en/articles/js/react/","__resourceUrl":"/en/articles/js/react/index.html","__dataUrl":"/en/articles/js/react/index.html.7df1453f67d5a50886ca93b0222abe86.json"}