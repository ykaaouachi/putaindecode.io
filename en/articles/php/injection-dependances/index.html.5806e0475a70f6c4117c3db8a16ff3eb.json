{"head":{"layout":"Post","comments":true,"date":"2014-11-05","title":"Dependency injection with PHP","tags":["php","php-di"],"authors":["neemzy"],"description":"Hi there! I'm here today to tell you about PHP (true story), and specifically the dependency injection mechanism you may not be familiar…"},"body":"<p>Hi there! I'm here today to tell you about PHP (true story), and specifically\nthe dependency injection mechanism you may not be familiar with. Objects,\nfactories and containers are on the way, so put on your docker cap and gloves\nand let's move shit around!</p>\n<h2 id=\"dependency-injection-what-the-hell-is-that\"><a href=\"#dependency-injection-what-the-hell-is-that\" class=\"phenomic-HeadingAnchor\">#</a>Dependency injection? What the hell is that?</h2>\n<p>If you're into object-oriented programming, I'd bet you've stumbled upon the\nword before. As for us PHP folks, we mainly started to hear about it with the\nadvent of Symfony, which is now the main web framework for the language. Fabien\nPotencier, its creator and lead developer, explains the concept on <a href=\"http://fabien.potencier.org/article/11/what-is-dependency-injection\">his blog</a>\nby quoting the following definition:</p>\n<blockquote>\n<p><em>Dependency Injection is where components are given their dependencies through their constructors, methods, or directly into fields.</em></p>\n<p>Someone</p>\n</blockquote>\n<p>Crystal clear, isn't it? It isn't? Well. Let's picture a piece of a PHP app,\nwhere we want to manage people, each of which has a postal address. If you\nhaven't been sleeping to much in college on Friday mornings following your\nThursday night binge drinking sessions, you may eventually conclude on your own\nwe're going to need two classes, namely <code>Person</code> and <code>Address</code>:</p>\n<pre><code class=\"hljs language-php\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Address</span>\n</span>{\n    <span class=\"hljs-keyword\">private</span> $number;\n    <span class=\"hljs-keyword\">private</span> $street;\n    <span class=\"hljs-keyword\">private</span> $zipcode;\n    <span class=\"hljs-keyword\">private</span> $city;\n\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">__construct</span><span class=\"hljs-params\">($number, $street, $zipcode, $city)</span>\n    </span>{\n        <span class=\"hljs-keyword\">$this</span>->number = $number;\n        <span class=\"hljs-keyword\">$this</span>->street = $street;\n        <span class=\"hljs-keyword\">$this</span>->zipcode = $zipcode;\n        <span class=\"hljs-keyword\">$this</span>->city = $city;\n    }\n}\n\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Person</span>\n</span>{\n    <span class=\"hljs-keyword\">private</span> $address;\n}</code></pre>\n<p>I bet you noticed I didn't write the constructor for <code>Person</code>. That's on\npurpose. A naive developer may do it as follows:</p>\n<pre><code class=\"hljs language-php\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Person</span>\n</span>{\n    <span class=\"hljs-keyword\">private</span> $address;\n\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">__construct</span><span class=\"hljs-params\">($number, $street, $zipcode, $city)</span>\n    </span>{\n        <span class=\"hljs-keyword\">$this</span>->address = <span class=\"hljs-keyword\">new</span> Address($number, $street, $zipcode, $city);\n    }\n}\n\n$person = <span class=\"hljs-keyword\">new</span> Person(<span class=\"hljs-number\">5</span>, <span class=\"hljs-string\">'Allée des Rosiers'</span>, <span class=\"hljs-number\">78670</span>, <span class=\"hljs-string\">'Villennes-sur-Seine'</span>);</code></pre>\n<p>So yeah, well, that works, and instantiating a person and its address only takes\na single line of code. The problem is that this way of doing makes <code>Person</code> and\n<code>Address</code> <strong>tightly coupled</strong>: the <code>Person</code> class is unusable without <code>Address</code>,\nand worse, the former's internal code would be impacted by any change on the\nlatter.</p>\n<p>Not convinced, are you? What's going to happen the day we raise 10 million\ndollars to internationalize our app?</p>\n<pre><code class=\"hljs language-php\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Address</span>\n</span>{\n    <span class=\"hljs-comment\">// ...</span>\n    <span class=\"hljs-keyword\">private</span> $country;\n\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">__construct</span><span class=\"hljs-params\">($number, $street, $zipcode, $city, $country)</span>\n    </span>{\n        <span class=\"hljs-comment\">// ...</span>\n        <span class=\"hljs-keyword\">$this</span>->country = $country;\n    }\n}</code></pre>\n<p>Oh, we now have to evolve the <code>Person</code> constructor to add the new <code>$country</code>\nparameter symmetrically. Bummers.</p>\n<p>Ideally, the <code>Person</code> class should give no shit about how <code>Address</code> works\ninternally. A person still needs an address, but it most certainly doesn't mean\nit is this class's business to craft it. So, how do we achieve that? Quite\nsimply, actually:</p>\n<pre><code class=\"hljs language-php\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Person</span>\n</span>{\n    <span class=\"hljs-keyword\">private</span> $address;\n\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">__construct</span><span class=\"hljs-params\">(Address $address)</span>\n    </span>{\n        <span class=\"hljs-keyword\">$this</span>->address = $address;\n    }\n}</code></pre>\n<p>Dependency injection is just that. If a class needs an instance of another\nclass, should it be in its constructor or another method (like a <em>setter</em>), said\nmethod should directly receive this instance as a parameter and absolutely not\ndwelve into the specifics of instantiating it by itself. Doing so helps writing\n<strong>decoupled</strong> code, avoiding interdependency between its components, which makes\nthem <strong>reusable</strong> without having to bring the whole arsenal with, but much more\n<strong>maintenable</strong> as well since each class deals with itself only. In PHP, we also\ntake advantage of object type hinting, which allows us to be totally sure our\nparameter is an instance of the class we want and nothing else.</p>\n<p>Alright, I can already hear you ranting:</p>\n<blockquote>\n<p>Well now I gotta instantiate an address by myself every time I do so with a\nperson, this is shit</p>\n</blockquote>\n<p>If so is your opinion, <del>you'd be better off dead</del> please keep on reading this\narticle with that wild enthusiasm of yours!</p>\n<h2 id=\"factory-to-the-rescue\"><a href=\"#factory-to-the-rescue\" class=\"phenomic-HeadingAnchor\">#</a>Factory to the rescue</h2>\n<p>Don't know if you know, but there is a quite common object-oriented design\npattern named <strong>factory</strong> (hence this part's stupid title).</p>\n<p>The idea, roughly, is to create a class which sole purpose is to instantiate\nother classes, precisely when doing so requires multiple lines of code, in order\nto avoid repeating these. Going on with our example:</p>\n<pre><code class=\"hljs language-php\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">PersonFactory</span>\n</span>{\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">createPerson</span><span class=\"hljs-params\">($number, $street, $zipcode, $city, $country)</span>\n    </span>{\n        $address = <span class=\"hljs-keyword\">new</span> Address($number, $street, $zipcode, $city, $country);\n\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> Person($address);\n    }\n}</code></pre>\n<p>Right now, you may be thinking I'm messing around with you: why bother creating\na class which does exactly what we did directly in <code>Person</code> in the first place?\nBecause you haven't been paying attention, <del>little cu</del> young Padawan. The\ngoal, when using dependency injection, is not to make our classes depend on each\nother if they don't need to. A person does need an address, but we may very well\nimagine using these two classes independently (you'll see how in the next part).\nAs for <code>PersonFactory</code>, it is here to allow us to create a person from an\naddress' ingredients in a single line of code, to preserve simplicity in\nbusiness code as you wished for (and are goddamn right about). But here,\n<code>Person</code> and <code>Address</code> remain usable with or without <code>PersonFactory</code>: mission\ncomplete.</p>\n<p>While we're on the subject of making our lives easier:</p>\n<pre><code class=\"hljs language-php\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">PersonFactory</span>\n</span>{\n    <span class=\"hljs-comment\">// ...</span>\n\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">getZipcodeFromDistrict</span><span class=\"hljs-params\">($district)</span>\n    </span>{\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">75000</span> + $district;\n    }\n\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">createParigot</span><span class=\"hljs-params\">($number, $street, $district)</span>\n    </span>{\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">$this</span>->createPerson($number, $street, <span class=\"hljs-keyword\">$this</span>->getZipcodeFromDistrict($district), <span class=\"hljs-string\">'Paris'</span>, <span class=\"hljs-string\">'France'</span>);\n    }\n}</code></pre>\n<p>Would you have made this sort of thing in <code>Person</code> or <code>Address</code>? I sure hope you\nwouldn't.</p>\n<h2 id=\"yes-an-interface-has-a-purpose\"><a href=\"#yes-an-interface-has-a-purpose\" class=\"phenomic-HeadingAnchor\">#</a>Yes, an interface has a purpose</h2>\n<p>In your white-out student Friday mornings (<em>cf. supra</em>), you may find back some\nscattered memories of a lesson on <strong>interfaces</strong>. If all you can remember is\nthat \"an empty class is freakin' useless\", read on.</p>\n<p>An interface is first and foremost a contract. A class <strong>implementing</strong> an\ninterface commits to implement each and every method the latter declares.\nWithout even reading said class' code, we already know how to play with it and\nhow it's supposed to work.</p>\n<p>Let's use our same old example again and imagine we have to deal with addresses\nthat don't respect the format we've used until now, like a basic address only\nmade of a single string:</p>\n<pre><code class=\"hljs language-php\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">BasicAddress</span>\n</span>{\n    <span class=\"hljs-keyword\">private</span> $address;\n}</code></pre>\n<p>The way things are now, an instance of this class cannot be used with <code>Person</code>\nsince its constructor expects an instance of <code>Address</code>. Let's fix that!</p>\n<pre><code class=\"hljs language-php\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title\">AddressInterface</span>\n</span>{\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">getFullAddress</span><span class=\"hljs-params\">()</span></span>;\n}\n\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">BasicAddress</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title\">AddressInterface</span>\n</span>{\n    <span class=\"hljs-keyword\">private</span> $address;\n\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">getFullAddress</span><span class=\"hljs-params\">()</span>\n    </span>{\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">$this</span>->address;\n    }\n}\n\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Address</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title\">AddressInterface</span>\n</span>{\n    <span class=\"hljs-comment\">// ...</span>\n\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">getFullAddress</span><span class=\"hljs-params\">()</span>\n    </span>{\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">$this</span>->number.<span class=\"hljs-string\">', '</span>.<span class=\"hljs-keyword\">$this</span>->street.<span class=\"hljs-string\">', '</span>.<span class=\"hljs-keyword\">$this</span>->zipcode.<span class=\"hljs-string\">' '</span>.<span class=\"hljs-keyword\">$this</span>->city.<span class=\"hljs-string\">', '</span>.<span class=\"hljs-keyword\">$this</span>->country;\n    }\n}\n\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Person</span>\n</span>{\n    <span class=\"hljs-comment\">// ...</span>\n\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">__construct</span><span class=\"hljs-params\">(AddressInterface $address)</span>\n    </span>{\n        <span class=\"hljs-keyword\">$this</span>->address = $address;\n    }\n\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">getAddress</span><span class=\"hljs-params\">()</span>\n    </span>{\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">$this</span>->address;\n    }\n}\n\n$address = <span class=\"hljs-keyword\">new</span> BasicAddress(<span class=\"hljs-string\">'test test one two one two'</span>);\n$person = <span class=\"hljs-keyword\">new</span> Person($address);\n\n$factory = <span class=\"hljs-keyword\">new</span> PersonFactory();\n$robert = $factory->createParigot(<span class=\"hljs-number\">1</span>, <span class=\"hljs-string\">'Rue de la Paix'</span>, <span class=\"hljs-number\">2</span>);\n\n<span class=\"hljs-keyword\">echo</span>($person->getAddress()->getFullAddress()); <span class=\"hljs-comment\">// 'test test one two one two'</span>\n<span class=\"hljs-keyword\">echo</span>($robert->getAddress()->getFullAddress()); <span class=\"hljs-comment\">// '1, rue de la Paix, 75002 Paris, France'</span></code></pre>\n<p>See the point? By asking for an instance of <em>any</em> class implementing\n<code>AddressInterface</code> instead of an instance of <code>Address</code> specifically, we loosen\neven more the coupling between our classes. No matter how we create a person,\nshould it be with <code>Address</code> or <code>BasicAddress</code>, we'll be able to print the actual\naddress the same way.</p>\n<h2 id=\"bitch-please-contain-your-orgasms\"><a href=\"#bitch-please-contain-your-orgasms\" class=\"phenomic-HeadingAnchor\">#</a>Bitch please, contain your orgasms</h2>\n<p>You may have frowned upon a detail in that last part: the fact we didn't make\n<code>PersonFactory</code> a static class (bwaaah) means we have to instantiate it to be\nable to use it; without a doubt, this has lead you to think \"lel, gunna have\n<code>new SomethingFactory()</code> all over da place to instantiate my shit\". Once again,\ndependency injection can help, although indirectly: with a dependency injection\ncontainer.</p>\n<p>A container (should be enough) can pretty much be compared to a huge factory\nthat can instantiate multiple classes. In actuality, to avoid having to write\nand maintain some monolithic, god-like class, we'll rather make it call the\nother factories. Once more with our example:</p>\n<pre><code class=\"hljs language-php\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">DependencyInjectionContainer</span>\n</span>{\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">getPersonFactory</span><span class=\"hljs-params\">()</span>\n    </span>{\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> PersonFactory();\n    }\n}</code></pre>\n<p>But it obviously doesn't stop there. When using dependency injection on a large\nscale, we often find ourselves having to manually instantiate objects we need.\nIn some cases, these objects are always the same, like factories but not only:\nthink about the various libraries used in a web project. Wouldn't it be great to\nhave instant access to these objects through the container?</p>\n<pre><code class=\"hljs language-php\">$container = <span class=\"hljs-keyword\">new</span> DependencyInjectionContainer();\n\n$container->getOrm()->performSomeNaughtyQuery();\n$container->getTwig()->renderUglyTemplate();\n$container->getTranslator()->translate(<span class=\"hljs-string\">'Putain de code !'</span>);</code></pre>\n<p>Objects managed in such a fashion thus become <strong>services</strong> of your application.</p>\n<blockquote>\n<p>Does that mean services are instantiated for each call?</p>\n</blockquote>\n<p>Not necessarily! There are mechanisms allowing us to keep a single instance and\nserve it on subsequent calls. This is out of this article's scope, but you can\ntake a look at <a href=\"http://php-di.org/\">PHP-DI</a>, a nicely done dependency injection\ncontainer library you can use in your own project.</p>\n<h2 id=\"the-end\"><a href=\"#the-end\" class=\"phenomic-HeadingAnchor\">#</a>The end</h2>\n<p>If you're a PHP developer, I hope I could show you how to write more\nmaintenable, elegant code by making use of dependency injection. If you're not,\nbe aware that this concept is quite common in object-oriented programming in\ngeneral - after all, <a href=\"https://docs.angularjs.org/guide/di\">it's even in Angular</a>.</p>\n<p>Happy coding, and remember, pushing to production on Friday is bad. Now, go!</p>\n","rawBody":"\nHi there! I'm here today to tell you about PHP (true story), and specifically\nthe dependency injection mechanism you may not be familiar with. Objects,\nfactories and containers are on the way, so put on your docker cap and gloves\nand let's move shit around!\n\n## Dependency injection? What the hell is that?\n\nIf you're into object-oriented programming, I'd bet you've stumbled upon the\nword before. As for us PHP folks, we mainly started to hear about it with the\nadvent of Symfony, which is now the main web framework for the language. Fabien\nPotencier, its creator and lead developer, explains the concept on [his blog](http://fabien.potencier.org/article/11/what-is-dependency-injection)\nby quoting the following definition:\n\n> *Dependency Injection is where components are given their dependencies through their constructors, methods, or directly into fields.*\n>\n> Someone\n\nCrystal clear, isn't it? It isn't? Well. Let's picture a piece of a PHP app,\nwhere we want to manage people, each of which has a postal address. If you\nhaven't been sleeping to much in college on Friday mornings following your\nThursday night binge drinking sessions, you may eventually conclude on your own\nwe're going to need two classes, namely `Person` and `Address`:\n\n```php\nclass Address\n{\n    private $number;\n    private $street;\n    private $zipcode;\n    private $city;\n\n    public function __construct($number, $street, $zipcode, $city)\n    {\n        $this->number = $number;\n        $this->street = $street;\n        $this->zipcode = $zipcode;\n        $this->city = $city;\n    }\n}\n\nclass Person\n{\n    private $address;\n}\n```\n\nI bet you noticed I didn't write the constructor for `Person`. That's on\npurpose. A naive developer may do it as follows:\n\n```php\nclass Person\n{\n    private $address;\n\n    public function __construct($number, $street, $zipcode, $city)\n    {\n        $this->address = new Address($number, $street, $zipcode, $city);\n    }\n}\n\n$person = new Person(5, 'Allée des Rosiers', 78670, 'Villennes-sur-Seine');\n```\n\nSo yeah, well, that works, and instantiating a person and its address only takes\na single line of code. The problem is that this way of doing makes `Person` and\n`Address` **tightly coupled**: the `Person` class is unusable without `Address`,\nand worse, the former's internal code would be impacted by any change on the\nlatter.\n\nNot convinced, are you? What's going to happen the day we raise 10 million\ndollars to internationalize our app?\n\n```php\nclass Address\n{\n    // ...\n    private $country;\n\n    public function __construct($number, $street, $zipcode, $city, $country)\n    {\n        // ...\n        $this->country = $country;\n    }\n}\n```\n\nOh, we now have to evolve the `Person` constructor to add the new `$country`\nparameter symmetrically. Bummers.\n\nIdeally, the `Person` class should give no shit about how `Address` works\ninternally. A person still needs an address, but it most certainly doesn't mean\nit is this class's business to craft it. So, how do we achieve that? Quite\nsimply, actually:\n\n```php\nclass Person\n{\n    private $address;\n\n    public function __construct(Address $address)\n    {\n        $this->address = $address;\n    }\n}\n```\n\nDependency injection is just that. If a class needs an instance of another\nclass, should it be in its constructor or another method (like a *setter*), said\nmethod should directly receive this instance as a parameter and absolutely not\ndwelve into the specifics of instantiating it by itself. Doing so helps writing\n**decoupled** code, avoiding interdependency between its components, which makes\nthem **reusable** without having to bring the whole arsenal with, but much more\n**maintenable** as well since each class deals with itself only. In PHP, we also\ntake advantage of object type hinting, which allows us to be totally sure our\nparameter is an instance of the class we want and nothing else.\n\nAlright, I can already hear you ranting:\n\n> Well now I gotta instantiate an address by myself every time I do so with a\nperson, this is shit\n\nIf so is your opinion, ~~you'd be better off dead~~ please keep on reading this\narticle with that wild enthusiasm of yours!\n\n## Factory to the rescue\n\nDon't know if you know, but there is a quite common object-oriented design\npattern named **factory** (hence this part's stupid title).\n\nThe idea, roughly, is to create a class which sole purpose is to instantiate\nother classes, precisely when doing so requires multiple lines of code, in order\nto avoid repeating these. Going on with our example:\n\n```php\nclass PersonFactory\n{\n    public function createPerson($number, $street, $zipcode, $city, $country)\n    {\n        $address = new Address($number, $street, $zipcode, $city, $country);\n\n        return new Person($address);\n    }\n}\n```\n\nRight now, you may be thinking I'm messing around with you: why bother creating\na class which does exactly what we did directly in `Person` in the first place?\nBecause you haven't been paying attention, ~~little cu~~ young Padawan. The\ngoal, when using dependency injection, is not to make our classes depend on each\nother if they don't need to. A person does need an address, but we may very well\nimagine using these two classes independently (you'll see how in the next part).\nAs for `PersonFactory`, it is here to allow us to create a person from an\naddress' ingredients in a single line of code, to preserve simplicity in\nbusiness code as you wished for (and are goddamn right about). But here,\n`Person` and `Address` remain usable with or without `PersonFactory`: mission\ncomplete.\n\nWhile we're on the subject of making our lives easier:\n\n```php\nclass PersonFactory\n{\n    // ...\n\n    private function getZipcodeFromDistrict($district)\n    {\n        return 75000 + $district;\n    }\n\n    public function createParigot($number, $street, $district)\n    {\n        return $this->createPerson($number, $street, $this->getZipcodeFromDistrict($district), 'Paris', 'France');\n    }\n}\n```\n\nWould you have made this sort of thing in `Person` or `Address`? I sure hope you\nwouldn't.\n\n## Yes, an interface has a purpose\n\nIn your white-out student Friday mornings (*cf. supra*), you may find back some\nscattered memories of a lesson on **interfaces**. If all you can remember is\nthat \"an empty class is freakin' useless\", read on.\n\nAn interface is first and foremost a contract. A class **implementing** an\ninterface commits to implement each and every method the latter declares.\nWithout even reading said class' code, we already know how to play with it and\nhow it's supposed to work.\n\nLet's use our same old example again and imagine we have to deal with addresses\nthat don't respect the format we've used until now, like a basic address only\nmade of a single string:\n\n```php\nclass BasicAddress\n{\n    private $address;\n}\n```\n\nThe way things are now, an instance of this class cannot be used with `Person`\nsince its constructor expects an instance of `Address`. Let's fix that!\n\n```php\ninterface AddressInterface\n{\n    public function getFullAddress();\n}\n\nclass BasicAddress implements AddressInterface\n{\n    private $address;\n\n    public function getFullAddress()\n    {\n        return $this->address;\n    }\n}\n\nclass Address implements AddressInterface\n{\n    // ...\n\n    public function getFullAddress()\n    {\n        return $this->number.', '.$this->street.', '.$this->zipcode.' '.$this->city.', '.$this->country;\n    }\n}\n\nclass Person\n{\n    // ...\n\n    public function __construct(AddressInterface $address)\n    {\n        $this->address = $address;\n    }\n\n    public function getAddress()\n    {\n        return $this->address;\n    }\n}\n\n$address = new BasicAddress('test test one two one two');\n$person = new Person($address);\n\n$factory = new PersonFactory();\n$robert = $factory->createParigot(1, 'Rue de la Paix', 2);\n\necho($person->getAddress()->getFullAddress()); // 'test test one two one two'\necho($robert->getAddress()->getFullAddress()); // '1, rue de la Paix, 75002 Paris, France'\n```\n\nSee the point? By asking for an instance of *any* class implementing\n`AddressInterface` instead of an instance of `Address` specifically, we loosen\neven more the coupling between our classes. No matter how we create a person,\nshould it be with `Address` or `BasicAddress`, we'll be able to print the actual\naddress the same way.\n\n## Bitch please, contain your orgasms\n\nYou may have frowned upon a detail in that last part: the fact we didn't make\n`PersonFactory` a static class (bwaaah) means we have to instantiate it to be\nable to use it; without a doubt, this has lead you to think \"lel, gunna have\n`new SomethingFactory()` all over da place to instantiate my shit\". Once again,\ndependency injection can help, although indirectly: with a dependency injection\ncontainer.\n\nA container (should be enough) can pretty much be compared to a huge factory\nthat can instantiate multiple classes. In actuality, to avoid having to write\nand maintain some monolithic, god-like class, we'll rather make it call the\nother factories. Once more with our example:\n\n```php\nclass DependencyInjectionContainer\n{\n    public function getPersonFactory()\n    {\n        return new PersonFactory();\n    }\n}\n```\n\nBut it obviously doesn't stop there. When using dependency injection on a large\nscale, we often find ourselves having to manually instantiate objects we need.\nIn some cases, these objects are always the same, like factories but not only:\nthink about the various libraries used in a web project. Wouldn't it be great to\nhave instant access to these objects through the container?\n\n```php\n$container = new DependencyInjectionContainer();\n\n$container->getOrm()->performSomeNaughtyQuery();\n$container->getTwig()->renderUglyTemplate();\n$container->getTranslator()->translate('Putain de code !');\n```\n\nObjects managed in such a fashion thus become **services** of your application.\n\n> Does that mean services are instantiated for each call?\n\nNot necessarily! There are mechanisms allowing us to keep a single instance and\nserve it on subsequent calls. This is out of this article's scope, but you can\ntake a look at [PHP-DI](http://php-di.org/), a nicely done dependency injection\ncontainer library you can use in your own project.\n\n## The end\n\nIf you're a PHP developer, I hope I could show you how to write more\nmaintenable, elegant code by making use of dependency injection. If you're not,\nbe aware that this concept is quite common in object-oriented programming in\ngeneral - after all, [it's even in Angular](https://docs.angularjs.org/guide/di).\n\nHappy coding, and remember, pushing to production on Friday is bad. Now, go!\n","__filename":"en/articles/php/injection-dependances/index.md","__url":"/en/articles/php/injection-dependances/","__resourceUrl":"/en/articles/php/injection-dependances/index.html","__dataUrl":"/en/articles/php/injection-dependances/index.html.5806e0475a70f6c4117c3db8a16ff3eb.json"}