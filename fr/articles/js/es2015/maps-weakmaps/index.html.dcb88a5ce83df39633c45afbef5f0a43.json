{"head":{"layout":"Post","comments":true,"date":"2015-12-11","title":"ES6, ES2015 : les Maps & WeakMaps","tags":["javascript","ES6","ES2015"],"authors":["bloodyowl"],"description":"Maps Comme les objets, les maps et weak maps introduites avec ES6 sont des dictionnaires. La différence avec un objet, c'est que n'importe…"},"body":"<h2 id=\"maps\"><a href=\"#maps\" class=\"phenomic-HeadingAnchor\">#</a>Maps</h2>\n<p>Comme les objets, les maps et weak maps introduites avec ES6 sont des dictionnaires. La différence avec un objet, c'est que n'importe quelle valeur peut être utilisée comme clé.</p>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-keyword\">const</span> myMap = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Map</span>()\nmyMap.set(<span class=\"hljs-built_in\">window</span>, <span class=\"hljs-number\">1</span>)\nmyMap.get(<span class=\"hljs-built_in\">window</span>) <span class=\"hljs-comment\">// 1</span></code></pre>\n<p>Pour créer une map avec des valeurs, on peut passer un tableau de clés/valeurs en argument :</p>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-keyword\">const</span> myMap = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Map</span>([\n  [ <span class=\"hljs-number\">1</span>, <span class=\"hljs-string\">\"foo\"</span> ],\n  [ <span class=\"hljs-built_in\">window</span>, <span class=\"hljs-string\">\"bar\"</span> ],\n])</code></pre>\n<p>Pour tester si une clé est présente, on peut utiliser la méthode <code>has</code> :</p>\n<pre><code class=\"hljs language-javascript\">map.has(<span class=\"hljs-number\">1</span>) <span class=\"hljs-comment\">// false</span></code></pre>\n<p>On peut itérer sur les entrées d'une map à l'aide de <code>forEach</code> :</p>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-keyword\">const</span> myMap = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Map</span>([\n  [ <span class=\"hljs-number\">1</span>, <span class=\"hljs-string\">\"foo\"</span> ],\n  [ <span class=\"hljs-built_in\">window</span>, <span class=\"hljs-string\">\"bar\"</span> ],\n])\n\nmyMap.forEach(<span class=\"hljs-function\">(<span class=\"hljs-params\">value, key</span>) =></span> {\n\t<span class=\"hljs-comment\">// do something</span>\n})</code></pre>\n<p>On peut aussi itérer à l'aide du <code>for … of</code> :</p>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">const</span> [key, value] <span class=\"hljs-keyword\">of</span> myMap) {\n  <span class=\"hljs-built_in\">console</span>.log(key, value)\n}</code></pre>\n<p>Ainsi que convertir la map en tableau à l'aide du spread, puisqu'une map est itérable :</p>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-keyword\">const</span> myEntries = [...myMap] <span class=\"hljs-comment\">// […[key, value]]</span>\n<span class=\"hljs-keyword\">const</span> myEntries = [...myMap.entries()] <span class=\"hljs-comment\">// alternativement</span></code></pre>\n<p>On peut aussi récupérer des itérables par clés et valeurs :</p>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-keyword\">const</span> myKeys = [...myMap.keys()]\n<span class=\"hljs-keyword\">const</span> myValues = [...myMap.values()]</code></pre>\n<p>Particularité, la valeur <code>NaN</code>, qui en JS n'est pas égale à elle même, est bien gérée :</p>\n<pre><code class=\"hljs language-javascript\">myMap.set(<span class=\"hljs-literal\">NaN</span>, <span class=\"hljs-number\">1</span>)\nmyMap.get(<span class=\"hljs-literal\">NaN</span>) <span class=\"hljs-comment\">// 1</span></code></pre>\n<p>Une utilisation possible des Maps est la fonction <code>dedupe</code> pour éliminer les doublons d'un array :</p>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-keyword\">const</span> dedupe = <span class=\"hljs-function\">(<span class=\"hljs-params\">array</span>) =></span> {\n  <span class=\"hljs-keyword\">return</span> [...new <span class=\"hljs-built_in\">Map</span>(array.map(<span class=\"hljs-function\">(<span class=\"hljs-params\">item</span>) =></span> [item, <span class=\"hljs-literal\">true</span>])).keys()]\n}\n\ndedupe([<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">4</span>]) <span class=\"hljs-comment\">// [1, 2, 3, 4]</span></code></pre>\n<h2 id=\"weakmaps\"><a href=\"#weakmaps\" class=\"phenomic-HeadingAnchor\">#</a>WeakMaps</h2>\n<p>Les WeakMaps sont comme les Maps mais qui ne gardent pas les valeurs \"oubliées\". Le garbage collector ne tient donc pas compte des weak maps.</p>\n<p>Les WeakMaps ne possèdent pas de méthodes d'itération et n'acceptent pas de valeurs primitives comme clés.</p>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-keyword\">const</span> myWeakMap = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">WeakMap</span>()\nmyWeakMap.set(<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">1</span>) <span class=\"hljs-comment\">// TypeError</span></code></pre>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-keyword\">const</span> myWeakMap = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">WeakMap</span>()\nmyWeakMap.set(<span class=\"hljs-built_in\">window</span>, <span class=\"hljs-number\">1</span>)\n(<span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =></span> {\n  <span class=\"hljs-keyword\">const</span> object = {}\n  myWeakMap.set(object, <span class=\"hljs-number\">2</span>)\n})()\n<span class=\"hljs-comment\">// myWeakMap a oublié la valeur 2, car `object` n'est plus accessible</span>\n<span class=\"hljs-comment\">// seule la clé `window` persiste.</span></code></pre>\n<p>Un usage possible est le stockage d'informations lié à une instance de classe, permettant de \"cacher\" cette information de l'instance :</p>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-keyword\">const</span> callbacks = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">WeakMap</span>()\n\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">SimpleEventEmitter</span> </span>{\n  <span class=\"hljs-keyword\">constructor</span>() {\n    callbacks.set(<span class=\"hljs-keyword\">this</span>, [])\n  }\n  addEventListener(callback) {\n    callbacks.set(<span class=\"hljs-keyword\">this</span>, callbacks.get(<span class=\"hljs-keyword\">this</span>).concat(callback))\n  }\n  removeEventListener(callback) {\n    callbacks.set(<span class=\"hljs-keyword\">this</span>, callbacks.get(<span class=\"hljs-keyword\">this</span>)\n      .filter(<span class=\"hljs-function\">(<span class=\"hljs-params\">func</span>) =></span> func !== callback))\n  }\n  triggerEvent(...args) {\n    callbacks.get(<span class=\"hljs-keyword\">this</span>).forEach(<span class=\"hljs-function\">(<span class=\"hljs-params\">func</span>) =></span> func(...args))\n  }\n}</code></pre>\n","rawBody":"\n## Maps\n\nComme les objets, les maps et weak maps introduites avec ES6 sont des dictionnaires. La différence avec un objet, c'est que n'importe quelle valeur peut être utilisée comme clé.\n\n```javascript\nconst myMap = new Map()\nmyMap.set(window, 1)\nmyMap.get(window) // 1\n```\n\nPour créer une map avec des valeurs, on peut passer un tableau de clés/valeurs en argument :\n\n```javascript\nconst myMap = new Map([\n  [ 1, \"foo\" ],\n  [ window, \"bar\" ],\n])\n```\n\nPour tester si une clé est présente, on peut utiliser la méthode `has` :\n\n```javascript\nmap.has(1) // false\n```\n\nOn peut itérer sur les entrées d'une map à l'aide de `forEach` :\n\n```javascript\nconst myMap = new Map([\n  [ 1, \"foo\" ],\n  [ window, \"bar\" ],\n])\n\nmyMap.forEach((value, key) => {\n\t// do something\n})\n```\n\nOn peut aussi itérer à l'aide du `for … of` :\n\n```javascript\nfor (const [key, value] of myMap) {\n  console.log(key, value)\n}\n```\n\nAinsi que convertir la map en tableau à l'aide du spread, puisqu'une map est itérable :\n\n```javascript\nconst myEntries = [...myMap] // […[key, value]]\nconst myEntries = [...myMap.entries()] // alternativement\n```\n\nOn peut aussi récupérer des itérables par clés et valeurs :\n\n```javascript\nconst myKeys = [...myMap.keys()]\nconst myValues = [...myMap.values()]\n```\n\nParticularité, la valeur `NaN`, qui en JS n'est pas égale à elle même, est bien gérée :\n\n```javascript\nmyMap.set(NaN, 1)\nmyMap.get(NaN) // 1\n```\n\nUne utilisation possible des Maps est la fonction `dedupe` pour éliminer les doublons d'un array :\n\n\n```javascript\nconst dedupe = (array) => {\n  return [...new Map(array.map((item) => [item, true])).keys()]\n}\n\ndedupe([1, 1, 2, 3, 4, 4]) // [1, 2, 3, 4]\n```\n\n## WeakMaps\n\nLes WeakMaps sont comme les Maps mais qui ne gardent pas les valeurs \"oubliées\". Le garbage collector ne tient donc pas compte des weak maps.\n\nLes WeakMaps ne possèdent pas de méthodes d'itération et n'acceptent pas de valeurs primitives comme clés.\n\n```javascript\nconst myWeakMap = new WeakMap()\nmyWeakMap.set(1, 1) // TypeError\n```\n\n```javascript\nconst myWeakMap = new WeakMap()\nmyWeakMap.set(window, 1)\n(() => {\n  const object = {}\n  myWeakMap.set(object, 2)\n})()\n// myWeakMap a oublié la valeur 2, car `object` n'est plus accessible\n// seule la clé `window` persiste.\n```\n\nUn usage possible est le stockage d'informations lié à une instance de classe, permettant de \"cacher\" cette information de l'instance :\n\n```javascript\nconst callbacks = new WeakMap()\n\nclass SimpleEventEmitter {\n  constructor() {\n    callbacks.set(this, [])\n  }\n  addEventListener(callback) {\n    callbacks.set(this, callbacks.get(this).concat(callback))\n  }\n  removeEventListener(callback) {\n    callbacks.set(this, callbacks.get(this)\n      .filter((func) => func !== callback))\n  }\n  triggerEvent(...args) {\n    callbacks.get(this).forEach((func) => func(...args))\n  }\n}\n```\n","__filename":"fr/articles/js/es2015/maps-weakmaps.md","__url":"/fr/articles/js/es2015/maps-weakmaps/","__resourceUrl":"/fr/articles/js/es2015/maps-weakmaps/index.html","__dataUrl":"/fr/articles/js/es2015/maps-weakmaps/index.html.dcb88a5ce83df39633c45afbef5f0a43.json"}