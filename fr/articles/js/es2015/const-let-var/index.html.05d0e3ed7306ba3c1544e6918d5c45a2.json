{"head":{"layout":"Post","comments":true,"date":"2015-12-01","title":"ES6, ES2015 : la déclaration de variables avec const, let et var","tags":["JavaScript","ES6","ES2015"],"authors":["Nyalab"],"description":"ES6 (aussi appelé ES2015) vous apporte de nouvelles façons de déclarer vos variables grâce à let et const mais garde aussi la déclaration…"},"body":"<p>ES6 (aussi appelé ES2015) vous apporte de nouvelles façons de déclarer vos\nvariables grâce à <code>let</code> et <code>const</code> mais garde aussi la déclaration par <code>var</code>\ndans la spécification du langage.</p>\n<p>Première étape, on oublie tout ce qu'on sait sur <code>var</code>.</p>\n<h1 id=\"déclarations\"><a href=\"#d%C3%A9clarations\" class=\"phenomic-HeadingAnchor\">#</a>Déclarations</h1>\n<h2 id=\"const\"><a href=\"#const\" class=\"phenomic-HeadingAnchor\">#</a>const</h2>\n<p><code>const</code> vous permet de déclarer une variable à assignation unique bindée\nlexicalement. Bon, ça fait un peu pompeux, alors pour les devs au fond de la\nsalle à côté du radiateur, ça veut simplement dire que vous pouvez déclarer une\nvariable qui ne contiendra qu'une valeur et qui sera scopée au niveau du bloc.</p>\n<p>Si vous avez déjà lu des posts ou des ressources parlant de <code>const</code>, méfiez-vous\n: ce ne sont pas des vraies constantes au sens <em>valeur</em> de variable. Ce sont des\nconstantes au niveau référence. C'est à dire que le contenu d'un tableau ou d'un\nobjet déclaré avec <code>const</code> bloque la réassignation de la variable, mais ne rend\npas la valeur immuable.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">fn</span>(<span class=\"hljs-params\"></span>) </span>{\n  <span class=\"hljs-keyword\">const</span> foo = <span class=\"hljs-string\">\"bar\"</span>\n  <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-literal\">true</span>) {\n    <span class=\"hljs-keyword\">const</span> foo <span class=\"hljs-comment\">// SyntaxError, la variable a besoin d'être assignée</span>\n    <span class=\"hljs-keyword\">const</span> foo = <span class=\"hljs-string\">\"qux\"</span>\n    foo = <span class=\"hljs-string\">\"norf\"</span> <span class=\"hljs-comment\">// SyntaxError, la variable ne peut pas être réassignée</span>\n    <span class=\"hljs-built_in\">console</span>.log(foo)\n    <span class=\"hljs-comment\">// \"qux\", la variable appartient au scope de son bloc (le \"if\")</span>\n  }\n  <span class=\"hljs-built_in\">console</span>.log(foo)\n  <span class=\"hljs-comment\">// \"bar\", la variable appartient au scope de la fonction \"fn\"</span>\n}</code></pre>\n<p>Le fonctionnement <code>const</code> peut être utilisé de manière cool dans le cas\nd'itérables :</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">fn</span>(<span class=\"hljs-params\"></span>) </span>{\n  <span class=\"hljs-keyword\">const</span> arr = [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>]\n  <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">const</span> el <span class=\"hljs-keyword\">of</span> arr) {\n    <span class=\"hljs-built_in\">console</span>.log(el)\n  }\n}</code></pre>\n<p>En effet, on pourrait croire qu'un <code>let</code> doit être utilisé ici, mais la\ndéclaration est évaluée à chaque passage de l'itérateur, <code>const</code> est donc un\nmeilleur choix !</p>\n<h2 id=\"let\"><a href=\"#let\" class=\"phenomic-HeadingAnchor\">#</a>let</h2>\n<p><code>let</code> vous permet de faire pareil que <code>const</code> mais sans la contrainte\nd'assignation unique. Vous devriez donc instinctivement voir que les cas\nd'utilisation pour <code>let</code> sont les mêmes que ceux de <code>var</code>, son ancêtre.\nD'ailleurs, vous entendrez souvent : <code>let</code> est le nouveau <code>var</code> (<em><code>let</code> is the\nnew <code>var</code></em>). C'est en partie vrai car il est capable de faire les mêmes choses,\nmais en mieux, car il a cette caractéristique d'être scopé au bloc courant.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">fn</span>(<span class=\"hljs-params\"></span>) </span>{\n  <span class=\"hljs-keyword\">let</span> foo = <span class=\"hljs-string\">\"bar\"</span>\n  <span class=\"hljs-keyword\">var</span> foo2 = <span class=\"hljs-string\">\"bar\"</span>\n  <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-literal\">true</span>) {\n    <span class=\"hljs-keyword\">let</span> foo <span class=\"hljs-comment\">// pas d'erreur, foo === undefined</span>\n    <span class=\"hljs-keyword\">var</span> foo2\n    <span class=\"hljs-comment\">// Attention, les déclarations \"var\" ne sont pas scopées au niveau bloc</span>\n    <span class=\"hljs-comment\">// foo2 est en réalité écrasé !</span>\n    foo = <span class=\"hljs-string\">\"qux\"</span>\n    foo2 = <span class=\"hljs-string\">\"qux\"</span>\n    <span class=\"hljs-built_in\">console</span>.log(foo)\n    <span class=\"hljs-comment\">// \"qux\", la variable appartient au scope de son blocs (le \"if\")</span>\n    <span class=\"hljs-built_in\">console</span>.log(foo2)\n    <span class=\"hljs-comment\">// \"qux\"</span>\n  }\n  <span class=\"hljs-built_in\">console</span>.log(foo)\n  <span class=\"hljs-comment\">// \"bar\", la variable appartient au scope de son bloc (la fonction \"fn\")</span>\n  <span class=\"hljs-built_in\">console</span>.log(foo2)\n  <span class=\"hljs-comment\">// \"qux\"</span>\n}</code></pre>\n<p>Vous pouvez par exemple utiliser <code>let</code> pour vos boucles, la variable servant à\nl'itération est désormais scopée au niveau de cette boucle et n'entrera pas en\nconflit avec votre code autour. Plus de problème de <code>i</code> déjà pris !</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">fn2</span>(<span class=\"hljs-params\"></span>) </span>{\n  <span class=\"hljs-keyword\">let</span> i = <span class=\"hljs-number\">0</span>\n  <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> i=i; i&#x3C;<span class=\"hljs-number\">10</span>; i++) {\n    <span class=\"hljs-built_in\">console</span>.log(i)\n  }\n  <span class=\"hljs-built_in\">console</span>.log(i)\n  <span class=\"hljs-comment\">// 0</span>\n\n  <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> j=i; j&#x3C;<span class=\"hljs-number\">10</span>; j++) {}\n  <span class=\"hljs-built_in\">console</span>.log(j)\n  <span class=\"hljs-comment\">// j is not defined</span>\n}\nfn2() <span class=\"hljs-comment\">// 0, 1, 2, 3, 4, 5, 6, 7, 8, 9</span></code></pre>\n<p>Note : l'exemple avec <code>const</code> dans une boucle <code>for ... of</code> ne peut être\nreproduit ici. En effet, la boucle <code>for</code> classique est impérative, et la\ndéclaration n'est effectuée qu'une seule fois au début de la boucle. Un <code>const</code>\nn'est donc pas utilisable.</p>\n<h2 id=\"var\"><a href=\"#var\" class=\"phenomic-HeadingAnchor\">#</a>var</h2>\n<p>On a vu <code>const</code>, on a vu <code>let</code>. Avec ces deux nouveaux outils, il ne reste pas\nde grande place pour <code>var</code>. À mon avis, le seul cas d'utilisation valable pour\n<code>var</code> est lors de l'utilisation de <code>try</code>/<code>catch</code>, et ce n'est pas dans le cadre\nd'un bug, mais juste de syntaxe et de préférence\n(<a href=\"https://twitter.com/getify/status/658662478528643072\">exemple</a>).</p>\n<h1 id=\"piège-du-hoisting-et-de-la-tdz-temporal-dead-zone\"><a href=\"#pi%C3%A8ge-du-hoisting-et-de-la-tdz-temporal-dead-zone\" class=\"phenomic-HeadingAnchor\">#</a>Piège du hoisting et de la TDZ (<em>Temporal Dead Zone</em>)</h1>\n<p>Pour rappel, JavaScript possède un mécanisme de hoisting, par exemple, vous\npouvez écrire :</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">fn</span>(<span class=\"hljs-params\"></span>) </span>{\n  <span class=\"hljs-built_in\">console</span>.log(foo) <span class=\"hljs-comment\">// undefined (au lieu de ReferenceError)</span>\n  <span class=\"hljs-keyword\">var</span> foo = <span class=\"hljs-string\">\"bar\"</span>\n}</code></pre>\n<p>Concrètement, le moteur d'exécution JavaScript va lire toutes les déclarations\net remonter celles avec <code>var</code> au début du scope de votre fonction (attention,\ncela concerne les déclarations, pas les affectations).</p>\n<p><code>let</code> et <code>const</code> ne bénéficient pas de ce mécanisme de hoisting, ce qui peut\nmener à des problèmes de TDZ (<em>Temporal Dead Zone</em>). Vu que la déclaration de\nvotre variable n'est pas remontée au scope de la fonction, il existe un moment\noù votre variable n'existe pas. Ce moment, c'est la TDZ.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">fn</span>(<span class=\"hljs-params\"></span>) </span>{\n  <span class=\"hljs-built_in\">console</span>.log(foo)\n  <span class=\"hljs-comment\">// ReferenceError, on est dans la TDZ pour la variable foo</span>\n  <span class=\"hljs-keyword\">let</span> foo = <span class=\"hljs-string\">\"bar\"</span>\n}</code></pre>\n<h1 id=\"outro\"><a href=\"#outro\" class=\"phenomic-HeadingAnchor\">#</a>Outro</h1>\n<p>Comment choisir quelle déclaration de variable utiliser ? C'est très simple :</p>\n<ul>\n<li>Utilisez une déclaration par <code>const</code> (99% du temps, c'est le bon choix)</li>\n<li>Si au fil de votre code vous changez sa valeur, modifiez pour un <code>let</code> (1%)</li>\n<li>Si vous avez trouvé le pire cas d'utilisation du monde, changez pour un <code>var</code>\n(je vous laisse faire le calcul)</li>\n</ul>\n","rawBody":"\nES6 (aussi appelé ES2015) vous apporte de nouvelles façons de déclarer vos\nvariables grâce à `let` et `const` mais garde aussi la déclaration par `var`\ndans la spécification du langage.\n\nPremière étape, on oublie tout ce qu'on sait sur `var`.\n\n\n# Déclarations\n\n## const\n\n`const` vous permet de déclarer une variable à assignation unique bindée\nlexicalement. Bon, ça fait un peu pompeux, alors pour les devs au fond de la\nsalle à côté du radiateur, ça veut simplement dire que vous pouvez déclarer une\nvariable qui ne contiendra qu'une valeur et qui sera scopée au niveau du bloc.\n\nSi vous avez déjà lu des posts ou des ressources parlant de `const`, méfiez-vous\n: ce ne sont pas des vraies constantes au sens *valeur* de variable. Ce sont des\nconstantes au niveau référence. C'est à dire que le contenu d'un tableau ou d'un\nobjet déclaré avec `const` bloque la réassignation de la variable, mais ne rend\npas la valeur immuable.\n\n```js\nfunction fn() {\n  const foo = \"bar\"\n  if (true) {\n    const foo // SyntaxError, la variable a besoin d'être assignée\n    const foo = \"qux\"\n    foo = \"norf\" // SyntaxError, la variable ne peut pas être réassignée\n    console.log(foo)\n    // \"qux\", la variable appartient au scope de son bloc (le \"if\")\n  }\n  console.log(foo)\n  // \"bar\", la variable appartient au scope de la fonction \"fn\"\n}\n```\n\nLe fonctionnement `const` peut être utilisé de manière cool dans le cas\nd'itérables :\n\n```js\nfunction fn() {\n  const arr = [1, 2, 3]\n  for (const el of arr) {\n    console.log(el)\n  }\n}\n```\n\nEn effet, on pourrait croire qu'un `let` doit être utilisé ici, mais la\ndéclaration est évaluée à chaque passage de l'itérateur, `const` est donc un\nmeilleur choix !\n\n## let\n\n`let` vous permet de faire pareil que `const` mais sans la contrainte\nd'assignation unique. Vous devriez donc instinctivement voir que les cas\nd'utilisation pour `let` sont les mêmes que ceux de `var`, son ancêtre.\nD'ailleurs, vous entendrez souvent : `let` est le nouveau `var` (*`let` is the\nnew `var`*). C'est en partie vrai car il est capable de faire les mêmes choses,\nmais en mieux, car il a cette caractéristique d'être scopé au bloc courant.\n\n```js\nfunction fn() {\n  let foo = \"bar\"\n  var foo2 = \"bar\"\n  if (true) {\n    let foo // pas d'erreur, foo === undefined\n    var foo2\n    // Attention, les déclarations \"var\" ne sont pas scopées au niveau bloc\n    // foo2 est en réalité écrasé !\n    foo = \"qux\"\n    foo2 = \"qux\"\n    console.log(foo)\n    // \"qux\", la variable appartient au scope de son blocs (le \"if\")\n    console.log(foo2)\n    // \"qux\"\n  }\n  console.log(foo)\n  // \"bar\", la variable appartient au scope de son bloc (la fonction \"fn\")\n  console.log(foo2)\n  // \"qux\"\n}\n```\n\nVous pouvez par exemple utiliser `let` pour vos boucles, la variable servant à\nl'itération est désormais scopée au niveau de cette boucle et n'entrera pas en\nconflit avec votre code autour. Plus de problème de `i` déjà pris !\n\n```js\nfunction fn2() {\n  let i = 0\n  for (let i=i; i<10; i++) {\n    console.log(i)\n  }\n  console.log(i)\n  // 0\n\n  for (let j=i; j<10; j++) {}\n  console.log(j)\n  // j is not defined\n}\nfn2() // 0, 1, 2, 3, 4, 5, 6, 7, 8, 9\n```\n\nNote : l'exemple avec `const` dans une boucle `for ... of` ne peut être\nreproduit ici. En effet, la boucle `for` classique est impérative, et la\ndéclaration n'est effectuée qu'une seule fois au début de la boucle. Un `const`\nn'est donc pas utilisable.\n\n## var\n\nOn a vu `const`, on a vu `let`. Avec ces deux nouveaux outils, il ne reste pas\nde grande place pour `var`. À mon avis, le seul cas d'utilisation valable pour\n`var` est lors de l'utilisation de `try`/`catch`, et ce n'est pas dans le cadre\nd'un bug, mais juste de syntaxe et de préférence\n([exemple](https://twitter.com/getify/status/658662478528643072)).\n\n# Piège du hoisting et de la TDZ (*Temporal Dead Zone*)\n\nPour rappel, JavaScript possède un mécanisme de hoisting, par exemple, vous\npouvez écrire :\n\n```js\nfunction fn() {\n  console.log(foo) // undefined (au lieu de ReferenceError)\n  var foo = \"bar\"\n}\n```\n\nConcrètement, le moteur d'exécution JavaScript va lire toutes les déclarations\net remonter celles avec `var` au début du scope de votre fonction (attention,\ncela concerne les déclarations, pas les affectations).\n\n`let` et `const` ne bénéficient pas de ce mécanisme de hoisting, ce qui peut\nmener à des problèmes de TDZ (*Temporal Dead Zone*). Vu que la déclaration de\nvotre variable n'est pas remontée au scope de la fonction, il existe un moment\noù votre variable n'existe pas. Ce moment, c'est la TDZ.\n\n```js\nfunction fn() {\n  console.log(foo)\n  // ReferenceError, on est dans la TDZ pour la variable foo\n  let foo = \"bar\"\n}\n```\n\n# Outro\n\nComment choisir quelle déclaration de variable utiliser ? C'est très simple :\n\n - Utilisez une déclaration par `const` (99% du temps, c'est le bon choix)\n - Si au fil de votre code vous changez sa valeur, modifiez pour un `let` (1%)\n - Si vous avez trouvé le pire cas d'utilisation du monde, changez pour un `var`\n(je vous laisse faire le calcul)\n","__filename":"fr/articles/js/es2015/const-let-var.md","__url":"/fr/articles/js/es2015/const-let-var/","__resourceUrl":"/fr/articles/js/es2015/const-let-var/index.html","__dataUrl":"/fr/articles/js/es2015/const-let-var/index.html.05d0e3ed7306ba3c1544e6918d5c45a2.json"}