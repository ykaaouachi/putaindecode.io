{"head":{"layout":"Post","comments":true,"date":"2015-12-07","title":"ES6, ES2015 : les template strings","tags":["JavaScript","ES6","ES2015"],"authors":["jbleuzen"],"description":"ES2015 ajoute le support des template strings qui va permettre enfin de se simplifier la vie lorsqu'on doit manipuler des chaînes de…"},"body":"<p>ES2015 ajoute le support des <em>template strings</em> qui va permettre enfin de se\nsimplifier la vie lorsqu'on doit manipuler des chaînes de caractères.</p>\n<h2 id=\"le-principe\"><a href=\"#le-principe\" class=\"phenomic-HeadingAnchor\">#</a>Le principe</h2>\n<p>Pour définir une chaîne en JavaScript, il faut utiliser soit des single quotes,\nsoit des double quotes. Malheureusement ces délimiteurs posent quelques\nproblèmes lorsque justement la chaîne contient un single quote ou une\ndouble quote.</p>\n<p>Ainsi, les <em>template strings</em> utilisent le caractère <em>back-tick</em> (accent grave\nsimple) pour délimiter les chaînes de caractères.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// ES5</span>\n<span class=\"hljs-keyword\">var</span> myString = <span class=\"hljs-string\">'Je suis une \"chaîne de caractères\"'</span>\n\n<span class=\"hljs-comment\">// ES6</span>\n<span class=\"hljs-keyword\">const</span> myNewString = <span class=\"hljs-string\">`Je suis une \"template string\"`</span></code></pre>\n<p>Jusque là, rien de bien novateur mais voyons un exemple que l'on rencontre\ntout le temps : l'interpolation d'expression dans les chaînes de texte.</p>\n<h2 id=\"interpolation-dexpression\"><a href=\"#interpolation-dexpression\" class=\"phenomic-HeadingAnchor\">#</a>Interpolation d'expression</h2>\n<p>On peut maintenant directement utiliser les variables dans une <em>template string</em>\nsi on les insère dans un placeholder qui s'écrit <code>${variable}</code>.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// ES5</span>\n<span class=\"hljs-keyword\">var</span> name = <span class=\"hljs-string\">\"world\"</span>;\n<span class=\"hljs-keyword\">var</span> myStrin = <span class=\"hljs-string\">\"Hello \"</span> + name; <span class=\"hljs-comment\">// => Hello world</span>\n\n<span class=\"hljs-comment\">// ES6</span>\n<span class=\"hljs-keyword\">const</span> newName = <span class=\"hljs-string\">`developer`</span>;\n<span class=\"hljs-keyword\">const</span> myStrin = <span class=\"hljs-string\">`Hello <span class=\"hljs-subst\">${ newName }</span>`</span>; <span class=\"hljs-comment\">// => Hello developer</span></code></pre>\n<p>Il est également possible de faire des traitements dans un placeholder et\nd'appeler des fonctions.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> x = <span class=\"hljs-number\">1</span>;\n<span class=\"hljs-keyword\">const</span> y = <span class=\"hljs-number\">2</span>;\n<span class=\"hljs-keyword\">const</span> result = <span class=\"hljs-string\">`<span class=\"hljs-subst\">${ x }</span> + <span class=\"hljs-subst\">${ y }</span> = <span class=\"hljs-subst\">${ x + y }</span>`</span> <span class=\"hljs-comment\">// => 1 + 2 = 3</span>\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">square</span>(<span class=\"hljs-params\">num</span>) </span>{\n  <span class=\"hljs-keyword\">return</span> num * num;\n}\n<span class=\"hljs-keyword\">const</span> result = <span class=\"hljs-string\">`<span class=\"hljs-subst\">${square(<span class=\"hljs-number\">5</span>)}</span>`</span> <span class=\"hljs-comment\">// => 25</span></code></pre>\n<p>Ce qui rend l'utilisation des <em>template strings</em> extrêmement intéressante.</p>\n<h2 id=\"les-template-strings-multi-lignes\"><a href=\"#les-template-strings-multi-lignes\" class=\"phenomic-HeadingAnchor\">#</a>Les <em>template strings</em> multi-lignes</h2>\n<p>Une autre avancée des <em>template strings</em> est le support multi-ligne, en effet en\nES5 il n'existe aucune solution esthétique (et pratique) pour générer des\nchaînes multi-lignes.\nCe problème disparait avec les <em>template strings</em>.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// ES5</span>\n<span class=\"hljs-keyword\">var</span> multiline = <span class=\"hljs-string\">\"foo \\\n                 bar \\\n                 baz\"</span>;\n\n<span class=\"hljs-keyword\">var</span> multiline2 = <span class=\"hljs-string\">\"foo\"</span>;\nmultiline2 += <span class=\"hljs-string\">\"bar\"</span>;\nmultiline2 += <span class=\"hljs-string\">\"baz\"</span>;\n\n<span class=\"hljs-comment\">// ES6</span>\n<span class=\"hljs-keyword\">const</span> multiline = <span class=\"hljs-string\">`foo\n                   bar\n                   baz`</span>;</code></pre>\n<p><em>Attention</em> cependant, les espaces sont conservés avec les <em>template strings</em>,\nce qui peut surprendre si vous devez tester des strings multi-lignes.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> str1 = <span class=\"hljs-string\">`foo\nbar`</span>;\n\n<span class=\"hljs-keyword\">const</span> str2 = <span class=\"hljs-string\">`foo\n             bar`</span>;\n\nstr1 === str2 <span class=\"hljs-comment\">// => false</span></code></pre>\n<h2 id=\"les-template-strings-taggués\"><a href=\"#les-template-strings-taggu%C3%A9s\" class=\"phenomic-HeadingAnchor\">#</a>Les <em>template strings</em> taggués</h2>\n<p>On entre dans les fonctions moins connues et peu utilisées des <em>template strings</em>.\nLes tags sont des fonctions que l'on place juste avant une <em>template string</em> et\nqui permettent de modifier le contenu de la dite chaîne de caractères.</p>\n<p>Ce tag aura pour paramètres un tableau de \"literals\" (les chaînes de caractères),\net ensuite tous les paramètres correspondant aux valeurs interpolées qui auront\ndéjà été évaluées, mais que l'on pourra quand même modifier.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">capitalizeVowels</span>(<span class=\"hljs-params\">strings, ...values</span>) </span>{\n\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">replaceVowels</span>(<span class=\"hljs-params\">string</span>) </span>{\n    <span class=\"hljs-keyword\">return</span> string.replace(<span class=\"hljs-regexp\">/[aeiou]/g</span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">c</span>)</span>{\n      <span class=\"hljs-keyword\">return</span> c.toUpperCase();\n    });\n  }\n\n  <span class=\"hljs-keyword\">let</span> result = <span class=\"hljs-string\">\"\"</span>;\n  <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">let</span> i = <span class=\"hljs-number\">0</span>; i &#x3C; strings.length; ++i) {\n    <span class=\"hljs-keyword\">const</span> nextValue = values[i] || <span class=\"hljs-string\">\"\"</span>;\n    result += replaceVowels(strings[i]);\n    <span class=\"hljs-keyword\">if</span>(! <span class=\"hljs-built_in\">parseInt</span>(nextValue)) {\n      result += replaceVowels(nextValue)\n    } <span class=\"hljs-keyword\">else</span> {\n      result += nextValue;\n    }\n  }\n  <span class=\"hljs-keyword\">return</span> result;\n}\n\n\ncapitalizeVowels<span class=\"hljs-string\">`foo bar ?`</span> <span class=\"hljs-comment\">// => fOO bAr ?</span>\n<span class=\"hljs-keyword\">const</span> n = <span class=\"hljs-number\">42</span>\n<span class=\"hljs-keyword\">const</span> c = <span class=\"hljs-string\">\"f\"</span>\n<span class=\"hljs-keyword\">const</span> v = <span class=\"hljs-string\">\"o\"</span>\ncapitalizeVowels<span class=\"hljs-string\">`foo <span class=\"hljs-subst\">${ n }</span> bar <span class=\"hljs-subst\">${ c }</span><span class=\"hljs-subst\">${ v }</span><span class=\"hljs-subst\">${ v }</span> ?`</span> <span class=\"hljs-comment\">// => fOO 42 bAr fOO ?</span></code></pre>\n<p>Voici un exemple intéressant d'utilisation des <em>template strings</em> taggués qui\nprésente un système <a href=\"http://jaysoo.ca/2014/03/20/i18n-with-es6-template-strings/\">de localisation de chaînes de caractères</a>.</p>\n<h2 id=\"stringraw\"><a href=\"#stringraw\" class=\"phenomic-HeadingAnchor\">#</a>String.raw</h2>\n<p>Et pour finir, une nouvelle fonction a été ajoutée au prototype de <code>String</code> qui\npermet d'afficher le contenu d'un <em>template string</em> brut. C'est à dire que la\nfonction permettra de voir les caractères d'échappement qui sont\nautomatiquement gérés avec une <em>template string</em>.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-built_in\">String</span>.raw<span class=\"hljs-string\">`FOO\\nbar`</span> <span class=\"hljs-comment\">// => FOO\\\\nbar</span></code></pre>\n<h2 id=\"conclusion\"><a href=\"#conclusion\" class=\"phenomic-HeadingAnchor\">#</a>Conclusion</h2>\n<p>Les <em>template strings</em> sont bien utiles au quotidien, l'ajout de l'interpolation\nsimplifie grandement la vie et permet d'oublier les erreurs d'échappement.</p>\n<p>Aujourd'hui, <a href=\"https://kangax.github.io/compat-table/es6/#test-template_strings\">la grande majorité des navigateurs les supportent</a>\nainsi que babel et traceur, donc usez et abusez des <em>template strings</em>…</p>\n","rawBody":"\nES2015 ajoute le support des *template strings* qui va permettre enfin de se\nsimplifier la vie lorsqu'on doit manipuler des chaînes de caractères.\n\n## Le principe\n\nPour définir une chaîne en JavaScript, il faut utiliser soit des single quotes,\nsoit des double quotes. Malheureusement ces délimiteurs posent quelques\nproblèmes lorsque justement la chaîne contient un single quote ou une\ndouble quote.\n\nAinsi, les *template strings* utilisent le caractère _back-tick_ (accent grave\nsimple) pour délimiter les chaînes de caractères.\n\n```js\n// ES5\nvar myString = 'Je suis une \"chaîne de caractères\"'\n\n// ES6\nconst myNewString = `Je suis une \"template string\"`\n```\n\nJusque là, rien de bien novateur mais voyons un exemple que l'on rencontre\ntout le temps : l'interpolation d'expression dans les chaînes de texte.\n\n## Interpolation d'expression\n\nOn peut maintenant directement utiliser les variables dans une *template string*\nsi on les insère dans un placeholder qui s'écrit `${variable}`.\n\n```js\n// ES5\nvar name = \"world\";\nvar myStrin = \"Hello \" + name; // => Hello world\n\n// ES6\nconst newName = `developer`;\nconst myStrin = `Hello ${ newName }`; // => Hello developer\n```\n\nIl est également possible de faire des traitements dans un placeholder et\nd'appeler des fonctions.\n\n```js\nconst x = 1;\nconst y = 2;\nconst result = `${ x } + ${ y } = ${ x + y }` // => 1 + 2 = 3\n\nfunction square(num) {\n  return num * num;\n}\nconst result = `${square(5)}` // => 25\n```\n\nCe qui rend l'utilisation des *template strings* extrêmement intéressante.\n\n## Les *template strings* multi-lignes\n\nUne autre avancée des *template strings* est le support multi-ligne, en effet en\nES5 il n'existe aucune solution esthétique (et pratique) pour générer des\nchaînes multi-lignes.\nCe problème disparait avec les *template strings*.\n\n```js\n// ES5\nvar multiline = \"foo \\\n                 bar \\\n                 baz\";\n\nvar multiline2 = \"foo\";\nmultiline2 += \"bar\";\nmultiline2 += \"baz\";\n\n// ES6\nconst multiline = `foo\n                   bar\n                   baz`;\n```\n\n*Attention* cependant, les espaces sont conservés avec les *template strings*,\nce qui peut surprendre si vous devez tester des strings multi-lignes.\n\n```js\nconst str1 = `foo\nbar`;\n\nconst str2 = `foo\n             bar`;\n\nstr1 === str2 // => false\n```\n\n## Les *template strings* taggués\n\nOn entre dans les fonctions moins connues et peu utilisées des *template strings*.\nLes tags sont des fonctions que l'on place juste avant une *template string* et\nqui permettent de modifier le contenu de la dite chaîne de caractères.\n\nCe tag aura pour paramètres un tableau de \"literals\" (les chaînes de caractères),\net ensuite tous les paramètres correspondant aux valeurs interpolées qui auront\ndéjà été évaluées, mais que l'on pourra quand même modifier.\n\n```js\nfunction capitalizeVowels(strings, ...values) {\n\n  function replaceVowels(string) {\n    return string.replace(/[aeiou]/g, function(c){\n      return c.toUpperCase();\n    });\n  }\n\n  let result = \"\";\n  for(let i = 0; i < strings.length; ++i) {\n    const nextValue = values[i] || \"\";\n    result += replaceVowels(strings[i]);\n    if(! parseInt(nextValue)) {\n      result += replaceVowels(nextValue)\n    } else {\n      result += nextValue;\n    }\n  }\n  return result;\n}\n\n\ncapitalizeVowels`foo bar ?` // => fOO bAr ?\nconst n = 42\nconst c = \"f\"\nconst v = \"o\"\ncapitalizeVowels`foo ${ n } bar ${ c }${ v }${ v } ?` // => fOO 42 bAr fOO ?\n```\n\nVoici un exemple intéressant d'utilisation des *template strings* taggués qui\nprésente un système [de localisation de chaînes de caractères](http://jaysoo.ca/2014/03/20/i18n-with-es6-template-strings/).\n\n## String.raw\n\nEt pour finir, une nouvelle fonction a été ajoutée au prototype de `String` qui\npermet d'afficher le contenu d'un *template string* brut. C'est à dire que la\nfonction permettra de voir les caractères d'échappement qui sont\nautomatiquement gérés avec une *template string*.\n\n```js\nString.raw`FOO\\nbar` // => FOO\\\\nbar\n```\n\n## Conclusion\n\nLes *template strings* sont bien utiles au quotidien, l'ajout de l'interpolation\nsimplifie grandement la vie et permet d'oublier les erreurs d'échappement.\n\nAujourd'hui, [la grande majorité des navigateurs les supportent](https://kangax.github.io/compat-table/es6/#test-template_strings)\nainsi que babel et traceur, donc usez et abusez des *template strings*…\n","__filename":"fr/articles/js/es2015/template-strings.md","__url":"/fr/articles/js/es2015/template-strings/","__resourceUrl":"/fr/articles/js/es2015/template-strings/index.html","__dataUrl":"/fr/articles/js/es2015/template-strings/index.html.43810ef80053c12a865e5ace90b6f1e2.json"}