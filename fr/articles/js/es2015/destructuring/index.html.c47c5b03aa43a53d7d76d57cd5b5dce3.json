{"head":{"layout":"Post","comments":true,"date":"2015-12-02","title":"ES6, ES2015 : le destructuring","tags":["javascript","ES6","ES2015"],"authors":["bloodyowl"],"description":"Le principe Le destructuring consiste à assigner des variables provenant d'un objet ou tableau en reposant sur leur structure. Les…"},"body":"<h2 id=\"le-principe\"><a href=\"#le-principe\" class=\"phenomic-HeadingAnchor\">#</a>Le principe</h2>\n<p>Le destructuring consiste à assigner des variables provenant d'un objet ou\ntableau en reposant sur leur structure.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// Partons d'un objet `myObject`</span>\n<span class=\"hljs-keyword\">var</span> myObject = {\n  <span class=\"hljs-attr\">foo</span>: <span class=\"hljs-number\">1</span>,\n  <span class=\"hljs-attr\">bar</span>: <span class=\"hljs-number\">2</span>,\n}\n\n<span class=\"hljs-comment\">// Avec ES5, vous deviez par exemple faire</span>\n<span class=\"hljs-keyword\">var</span> foo = myObject.foo\n<span class=\"hljs-keyword\">var</span> bar = myObject.bar\n\nfoo <span class=\"hljs-comment\">// 1</span>\nbar <span class=\"hljs-comment\">// 2</span>\n\n<span class=\"hljs-comment\">// Avec ES6, vous pouvez désormais l'écrire sous la forme</span>\n<span class=\"hljs-keyword\">const</span> { foo, bar } = myObject\nfoo <span class=\"hljs-comment\">// 1</span>\nbar <span class=\"hljs-comment\">// 2</span>\n\n<span class=\"hljs-comment\">// On peut bien entendu destructurer la valeur retournée par une</span>\n<span class=\"hljs-comment\">// fonction, pour peu qu'il s'agisse d'un objet ou d'un tableau</span>\n<span class=\"hljs-keyword\">const</span> getMyObject = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) </span>{\n  <span class=\"hljs-keyword\">return</span> {\n    <span class=\"hljs-attr\">foo</span>: <span class=\"hljs-number\">1</span>,\n    <span class=\"hljs-attr\">bar</span>: <span class=\"hljs-number\">2</span>,\n  }\n}\n<span class=\"hljs-keyword\">const</span> { foo, bar } = getMyObject()\nfoo <span class=\"hljs-comment\">// 1</span>\nbar <span class=\"hljs-comment\">// 2</span></code></pre>\n<h2 id=\"les-différentes-syntaxes\"><a href=\"#les-diff%C3%A9rentes-syntaxes\" class=\"phenomic-HeadingAnchor\">#</a>Les différentes syntaxes</h2>\n<h3 id=\"tableau\"><a href=\"#tableau\" class=\"phenomic-HeadingAnchor\">#</a>Tableau</h3>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// Pour un tableau, on utilise une forme proche de la déclaration litérale de</span>\n<span class=\"hljs-comment\">// tableau, vous remarquerez que pour ignorer un item, il suffit de ne rien</span>\n<span class=\"hljs-comment\">// placer entre les virgules</span>\n<span class=\"hljs-keyword\">const</span> [ first, second, , fourth ] = [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>]\nfirst <span class=\"hljs-comment\">// 1</span>\nsecond <span class=\"hljs-comment\">// 2</span>\nfourth <span class=\"hljs-comment\">// 4</span></code></pre>\n<h3 id=\"utiliser-un-nom-différent-de-la-clé\"><a href=\"#utiliser-un-nom-diff%C3%A9rent-de-la-cl%C3%A9\" class=\"phenomic-HeadingAnchor\">#</a>Utiliser un nom différent de la clé</h3>\n<p>Pour un objet, par défaut, le nom de la variable correspond au nom de la clé.\nSi, par exemple, vous avez déjà une variable portant le nom de la clé dans le\nscope, vous pouvez choisir de nommer différemment votre variable.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">var</span> myObject = {\n  <span class=\"hljs-attr\">foo</span>: <span class=\"hljs-number\">1</span>,\n  <span class=\"hljs-attr\">bar</span>: <span class=\"hljs-number\">2</span>\n}\n<span class=\"hljs-keyword\">const</span> { <span class=\"hljs-attr\">foo</span>: renamedFoo } = myObject\nrenamedFoo <span class=\"hljs-comment\">// 1</span></code></pre>\n<p>Cette syntaxe est, il faut tout de même le noter, peu lisible.</p>\n<h3 id=\"arguments-de-fonctions\"><a href=\"#arguments-de-fonctions\" class=\"phenomic-HeadingAnchor\">#</a>Arguments de fonctions</h3>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// On peut directement utiliser le destructuring dans une déclaration de</span>\n<span class=\"hljs-comment\">// fonction</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">myFunction</span>(<span class=\"hljs-params\">{ title, text }</span>) </span>{\n\t<span class=\"hljs-keyword\">return</span> title + <span class=\"hljs-string\">\": \"</span> + text\n}\n\nmyFunction({ <span class=\"hljs-attr\">title</span>: <span class=\"hljs-string\">\"foo\"</span>, <span class=\"hljs-attr\">text</span>: <span class=\"hljs-string\">\"bar\"</span> }) <span class=\"hljs-comment\">// \"foo: bar\"</span></code></pre>\n<h3 id=\"nested-destructuring\"><a href=\"#nested-destructuring\" class=\"phenomic-HeadingAnchor\">#</a>Nested destructuring</h3>\n<p>On peut aussi imbriquer les assignements.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">var</span> myObject = {\n  <span class=\"hljs-attr\">foo</span>: {\n    <span class=\"hljs-attr\">bar</span>: <span class=\"hljs-number\">1</span>,\n  },\n}\n<span class=\"hljs-keyword\">const</span> { <span class=\"hljs-attr\">foo</span>: { bar } } = myObject\nbar <span class=\"hljs-comment\">// 1</span></code></pre>\n<p>Attention cependant, si le destructuring au premier niveau ne fera que retourner\n<code>undefined</code> si la valeur n'existe pas, vous aurez bel et bien une erreur avec le\nnesting, puisqu'il essaiera d'aller chercher une propriété d'<code>undefined</code>.\nPour pallier ces soucis, rendez-vous pour l'article sur les\n<a href=\"/fr/articles/js/es2015/defaults/\">defaults</a>.</p>\n","rawBody":"\n## Le principe\n\nLe destructuring consiste à assigner des variables provenant d'un objet ou\ntableau en reposant sur leur structure.\n\n```js\n// Partons d'un objet `myObject`\nvar myObject = {\n  foo: 1,\n  bar: 2,\n}\n\n// Avec ES5, vous deviez par exemple faire\nvar foo = myObject.foo\nvar bar = myObject.bar\n\nfoo // 1\nbar // 2\n\n// Avec ES6, vous pouvez désormais l'écrire sous la forme\nconst { foo, bar } = myObject\nfoo // 1\nbar // 2\n\n// On peut bien entendu destructurer la valeur retournée par une\n// fonction, pour peu qu'il s'agisse d'un objet ou d'un tableau\nconst getMyObject = function() {\n  return {\n    foo: 1,\n    bar: 2,\n  }\n}\nconst { foo, bar } = getMyObject()\nfoo // 1\nbar // 2\n```\n\n\n## Les différentes syntaxes\n\n### Tableau\n\n```js\n// Pour un tableau, on utilise une forme proche de la déclaration litérale de\n// tableau, vous remarquerez que pour ignorer un item, il suffit de ne rien\n// placer entre les virgules\nconst [ first, second, , fourth ] = [1, 2, 3, 4]\nfirst // 1\nsecond // 2\nfourth // 4\n```\n\n### Utiliser un nom différent de la clé\n\nPour un objet, par défaut, le nom de la variable correspond au nom de la clé.\nSi, par exemple, vous avez déjà une variable portant le nom de la clé dans le\nscope, vous pouvez choisir de nommer différemment votre variable.\n\n```js\nvar myObject = {\n  foo: 1,\n  bar: 2\n}\nconst { foo: renamedFoo } = myObject\nrenamedFoo // 1\n```\n\nCette syntaxe est, il faut tout de même le noter, peu lisible.\n\n### Arguments de fonctions\n\n```js\n// On peut directement utiliser le destructuring dans une déclaration de\n// fonction\nfunction myFunction({ title, text }) {\n\treturn title + \": \" + text\n}\n\nmyFunction({ title: \"foo\", text: \"bar\" }) // \"foo: bar\"\n```\n\n### Nested destructuring\n\nOn peut aussi imbriquer les assignements.\n\n```js\nvar myObject = {\n  foo: {\n    bar: 1,\n  },\n}\nconst { foo: { bar } } = myObject\nbar // 1\n```\n\nAttention cependant, si le destructuring au premier niveau ne fera que retourner\n`undefined` si la valeur n'existe pas, vous aurez bel et bien une erreur avec le\nnesting, puisqu'il essaiera d'aller chercher une propriété d'`undefined`.\nPour pallier ces soucis, rendez-vous pour l'article sur les\n[defaults](/fr/articles/js/es2015/defaults/).\n","__filename":"fr/articles/js/es2015/destructuring.md","__url":"/fr/articles/js/es2015/destructuring/","__resourceUrl":"/fr/articles/js/es2015/destructuring/index.html","__dataUrl":"/fr/articles/js/es2015/destructuring/index.html.c47c5b03aa43a53d7d76d57cd5b5dce3.json"}