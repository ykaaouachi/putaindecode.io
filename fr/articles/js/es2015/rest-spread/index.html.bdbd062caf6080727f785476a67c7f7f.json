{"head":{"layout":"Post","comments":true,"date":"2015-12-12","title":"ES6, ES2015 : paramètres rest et opérateur spread","tags":["javascript","ES6","ES2015"],"authors":["zoontek"],"description":"Identiques en apparence et en syntaxe, ils permettent d'effectuer plus simplement des opérations complexes sur les tableaux, ou tout autre…"},"body":"<p>Identiques en apparence et en syntaxe, ils permettent d'effectuer plus\nsimplement des opérations complexes sur les tableaux, ou tout autre objet\nitérable.</p>\n<h2 id=\"les-paramètres-rest\"><a href=\"#les-param%C3%A8tres-rest\" class=\"phenomic-HeadingAnchor\">#</a>Les paramètres rest</h2>\n<p>Avez-vous déjà eu l'occasion d'utiliser l'horrible variable magique <code>arguments</code> ?\nDisponible au sein de chaque fonction, elle permet d'en récupérer, comme son\nnom l'indique, les arguments. Si l'objet récupéré est similaire à un <code>Array</code>,\nil ne dispose d'aucune des propriétés ou des méthodes de celui-ci, à\nl'exception de <code>length</code>.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">myFunction</span>(<span class=\"hljs-params\">separator</span>) </span>{\n  <span class=\"hljs-comment\">// conversion nécessaire en objet de type Array</span>\n  <span class=\"hljs-keyword\">var</span> words = <span class=\"hljs-built_in\">Array</span>.prototype.slice.call(<span class=\"hljs-built_in\">arguments</span>, <span class=\"hljs-number\">1</span>)\n  <span class=\"hljs-keyword\">return</span> words.join(separator)\n}\n\nmyFunction(<span class=\"hljs-string\">\"-\"</span>, <span class=\"hljs-string\">\"foo\"</span>, <span class=\"hljs-string\">\"bar\"</span>) <span class=\"hljs-comment\">// \"foo-bar\"</span></code></pre>\n<p>Les paramètres rest vous permettent de récupérer un véritable <code>Array</code> à l'aide\ndu simple préfixe <code>...</code> appliqué sur le <strong>dernier</strong> argument de votre fonction.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">myFunction</span>(<span class=\"hljs-params\">separator, ...words</span>) </span>{\n  <span class=\"hljs-keyword\">return</span> words.join(separator)\n}\n\nmyFunction(<span class=\"hljs-string\">\"-\"</span>, <span class=\"hljs-string\">\"foo\"</span>, <span class=\"hljs-string\">\"bar\"</span>) <span class=\"hljs-comment\">// \"foo-bar\"</span></code></pre>\n<p>Il vous sera en revanche impossible de lui attribuer une <a href=\"/fr/articles/js/es2015/defaults/\">valeur par défaut</a>.</p>\n<h2 id=\"lopérateur-spread\"><a href=\"#lop%C3%A9rateur-spread\" class=\"phenomic-HeadingAnchor\">#</a>L'opérateur spread</h2>\n<p>Aussi appelé opérateur de décomposition, il permet de développer un objet\nitérable (comme un <code>Array</code>) lorsqu'on a besoin de plusieurs arguments.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> myArray = [<span class=\"hljs-number\">1991</span>, <span class=\"hljs-number\">8</span>, <span class=\"hljs-number\">1</span>]\n<span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Date</span>(...myArray) <span class=\"hljs-comment\">// object Date - équivaut à: new Date(1991, 8, 1)</span>\n\n<span class=\"hljs-keyword\">const</span> myString = <span class=\"hljs-string\">\"foo bar\"</span>\n<span class=\"hljs-comment\">// les objets String étant itérables</span>\n[...myString] <span class=\"hljs-comment\">// [\"f\", \"o\", \"o\", \" \", \"b\", \"a\", \"r\"]</span></code></pre>\n<p>À noter que contrairement aux paramètres rest, l'opérateur spread peut être\nmélangé aux autres arguments d'une fonction.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> myArray = [<span class=\"hljs-number\">8</span>, <span class=\"hljs-number\">1</span>]\n<span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Date</span>(<span class=\"hljs-number\">1991</span>, ...myArray, <span class=\"hljs-number\">12</span>) <span class=\"hljs-comment\">// object Date - équivaut à: new Date(1991, 8, 1, 12)</span></code></pre>\n<p>Les possibilités offertes par cette nouveauté sont très nombreuses. Voici\nquelques usages un peu plus avancés pour stimuler votre inspiration :</p>\n<h4 id=\"Éviter-lutilisation-de-apply\"><a href=\"#%C3%89viter-lutilisation-de-apply\" class=\"phenomic-HeadingAnchor\">#</a>Éviter l'utilisation de .apply()</h4>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// ES5</span>\n<span class=\"hljs-built_in\">console</span>.log.apply(<span class=\"hljs-built_in\">console</span>, [<span class=\"hljs-string\">\"foo\"</span>, <span class=\"hljs-string\">\"bar\"</span>])\n\n<span class=\"hljs-comment\">// ES6 / ES2015</span>\n<span class=\"hljs-built_in\">console</span>.log(...[<span class=\"hljs-string\">\"foo\"</span>, <span class=\"hljs-string\">\"bar\"</span>]) <span class=\"hljs-comment\">// même résultat</span></code></pre>\n<h4 id=\"concaténer-plusieurs-itérables\"><a href=\"#concat%C3%A9ner-plusieurs-it%C3%A9rables\" class=\"phenomic-HeadingAnchor\">#</a>Concaténer plusieurs itérables</h4>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> stronglyTyped = [<span class=\"hljs-string\">\"scala\"</span>, <span class=\"hljs-string\">\"haskell\"</span>]\n\n<span class=\"hljs-comment\">// ES5</span>\n[<span class=\"hljs-string\">\"go\"</span>, <span class=\"hljs-string\">\"rust\"</span>].concat(stronglyTyped) <span class=\"hljs-comment\">// [\"go\", \"rust\", \"scala\", \"haskell\"]</span>\n\n<span class=\"hljs-comment\">// ES6 / ES2015</span>\n[<span class=\"hljs-string\">\"go\"</span>, <span class=\"hljs-string\">\"rust\"</span>, ...stronglyTyped] <span class=\"hljs-comment\">// [\"go\", \"rust\", \"scala\", \"haskell\"]</span></code></pre>\n<h4 id=\"déstructurer-dans-un-tableau\"><a href=\"#d%C3%A9structurer-dans-un-tableau\" class=\"phenomic-HeadingAnchor\">#</a>Déstructurer dans un tableau</h4>\n<p>Si vous n'avez pas encore connaissance des possibilités offertes par le\ndestructuring, je vous invite à lire ce <a href=\"/fr/articles/js/es2015/destructuring/\">précédent article</a>.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> words = [<span class=\"hljs-string\">\"foo\"</span>, <span class=\"hljs-string\">\"bar\"</span>, <span class=\"hljs-string\">\"baz\"</span>]\n\n<span class=\"hljs-comment\">// ES5</span>\n<span class=\"hljs-keyword\">const</span> first = words[<span class=\"hljs-number\">0</span>] <span class=\"hljs-comment\">// \"foo\"</span>\n<span class=\"hljs-keyword\">const</span> rest = words.slice(<span class=\"hljs-number\">1</span>) <span class=\"hljs-comment\">// [\"bar\", \"baz\"]</span>\n\n<span class=\"hljs-comment\">// ES6 / ES2015</span>\n<span class=\"hljs-keyword\">const</span> [first, ...rest] = words <span class=\"hljs-comment\">// même résulat</span></code></pre>\n<h4 id=\"itérer-sur-le-résultat-dun-queryselectorall\"><a href=\"#it%C3%A9rer-sur-le-r%C3%A9sultat-dun-queryselectorall\" class=\"phenomic-HeadingAnchor\">#</a>Itérer sur le résultat d'un .querySelectorAll()</h4>\n<pre><code class=\"hljs language-js\">[...document.querySelectorAll(<span class=\"hljs-string\">'div'</span>)] <span class=\"hljs-comment\">// [&#x3C;div>, &#x3C;div>, &#x3C;div>]</span></code></pre>\n<h2 id=\"en-résumé\"><a href=\"#en-r%C3%A9sum%C3%A9\" class=\"phenomic-HeadingAnchor\">#</a>En résumé</h2>\n<p>Comme vous avez pu le constater par vous-même, les cas d'utilisation des\nparamètres rest et de l'opérateur spread sont légion.</p>\n<p><a href=\"http://kangax.github.io/compat-table/es6/#spread_(...)_operator\">Gérés</a>\ncorrectement par Babel et Traceur, ils vous permettront de rendre votre code\nplus concis en évitant bien souvent l'écriture de boucles inutiles.</p>\n","rawBody":"\nIdentiques en apparence et en syntaxe, ils permettent d'effectuer plus\nsimplement des opérations complexes sur les tableaux, ou tout autre objet\nitérable.\n\n## Les paramètres rest\n\nAvez-vous déjà eu l'occasion d'utiliser l'horrible variable magique `arguments` ?\nDisponible au sein de chaque fonction, elle permet d'en récupérer, comme son\nnom l'indique, les arguments. Si l'objet récupéré est similaire à un `Array`,\nil ne dispose d'aucune des propriétés ou des méthodes de celui-ci, à\nl'exception de `length`.\n\n```js\nfunction myFunction(separator) {\n  // conversion nécessaire en objet de type Array\n  var words = Array.prototype.slice.call(arguments, 1)\n  return words.join(separator)\n}\n\nmyFunction(\"-\", \"foo\", \"bar\") // \"foo-bar\"\n```\n\nLes paramètres rest vous permettent de récupérer un véritable `Array` à l'aide\ndu simple préfixe `...` appliqué sur le **dernier** argument de votre fonction.\n\n```js\nfunction myFunction(separator, ...words) {\n  return words.join(separator)\n}\n\nmyFunction(\"-\", \"foo\", \"bar\") // \"foo-bar\"\n```\n\nIl vous sera en revanche impossible de lui attribuer une [valeur par défaut](/fr/articles/js/es2015/defaults/).\n\n## L'opérateur spread\n\nAussi appelé opérateur de décomposition, il permet de développer un objet\nitérable (comme un `Array`) lorsqu'on a besoin de plusieurs arguments.\n\n```js\nconst myArray = [1991, 8, 1]\nnew Date(...myArray) // object Date - équivaut à: new Date(1991, 8, 1)\n\nconst myString = \"foo bar\"\n// les objets String étant itérables\n[...myString] // [\"f\", \"o\", \"o\", \" \", \"b\", \"a\", \"r\"]\n```\n\nÀ noter que contrairement aux paramètres rest, l'opérateur spread peut être\nmélangé aux autres arguments d'une fonction.\n\n```js\nconst myArray = [8, 1]\nnew Date(1991, ...myArray, 12) // object Date - équivaut à: new Date(1991, 8, 1, 12)\n```\n\nLes possibilités offertes par cette nouveauté sont très nombreuses. Voici\nquelques usages un peu plus avancés pour stimuler votre inspiration :\n\n#### Éviter l'utilisation de .apply()\n\n```js\n// ES5\nconsole.log.apply(console, [\"foo\", \"bar\"])\n\n// ES6 / ES2015\nconsole.log(...[\"foo\", \"bar\"]) // même résultat\n```\n\n#### Concaténer plusieurs itérables\n\n```js\nconst stronglyTyped = [\"scala\", \"haskell\"]\n\n// ES5\n[\"go\", \"rust\"].concat(stronglyTyped) // [\"go\", \"rust\", \"scala\", \"haskell\"]\n\n// ES6 / ES2015\n[\"go\", \"rust\", ...stronglyTyped] // [\"go\", \"rust\", \"scala\", \"haskell\"]\n```\n\n#### Déstructurer dans un tableau\n\nSi vous n'avez pas encore connaissance des possibilités offertes par le\ndestructuring, je vous invite à lire ce [précédent article](/fr/articles/js/es2015/destructuring/).\n\n```js\nconst words = [\"foo\", \"bar\", \"baz\"]\n\n// ES5\nconst first = words[0] // \"foo\"\nconst rest = words.slice(1) // [\"bar\", \"baz\"]\n\n// ES6 / ES2015\nconst [first, ...rest] = words // même résulat\n```\n\n#### Itérer sur le résultat d'un .querySelectorAll()\n```js\n[...document.querySelectorAll('div')] // [<div>, <div>, <div>]\n```\n\n## En résumé\n\nComme vous avez pu le constater par vous-même, les cas d'utilisation des\nparamètres rest et de l'opérateur spread sont légion.\n\n[Gérés](http://kangax.github.io/compat-table/es6/#spread_(...)_operator)\ncorrectement par Babel et Traceur, ils vous permettront de rendre votre code\nplus concis en évitant bien souvent l'écriture de boucles inutiles.\n","__filename":"fr/articles/js/es2015/rest-spread.md","__url":"/fr/articles/js/es2015/rest-spread/","__resourceUrl":"/fr/articles/js/es2015/rest-spread/index.html","__dataUrl":"/fr/articles/js/es2015/rest-spread/index.html.bdbd062caf6080727f785476a67c7f7f.json"}