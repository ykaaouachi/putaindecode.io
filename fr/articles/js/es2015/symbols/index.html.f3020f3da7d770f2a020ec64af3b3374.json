{"head":{"layout":"Post","comments":true,"date":"2015-12-17","title":"ES6, ES2015 : les symboles","tags":["javascript","ES6","ES2015"],"authors":["divarvel"],"description":"Dans sa politique d'enrichissement des types primitifs, ES6 introduit les symboles. Chers aux développeurs de nombreux langages, Ruby en…"},"body":"<p>Dans sa politique d'enrichissement des types primitifs, ES6 introduit les\nsymboles. Chers aux développeurs de nombreux langages, Ruby en tête, les\nsymboles constituent une étape de plus vers l'éradication du <em>stringly-typed\nprogramming</em>. En effet, les symboles fournissent un moyen plus robuste de\nreprésenter des identifiants.</p>\n<h2 id=\"créer-un-symbole\"><a href=\"#cr%C3%A9er-un-symbole\" class=\"phenomic-HeadingAnchor\">#</a>Créer un symbole</h2>\n<p>La fonction <code>Symbol()</code> permet de créer de nouveaux symboles :</p>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-comment\">// Un symbole tout bête</span>\n<span class=\"hljs-keyword\">const</span> mySymbol = <span class=\"hljs-built_in\">Symbol</span>();\n<span class=\"hljs-keyword\">typeof</span> mySymbol === <span class=\"hljs-string\">'symbol'</span> <span class=\"hljs-comment\">// true</span>\n\n<span class=\"hljs-comment\">// Un symbole avec une description</span>\n<span class=\"hljs-keyword\">const</span> myOtherSymbol = <span class=\"hljs-built_in\">Symbol</span>(<span class=\"hljs-string\">\"description\"</span>);\n\n\n<span class=\"hljs-comment\">// Chaque symbole est unique</span>\n<span class=\"hljs-keyword\">const</span> yetAnotherSymbol = <span class=\"hljs-built_in\">Symbol</span>(<span class=\"hljs-string\">\"description\"</span>);\nyetAnotherSymbol === myOtherSymbol; <span class=\"hljs-comment\">// false</span></code></pre>\n<p>Chaque symbole créé avec <code>Symbol</code> est unique et immutable. Cela permet\nd'éviter les collisions : on ne peut pas avoir deux symboles identiques par\nerreur.</p>\n<h2 id=\"utiliser-les-symboles-pour-limplémentation-dun-enum\"><a href=\"#utiliser-les-symboles-pour-limpl%C3%A9mentation-dun-enum\" class=\"phenomic-HeadingAnchor\">#</a>Utiliser les symboles pour l'implémentation d'un <em>enum</em></h2>\n<p>Plutôt que d'utiliser des chaînes de caractères comme valeurs possible d'un\n<em>enum</em>, on peut utiliser des symboles.</p>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-keyword\">const</span> ANIMAL_DOG = <span class=\"hljs-built_in\">Symbol</span>();\n<span class=\"hljs-keyword\">const</span> ANIMAL_CAT = <span class=\"hljs-built_in\">Symbol</span>();\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">getDescription</span>(<span class=\"hljs-params\">animal</span>) </span>{\n  <span class=\"hljs-keyword\">switch</span>(animal) {\n    <span class=\"hljs-keyword\">case</span> ANIMAL_DOG:\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">\"Loving animal\"</span>;\n    <span class=\"hljs-keyword\">case</span> ANIMAL_CAT:\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">\"Evil, sadistic animal\"</span>;\n  }\n}</code></pre>\n<p>De cette manière, on ne risque pas de mélanger accidentellement une chaine de\ncaractères fournie par l'utilisateur et la valeur d'un <em>enum</em>. On est obligé\nde passer par une phase de parsing et de vérification.</p>\n<h2 id=\"utiliser-un-symbole-comme-clé\"><a href=\"#utiliser-un-symbole-comme-cl%C3%A9\" class=\"phenomic-HeadingAnchor\">#</a>Utiliser un symbole comme clé</h2>\n<p>Il est possible d'employer des symboles comme clés d'un objet ou d'une classe.</p>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-keyword\">const</span> myKey = <span class=\"hljs-built_in\">Symbol</span>(<span class=\"hljs-string\">\"MY_KEY\"</span>);\n\n<span class=\"hljs-keyword\">const</span> myMutableObject = {};\nmyMutableObject[myKey] = <span class=\"hljs-string\">\"a value\"</span>;\n\n<span class=\"hljs-comment\">// En utilisant les *computed property keys*</span>\n<span class=\"hljs-keyword\">const</span> myObj = {\n    [myKey]: <span class=\"hljs-string\">\"a value\"</span>\n}</code></pre>\n<p>Grâce à l'unicité des symboles, plus de problèmes de collision entre les clés\nd'un objet. On peut laisser l'utilisateur étendre des objets sans prendre le\nrisque d'avoir des propriétés écrasées par erreur.</p>\n<p>Par exemple, l'itérateur d'un objet employé par <code>for..of</code> est une propriété\nqui a pour clé un symbole, accessible via <code>Symbol.iterator</code>.</p>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-keyword\">const</span> myIterableObject = {\n  * [<span class=\"hljs-built_in\">Symbol</span>.iterator]() {\n    <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-string\">\"One\"</span>;\n    <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-string\">\"Two\"</span>;\n    <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-string\">\"Three\"</span>;\n  }\n}\n\n<span class=\"hljs-comment\">// Affichera One, Two et Three</span>\n<span class=\"hljs-keyword\">for</span>(x <span class=\"hljs-keyword\">of</span> myIterableObject) {\n  <span class=\"hljs-built_in\">console</span>.log(x);\n}\n\n<span class=\"hljs-comment\">// Plantera avec 'TypeError: undefined is not a function'</span>\n<span class=\"hljs-keyword\">for</span>(x <span class=\"hljs-keyword\">of</span> {}) {}</code></pre>\n<p>Différents symboles (les <em>well-known symbols</em>) sont disponibles pour indexer\ndes propriétés qui personnalisent le comportement des objets :\n<code>Symbol.iterator</code> pour itérer sur les valeurs d'un objet, <code>Symbol.hasInstance</code>\npour modifier le retour de <code>instanceof</code>, …</p>\n<p>Ces propriétés sont ainsi protégées contre tout accès involontaire.</p>\n<h3 id=\"différences-avec-lutilisation-dune-chaine-de-caractères-comme-clé\"><a href=\"#diff%C3%A9rences-avec-lutilisation-dune-chaine-de-caract%C3%A8res-comme-cl%C3%A9\" class=\"phenomic-HeadingAnchor\">#</a>Différences avec l'utilisation d'une chaine de caractères comme clé</h3>\n<p>Les propriétés indexées par des symboles ne sont pas accessibles depuis les\nfonctions habituellement utilisées pour itérer sur les propriétés ou les\nvaleurs.</p>\n<h4 id=\"Énumération\"><a href=\"#%C3%89num%C3%A9ration\" class=\"phenomic-HeadingAnchor\">#</a>Énumération</h4>\n<p>Les propriétés indexées par des symboles ne sont pas visitées par <code>for..in</code>,\nni listées par <code>Object.keys</code> ni <code>Object.getOwnPropertyNames</code>. En revanche,\nelles sont listées par <code>Object.getOwnPropertySymbols</code>.</p>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-keyword\">const</span> myObject = {\n  [<span class=\"hljs-built_in\">Symbol</span>()]: <span class=\"hljs-string\">\"symbol-keyed value\"</span>,\n  <span class=\"hljs-string\">\"key\"</span>: <span class=\"hljs-string\">\"string-keyed value\"</span>\n}\n\n<span class=\"hljs-built_in\">Object</span>.getOwnPropertyNames(myObject) <span class=\"hljs-comment\">// [ \"key\" ]</span>\n<span class=\"hljs-built_in\">Object</span>.getOwnPropertySymbols(myObject) <span class=\"hljs-comment\">// [ Symbol() ]</span></code></pre>\n<p>Ainsi, du code utilisant <code>Object.getOwnPropertyNames</code> et s'attendant à\nrecevoir des chaînes de caractères ne sera pas cassé par l'utilisation de\nsymboles en tant que clés.</p>\n<h4 id=\"jsonstringify\"><a href=\"#jsonstringify\" class=\"phenomic-HeadingAnchor\">#</a><code>JSON.stringify</code></h4>\n<p>Les propriétés indexées par un symbole sont ignorées par <code>JSON.stringify</code>.</p>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-built_in\">JSON</span>.stringify({\n  [<span class=\"hljs-built_in\">Symbol</span>()]: <span class=\"hljs-string\">\"symbol-keyed value\"</span>,\n  <span class=\"hljs-string\">\"key\"</span>: <span class=\"hljs-string\">\"string-keyed value\"</span>\n}) <span class=\"hljs-comment\">// '{\"key\":\"string-keyed value\"}'</span></code></pre>\n<h2 id=\"registre-global-des-symboles\"><a href=\"#registre-global-des-symboles\" class=\"phenomic-HeadingAnchor\">#</a>Registre global des symboles</h2>\n<p>Un symbole est unique, une fois créé, il est impossible d'en créér un autre\nayant les mêmes propriétés. Il faut donc que le symbole créé soit accessible\nd'une manière ou d'une autre pour pouvoir l'employer. En revanche, il est\npossible de créer un symbole dans un registre global accessible de n'importe\noù, grâce à <code>Symbol.for</code>.</p>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-comment\">// Renvoie un symbole, en le créant s'il n'existe pas déjà</span>\n<span class=\"hljs-keyword\">const</span> mySymbol = <span class=\"hljs-built_in\">Symbol</span>.for(<span class=\"hljs-string\">\"mySymbol\"</span>)\n\nmySymbol === <span class=\"hljs-built_in\">Symbol</span>.for(<span class=\"hljs-string\">\"mySymbol\"</span>) <span class=\"hljs-comment\">// true</span>\n\n<span class=\"hljs-comment\">// Il est possible de récupérer la clé avec laquelle un symbole a été inséré</span>\n<span class=\"hljs-comment\">// dans le registre</span>\n<span class=\"hljs-built_in\">Symbol</span>.keyFor(mySymbol) <span class=\"hljs-comment\">// 'mySymbol'</span>\n\n<span class=\"hljs-comment\">// Un symbole non créé dans le registre n'est pas disponible</span>\n<span class=\"hljs-built_in\">Symbol</span>.keyFor(<span class=\"hljs-built_in\">Symbol</span>()) <span class=\"hljs-comment\">// undefined</span></code></pre>\n<p><code>Symbol.for</code> permet donc de partager des symboles partout dans le code, y\ncompris dans des contextes d'exécution différents (différentes frames).</p>\n<h2 id=\"support\"><a href=\"#support\" class=\"phenomic-HeadingAnchor\">#</a>Support</h2>\n<p>Côté navigateur, les symboles sont supportés depuis Chrome 38, Firefox 36,\nOpera 25 et Safari 9. Rien chez Internet Explorer. Le support Babel est\nlimité.</p>\n<p>Côté Node.js, le support des symboles est là depuis la version <code>0.12</code>.</p>\n<p>Les <em>well-known symbols</em> ne sont pas tous disponibles sur les différentes\nplates-formes, leur présence dépendant des fonctionnalités auxquelles ils sont\nliés.</p>\n<h2 id=\"pour-résumer\"><a href=\"#pour-r%C3%A9sumer\" class=\"phenomic-HeadingAnchor\">#</a>Pour résumer</h2>\n<p>Les symboles fournissent un moyen de créer des tokens uniques, ce qui est bien\nplus robuste que l'utilisation de chaînes de caractères. L'utilisation des\nsymboles pour représenter les valeurs d'un <em>enum</em> permet d'éviter les\ncollisions et le mélange avec des données non qualifiées.</p>\n<p>En tant que clés d'un objet, les symboles permettent d'éviter les collisions\net d'avoir des <em>méta-propriétés</em> séparées et indépendantes des propriétés\nindexées par des clés. Les propriétés indexées par des symboles ne peuvent pas\nêtre lues, modifiées ou listées par erreur, ce qui leur offre un certain degré\nde protection contre des manipulations accidentelles.</p>\n<h2 id=\"pour-aller-plus-loin\"><a href=\"#pour-aller-plus-loin\" class=\"phenomic-HeadingAnchor\">#</a>Pour aller plus loin</h2>\n<ul>\n<li><a href=\"https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Symbol\">La documentation des symboles sur MDN</a></li>\n<li><a href=\"http://www.2ality.com/2014/12/es6-symbols.html\">Un article complet sur le fonctionnement des symboles et leur cas\nd'utilisation</a></li>\n</ul>\n","rawBody":"\nDans sa politique d'enrichissement des types primitifs, ES6 introduit les\nsymboles. Chers aux développeurs de nombreux langages, Ruby en tête, les\nsymboles constituent une étape de plus vers l'éradication du *stringly-typed\nprogramming*. En effet, les symboles fournissent un moyen plus robuste de\nreprésenter des identifiants.\n\n## Créer un symbole\n\nLa fonction `Symbol()` permet de créer de nouveaux symboles :\n\n```javascript\n// Un symbole tout bête\nconst mySymbol = Symbol();\ntypeof mySymbol === 'symbol' // true\n\n// Un symbole avec une description\nconst myOtherSymbol = Symbol(\"description\");\n\n\n// Chaque symbole est unique\nconst yetAnotherSymbol = Symbol(\"description\");\nyetAnotherSymbol === myOtherSymbol; // false\n```\n\nChaque symbole créé avec `Symbol` est unique et immutable. Cela permet\nd'éviter les collisions : on ne peut pas avoir deux symboles identiques par\nerreur.\n\n## Utiliser les symboles pour l'implémentation d'un *enum*\n\nPlutôt que d'utiliser des chaînes de caractères comme valeurs possible d'un\n*enum*, on peut utiliser des symboles.\n\n```javascript\nconst ANIMAL_DOG = Symbol();\nconst ANIMAL_CAT = Symbol();\n\nfunction getDescription(animal) {\n  switch(animal) {\n    case ANIMAL_DOG:\n        return \"Loving animal\";\n    case ANIMAL_CAT:\n        return \"Evil, sadistic animal\";\n  }\n}\n```\n\nDe cette manière, on ne risque pas de mélanger accidentellement une chaine de\ncaractères fournie par l'utilisateur et la valeur d'un *enum*. On est obligé\nde passer par une phase de parsing et de vérification.\n\n## Utiliser un symbole comme clé\n\nIl est possible d'employer des symboles comme clés d'un objet ou d'une classe.\n\n```javascript\nconst myKey = Symbol(\"MY_KEY\");\n\nconst myMutableObject = {};\nmyMutableObject[myKey] = \"a value\";\n\n// En utilisant les *computed property keys*\nconst myObj = {\n    [myKey]: \"a value\"\n}\n```\n\nGrâce à l'unicité des symboles, plus de problèmes de collision entre les clés\nd'un objet. On peut laisser l'utilisateur étendre des objets sans prendre le\nrisque d'avoir des propriétés écrasées par erreur.\n\nPar exemple, l'itérateur d'un objet employé par `for..of` est une propriété\nqui a pour clé un symbole, accessible via `Symbol.iterator`.\n\n```javascript\nconst myIterableObject = {\n  * [Symbol.iterator]() {\n    yield \"One\";\n    yield \"Two\";\n    yield \"Three\";\n  }\n}\n\n// Affichera One, Two et Three\nfor(x of myIterableObject) {\n  console.log(x);\n}\n\n// Plantera avec 'TypeError: undefined is not a function'\nfor(x of {}) {}\n```\n\nDifférents symboles (les *well-known symbols*) sont disponibles pour indexer\ndes propriétés qui personnalisent le comportement des objets :\n`Symbol.iterator` pour itérer sur les valeurs d'un objet, `Symbol.hasInstance`\npour modifier le retour de `instanceof`, …\n\nCes propriétés sont ainsi protégées contre tout accès involontaire.\n\n### Différences avec l'utilisation d'une chaine de caractères comme clé\n\nLes propriétés indexées par des symboles ne sont pas accessibles depuis les\nfonctions habituellement utilisées pour itérer sur les propriétés ou les\nvaleurs.\n\n#### Énumération\n\nLes propriétés indexées par des symboles ne sont pas visitées par `for..in`,\nni listées par `Object.keys` ni `Object.getOwnPropertyNames`. En revanche,\nelles sont listées par `Object.getOwnPropertySymbols`.\n\n```javascript\nconst myObject = {\n  [Symbol()]: \"symbol-keyed value\",\n  \"key\": \"string-keyed value\"\n}\n\nObject.getOwnPropertyNames(myObject) // [ \"key\" ]\nObject.getOwnPropertySymbols(myObject) // [ Symbol() ]\n```\n\nAinsi, du code utilisant `Object.getOwnPropertyNames` et s'attendant à\nrecevoir des chaînes de caractères ne sera pas cassé par l'utilisation de\nsymboles en tant que clés.\n\n#### `JSON.stringify`\n\nLes propriétés indexées par un symbole sont ignorées par `JSON.stringify`.\n\n\n```javascript\nJSON.stringify({\n  [Symbol()]: \"symbol-keyed value\",\n  \"key\": \"string-keyed value\"\n}) // '{\"key\":\"string-keyed value\"}'\n```\n\n## Registre global des symboles\n\nUn symbole est unique, une fois créé, il est impossible d'en créér un autre\nayant les mêmes propriétés. Il faut donc que le symbole créé soit accessible\nd'une manière ou d'une autre pour pouvoir l'employer. En revanche, il est\npossible de créer un symbole dans un registre global accessible de n'importe\noù, grâce à `Symbol.for`.\n\n```javascript\n// Renvoie un symbole, en le créant s'il n'existe pas déjà\nconst mySymbol = Symbol.for(\"mySymbol\")\n\nmySymbol === Symbol.for(\"mySymbol\") // true\n\n// Il est possible de récupérer la clé avec laquelle un symbole a été inséré\n// dans le registre\nSymbol.keyFor(mySymbol) // 'mySymbol'\n\n// Un symbole non créé dans le registre n'est pas disponible\nSymbol.keyFor(Symbol()) // undefined\n```\n\n`Symbol.for` permet donc de partager des symboles partout dans le code, y\ncompris dans des contextes d'exécution différents (différentes frames).\n\n## Support\n\nCôté navigateur, les symboles sont supportés depuis Chrome 38, Firefox 36,\nOpera 25 et Safari 9. Rien chez Internet Explorer. Le support Babel est\nlimité.\n\nCôté Node.js, le support des symboles est là depuis la version `0.12`.\n\nLes *well-known symbols* ne sont pas tous disponibles sur les différentes\nplates-formes, leur présence dépendant des fonctionnalités auxquelles ils sont\nliés.\n\n## Pour résumer\n\nLes symboles fournissent un moyen de créer des tokens uniques, ce qui est bien\nplus robuste que l'utilisation de chaînes de caractères. L'utilisation des\nsymboles pour représenter les valeurs d'un *enum* permet d'éviter les\ncollisions et le mélange avec des données non qualifiées.\n\nEn tant que clés d'un objet, les symboles permettent d'éviter les collisions\net d'avoir des *méta-propriétés* séparées et indépendantes des propriétés\nindexées par des clés. Les propriétés indexées par des symboles ne peuvent pas\nêtre lues, modifiées ou listées par erreur, ce qui leur offre un certain degré\nde protection contre des manipulations accidentelles.\n\n\n## Pour aller plus loin\n\n - [La documentation des symboles sur MDN](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Symbol)\n - [Un article complet sur le fonctionnement des symboles et leur cas\nd'utilisation](http://www.2ality.com/2014/12/es6-symbols.html)\n","__filename":"fr/articles/js/es2015/symbols.md","__url":"/fr/articles/js/es2015/symbols/","__resourceUrl":"/fr/articles/js/es2015/symbols/index.html","__dataUrl":"/fr/articles/js/es2015/symbols/index.html.f3020f3da7d770f2a020ec64af3b3374.json"}