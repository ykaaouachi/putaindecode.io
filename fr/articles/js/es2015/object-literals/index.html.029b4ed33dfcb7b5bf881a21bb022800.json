{"head":{"layout":"Post","comments":true,"date":"2015-12-08","title":"ES6, ES2015 : Les object literals","tags":["JavaScript","ES6","ES2015"],"authors":["lionelB"],"description":"Là encore, cette évolution du langage amène un sucre syntaxique bien pratique lors de l'initialisation d'objets. Nom des propriétés…"},"body":"<p>Là encore, cette évolution du langage amène un sucre syntaxique bien pratique\nlors de l'initialisation d'objets.</p>\n<h2 id=\"nom-des-propriétés-raccourcies\"><a href=\"#nom-des-propri%C3%A9t%C3%A9s-raccourcies\" class=\"phenomic-HeadingAnchor\">#</a>Nom des propriétés raccourcies</h2>\n<p>Lorsqu'on crée un objet, il arrive fréquemment que lorsqu'on définisse une\npropriété depuis une variable, la clé porte le même nom que la variable.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">var</span> firstname = <span class=\"hljs-string\">\"Robert\"</span>\n<span class=\"hljs-keyword\">var</span> lastname = <span class=\"hljs-string\">\"Laiponje\"</span>\n\n<span class=\"hljs-keyword\">return</span> {\n  <span class=\"hljs-attr\">firstname</span>: firstname,\n  <span class=\"hljs-attr\">lastname</span>: lastname,\n}</code></pre>\n<p>Avec ES2015, on va pouvoir l'écrire comme ça :</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> firstname = <span class=\"hljs-string\">\"Robert\"</span>\n<span class=\"hljs-keyword\">const</span> lastname = <span class=\"hljs-string\">\"Laiponje\"</span>\n\n<span class=\"hljs-keyword\">return</span> {\n  firstname,\n  lastname,\n}\n<span class=\"hljs-comment\">// { firstname: \"Robert\", lastname: \"Laiponje\" }</span></code></pre>\n<p>De la même manière, on pourra déclarer des méthodes en se passant du mot clé\n<code>function</code>. Idem pour les <em>getter</em> / <em>setter</em>.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> obj = {\n  get email() {\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">this</span>.email()\n  },\n  set email(email) {\n    <span class=\"hljs-keyword\">this</span>.email = email\n  },\n  validateEmail(email) {\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>\n  },\n}</code></pre>\n<h2 id=\"nom-de-propriétés-calculées\"><a href=\"#nom-de-propri%C3%A9t%C3%A9s-calcul%C3%A9es\" class=\"phenomic-HeadingAnchor\">#</a>Nom de propriétés calculées</h2>\n<p>La dernière nouveauté concernant les <em>literal objects</em> va nous permettre\nde créer des noms de propriétés depuis une expression, directement à la\ncréation de l'objet. Auparavant, il fallait procéder en 2 temps, création\npuis affectation.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">action</span>(<span class=\"hljs-params\">type, data</span>) </span>{\n  <span class=\"hljs-keyword\">var</span> payload = {}\n  payload[type] = data\n  <span class=\"hljs-keyword\">return</span> payload\n}</code></pre>\n<p>En ES2015, cela donnerait :</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">action</span>(<span class=\"hljs-params\">type, data</span>) </span>{\n  <span class=\"hljs-keyword\">return</span> {\n    [type]: data\n  }\n}</code></pre>\n<p><strong>À noter</strong> qu'avec l'introduction des propriétés calculées, on va pouvoir\naussi déclarer plusieurs fois une même propriété, la dernière déclaration\nécrasant les précédentes (et plus de <code>syntaxError</code>).</p>\n","rawBody":"\nLà encore, cette évolution du langage amène un sucre syntaxique bien pratique\nlors de l'initialisation d'objets.\n\n## Nom des propriétés raccourcies\n\nLorsqu'on crée un objet, il arrive fréquemment que lorsqu'on définisse une\npropriété depuis une variable, la clé porte le même nom que la variable.\n\n```js\nvar firstname = \"Robert\"\nvar lastname = \"Laiponje\"\n\nreturn {\n  firstname: firstname,\n  lastname: lastname,\n}\n```\n\nAvec ES2015, on va pouvoir l'écrire comme ça :\n\n```js\nconst firstname = \"Robert\"\nconst lastname = \"Laiponje\"\n\nreturn {\n  firstname,\n  lastname,\n}\n// { firstname: \"Robert\", lastname: \"Laiponje\" }\n```\n\nDe la même manière, on pourra déclarer des méthodes en se passant du mot clé\n`function`. Idem pour les *getter* / *setter*.\n\n```js\nconst obj = {\n  get email() {\n    return this.email()\n  },\n  set email(email) {\n    this.email = email\n  },\n  validateEmail(email) {\n    return true\n  },\n}\n```\n\n## Nom de propriétés calculées\n\nLa dernière nouveauté concernant les *literal objects* va nous permettre\nde créer des noms de propriétés depuis une expression, directement à la\ncréation de l'objet. Auparavant, il fallait procéder en 2 temps, création\npuis affectation.\n\n```js\nfunction action(type, data) {\n  var payload = {}\n  payload[type] = data\n  return payload\n}\n```\n\nEn ES2015, cela donnerait :\n\n```js\nfunction action(type, data) {\n  return {\n    [type]: data\n  }\n}\n```\n\n**À noter** qu'avec l'introduction des propriétés calculées, on va pouvoir\naussi déclarer plusieurs fois une même propriété, la dernière déclaration\nécrasant les précédentes (et plus de `syntaxError`).\n","__filename":"fr/articles/js/es2015/object-literals.md","__url":"/fr/articles/js/es2015/object-literals/","__resourceUrl":"/fr/articles/js/es2015/object-literals/index.html","__dataUrl":"/fr/articles/js/es2015/object-literals/index.html.029b4ed33dfcb7b5bf881a21bb022800.json"}