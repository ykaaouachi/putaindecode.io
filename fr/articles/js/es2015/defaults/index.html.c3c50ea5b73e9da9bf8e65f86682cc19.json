{"head":{"layout":"Post","comments":true,"date":"2015-12-03","title":"ES6, ES2015 : les valeurs par défaut des arguments","tags":["javascript","ES6","ES2015"],"authors":["naholyr"],"description":"Fatigués de taper if (typeof x === 'undefined') x = defaultValue ? Là encore ES6 va nous apporter une solution élégante. Valeurs par défaut…"},"body":"<p>Fatigués de taper <code>if (typeof x === 'undefined') x = defaultValue</code> ? Là encore\nES6 va nous apporter une solution élégante.</p>\n<h1 id=\"valeurs-par-défaut\"><a href=\"#valeurs-par-d%C3%A9faut\" class=\"phenomic-HeadingAnchor\">#</a>Valeurs par défaut</h1>\n<p>L'opérateur <code>=</code> permet maintenant en plus d'affecter une valeur à une variable\nde définir une valeur par défaut à un paramètre.</p>\n<h2 id=\"paramètres-de-fonction\"><a href=\"#param%C3%A8tres-de-fonction\" class=\"phenomic-HeadingAnchor\">#</a>Paramètres de fonction</h2>\n<p>Il est maintenant possible de spécifier une valeur par défaut à un paramètre de\nfonction. Cette valeur sera utilisée si le paramètre n'est pas fourni, ou qu'il\nest explicitement défini à <em>undefined</em>.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">incr</span> (<span class=\"hljs-params\">value, step = <span class=\"hljs-number\">1</span></span>) </span>{\n  <span class=\"hljs-keyword\">return</span> value + step\n}\n\nincr(<span class=\"hljs-number\">41</span>) <span class=\"hljs-comment\">// 42</span>\nincr(<span class=\"hljs-number\">41</span>, <span class=\"hljs-literal\">undefined</span>) <span class=\"hljs-comment\">// 42</span>\nincr(<span class=\"hljs-number\">33</span>, <span class=\"hljs-number\">9</span>) <span class=\"hljs-comment\">// 42</span></code></pre>\n<h3 id=\"valeurs-par-défaut-dynamiques\"><a href=\"#valeurs-par-d%C3%A9faut-dynamiques\" class=\"phenomic-HeadingAnchor\">#</a>Valeurs par défaut dynamiques</h3>\n<p>On peut spécifier une expression en tant que valeur par défaut. Cette expression\nsera évaluée <strong>à l'appel de la fonction</strong>, pas lors de sa déclaration.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">let</span> defaultWho = <span class=\"hljs-string\">'world!'</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">hello</span> (<span class=\"hljs-params\">who = defaultWho.toUpperCase(</span>)) </span>{\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">'Hello '</span> + who\n}\n\nhello() <span class=\"hljs-comment\">// 'Hello WORLD!'</span>\ndefaultWho = <span class=\"hljs-string\">'Anyone?'</span>\nhello() <span class=\"hljs-comment\">// 'Hello ANYONE?'</span></code></pre>\n<h3 id=\"réutilisation-des-paramètres-précédents\"><a href=\"#r%C3%A9utilisation-des-param%C3%A8tres-pr%C3%A9c%C3%A9dents\" class=\"phenomic-HeadingAnchor\">#</a>Réutilisation des paramètres précédents</h3>\n<p>Dans l'expression d'une valeur par défaut, on peut réutiliser les paramètres\n<strong>précédents</strong> de la fonction :</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">foo</span> (<span class=\"hljs-params\">x = <span class=\"hljs-number\">1</span>, y = x + <span class=\"hljs-number\">1</span></span>) </span>{\n  <span class=\"hljs-keyword\">return</span> x + y\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">bar</span> (<span class=\"hljs-params\">x = y + <span class=\"hljs-number\">1</span>, y = <span class=\"hljs-number\">1</span></span>) </span>{\n  <span class=\"hljs-keyword\">return</span> x + y\n}\n\nfoo() <span class=\"hljs-comment\">// 1 + (1 + 1) → 3</span>\nbar() <span class=\"hljs-comment\">// (undefined + 1) + 1 → NaN</span></code></pre>\n<h3 id=\"cas-particulier-tdz-temporal-dead-zone\"><a href=\"#cas-particulier-tdz-temporal-dead-zone\" class=\"phenomic-HeadingAnchor\">#</a>Cas particulier : TDZ (Temporal Dead Zone)</h3>\n<p>Une <em>temporal dead zone</em> désigne une zone du programme où une variable \"existe\"\nmais n'est pas encore accessible tant qu'elle n'a pas reçu de valeur.</p>\n<p>L'exemple suivant semble très logiquement invalide :</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">foo</span> (<span class=\"hljs-params\">x = x</span>) </span>{ <span class=\"hljs-comment\">// throws ReferenceError?</span>\n}</code></pre>\n<p>En effet, au moment de l'appel à la fonction, <code>x</code> n'a pas encore été défini,\net ne peut donc être utilisé comme valeur par défaut. Il semble que cet exemple\ndevrait <a href=\"http://dmitrysoshnikov.com/ecmascript/es6-notes-default-values-of-parameters/#tdz-temporal-dead-zone-for-parameters\">lever une erreur</a>.</p>\n<p>Néanmoins, les règles de portée font que ce programme est également invalide :</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> x = <span class=\"hljs-number\">1</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">foo</span> (<span class=\"hljs-params\">x = x</span>) </span>{ <span class=\"hljs-comment\">// Le 'x' référencé ici est le paramètre</span>\n}</code></pre>\n<p>On est bien, dès l'évaluation des valeurs par défaut, dans le scope de la\nfonction, et dans ce scope <code>x</code> fait référence au paramètre (pas encore défini)\net pas à la variable du dessus.</p>\n<p><strong>ProTip:  ne réutilisez pas 3 fois le même nom de variable</strong>\n(ça pourra aussi aider à la compréhension).</p>\n<h2 id=\"décomposition\"><a href=\"#d%C3%A9composition\" class=\"phenomic-HeadingAnchor\">#</a>Décomposition</h2>\n<p>De la même manière que pour les paramètres de fonction, les affectations par\ndécomposition\n(<a href=\"/fr/articles/js/es2015/destructuring/\">destructuring</a>)\npeuvent bénéficier de valeurs par défaut.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> obj = {<span class=\"hljs-attr\">z</span>: <span class=\"hljs-number\">42</span>} \n<span class=\"hljs-keyword\">const</span> { x = <span class=\"hljs-number\">1</span>, y = x + <span class=\"hljs-number\">1</span>, z, w } = obj\nw <span class=\"hljs-comment\">// undefined</span>\nx <span class=\"hljs-comment\">// 1</span>\ny <span class=\"hljs-comment\">// 2</span>\nz <span class=\"hljs-comment\">// 42</span></code></pre>\n<p>Pour rappel, l'affectation de l'exemple précédent aurait été écrit de cette\nmanière en ES5 :</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">var</span> x = (obj.x === <span class=\"hljs-literal\">undefined</span>) ? <span class=\"hljs-number\">1</span> : obj.x \n<span class=\"hljs-keyword\">var</span> y = (obj.y === <span class=\"hljs-literal\">undefined</span>) ?  x + <span class=\"hljs-number\">1</span> : obj.y\n<span class=\"hljs-keyword\">var</span> z = obj.z\n<span class=\"hljs-keyword\">var</span> w = obj.w</code></pre>\n<h1 id=\"enjoy\"><a href=\"#enjoy\" class=\"phenomic-HeadingAnchor\">#</a>Enjoy!</h1>\n<p>Il n'y a <em>a priori</em> plus aucune raison de croiser un test sur <code>undefined</code> dans\nvotre code une fois passé à ES6.</p>\n<p>Un petit mot sur la compatibilité (à la date de cet article) : seul Firefox ≥ 43\nimplémente les valeurs par défaut, et encore seulement pour les paramètres de\nfonctions.\nIl faudra donc utiliser <a href=\"http://babeljs.io\">Babel</a> ou Traceur pour en profiter.</p>\n","rawBody":"\nFatigués de taper ``if (typeof x === 'undefined') x = defaultValue`` ? Là encore\nES6 va nous apporter une solution élégante.\n\n# Valeurs par défaut\n\nL'opérateur ``=`` permet maintenant en plus d'affecter une valeur à une variable\nde définir une valeur par défaut à un paramètre.\n\n## Paramètres de fonction\n\nIl est maintenant possible de spécifier une valeur par défaut à un paramètre de\nfonction. Cette valeur sera utilisée si le paramètre n'est pas fourni, ou qu'il\nest explicitement défini à *undefined*.\n\n```js\nfunction incr (value, step = 1) {\n  return value + step\n}\n\nincr(41) // 42\nincr(41, undefined) // 42\nincr(33, 9) // 42\n```\n\n### Valeurs par défaut dynamiques\n\nOn peut spécifier une expression en tant que valeur par défaut. Cette expression\nsera évaluée **à l'appel de la fonction**, pas lors de sa déclaration.\n\n```js\nlet defaultWho = 'world!'\nfunction hello (who = defaultWho.toUpperCase()) {\n  return 'Hello ' + who\n}\n\nhello() // 'Hello WORLD!'\ndefaultWho = 'Anyone?'\nhello() // 'Hello ANYONE?'\n```\n\n### Réutilisation des paramètres précédents\n\nDans l'expression d'une valeur par défaut, on peut réutiliser les paramètres\n**précédents** de la fonction :\n\n```js\nfunction foo (x = 1, y = x + 1) {\n  return x + y\n}\n\nfunction bar (x = y + 1, y = 1) {\n  return x + y\n}\n\nfoo() // 1 + (1 + 1) → 3\nbar() // (undefined + 1) + 1 → NaN\n```\n\n### Cas particulier : TDZ (Temporal Dead Zone)\n\nUne *temporal dead zone* désigne une zone du programme où une variable \"existe\"\nmais n'est pas encore accessible tant qu'elle n'a pas reçu de valeur.\n\nL'exemple suivant semble très logiquement invalide :\n\n```js\nfunction foo (x = x) { // throws ReferenceError?\n}\n```\n\nEn effet, au moment de l'appel à la fonction, ``x`` n'a pas encore été défini,\net ne peut donc être utilisé comme valeur par défaut. Il semble que cet exemple\ndevrait [lever une erreur](http://dmitrysoshnikov.com/ecmascript/es6-notes-default-values-of-parameters/#tdz-temporal-dead-zone-for-parameters).\n\nNéanmoins, les règles de portée font que ce programme est également invalide :\n\n```js\nconst x = 1\nfunction foo (x = x) { // Le 'x' référencé ici est le paramètre\n}\n```\n\nOn est bien, dès l'évaluation des valeurs par défaut, dans le scope de la\nfonction, et dans ce scope ``x`` fait référence au paramètre (pas encore défini)\net pas à la variable du dessus.\n\n**ProTip:  ne réutilisez pas 3 fois le même nom de variable**\n(ça pourra aussi aider à la compréhension).\n\n## Décomposition\n\nDe la même manière que pour les paramètres de fonction, les affectations par\ndécomposition\n([destructuring](/fr/articles/js/es2015/destructuring/))\npeuvent bénéficier de valeurs par défaut.\n\n```js\nconst obj = {z: 42} \nconst { x = 1, y = x + 1, z, w } = obj\nw // undefined\nx // 1\ny // 2\nz // 42\n```\n\nPour rappel, l'affectation de l'exemple précédent aurait été écrit de cette\nmanière en ES5 :\n\n```js\nvar x = (obj.x === undefined) ? 1 : obj.x \nvar y = (obj.y === undefined) ?  x + 1 : obj.y\nvar z = obj.z\nvar w = obj.w\n```\n\n# Enjoy!\n\nIl n'y a *a priori* plus aucune raison de croiser un test sur ``undefined`` dans\nvotre code une fois passé à ES6.\n\nUn petit mot sur la compatibilité (à la date de cet article) : seul Firefox ≥ 43\nimplémente les valeurs par défaut, et encore seulement pour les paramètres de\nfonctions.\nIl faudra donc utiliser [Babel](http://babeljs.io) ou Traceur pour en profiter.\n","__filename":"fr/articles/js/es2015/defaults.md","__url":"/fr/articles/js/es2015/defaults/","__resourceUrl":"/fr/articles/js/es2015/defaults/index.html","__dataUrl":"/fr/articles/js/es2015/defaults/index.html.c3c50ea5b73e9da9bf8e65f86682cc19.json"}