{"head":{"layout":"Post","comments":true,"date":"2015-12-06","title":"ES6, ES2015 : les promesses","tags":["JavaScript","ES6","ES2015","Promise"],"authors":["Uhsac"],"description":"ES2015 apporte une fonctionnalité simplifiant grandement l'asynchrone en JavaScript, les promesses ! Visible depuis longtemps dans…"},"body":"<p>ES2015 apporte une fonctionnalité simplifiant grandement l'asynchrone en\nJavaScript, les promesses ! Visible depuis longtemps dans l'écosystème\nJavaScript grâce a diverses librairies, on peut maintenant utiliser directement\nla spécification officielle.</p>\n<h2 id=\"cest-quoi-une-promesse-\"><a href=\"#cest-quoi-une-promesse-\" class=\"phenomic-HeadingAnchor\">#</a>C'est quoi une promesse ?</h2>\n<p>Et bien comme son nom l'indique vous pouvez voir ça comme la promesse que vous\nallez recevoir une valeur. Comme toute promesse, elle peut être tenue,\nla valeur est arrivée et on peut s'en servir, ou ne pas l'être, dans ce cas\nune erreur arrive et on peut réagir en conséquence.</p>\n<p>Ce mécanisme permet de remplacer les callbacks d'une manière plus élégante. Au\nrevoir, la suite de callbacks qui rend votre code illisible ! Vous ne me croyez\npas ? Voici un exemple pour vous le prouver :</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// En utilisant les callbacks</span>\n<span class=\"hljs-comment\">// Imaginez que chacune de ces fonctions effectue des tâches asynchrones</span>\n<span class=\"hljs-comment\">// plus ou moins complexes (requête HTTP, appel à une base de données</span>\n<span class=\"hljs-comment\">// ou encore lecture de fichier)</span>\n<span class=\"hljs-keyword\">const</span> functionWithCallback1 = <span class=\"hljs-function\">(<span class=\"hljs-params\">callback</span>) =></span> callback(<span class=\"hljs-string\">'test'</span>, <span class=\"hljs-literal\">undefined</span>)\n<span class=\"hljs-keyword\">const</span> functionWithCallback2 = <span class=\"hljs-function\">(<span class=\"hljs-params\">arg, callback</span>) =></span> callback(arg, <span class=\"hljs-literal\">undefined</span>)\n<span class=\"hljs-keyword\">const</span> functionWithCallback3 = <span class=\"hljs-function\">(<span class=\"hljs-params\">arg, callback</span>) =></span> callback(arg, <span class=\"hljs-literal\">undefined</span>)\n<span class=\"hljs-keyword\">const</span> functionWithCallback4 = <span class=\"hljs-function\">(<span class=\"hljs-params\">arg, callback</span>) =></span> callback(arg, <span class=\"hljs-literal\">undefined</span>)\n<span class=\"hljs-keyword\">const</span> functionWithCallback5 = <span class=\"hljs-function\">(<span class=\"hljs-params\">arg, callback</span>) =></span> callback(arg, <span class=\"hljs-literal\">undefined</span>)\n<span class=\"hljs-keyword\">const</span> functionWithCallback6 = <span class=\"hljs-function\">(<span class=\"hljs-params\">arg, callback</span>) =></span> callback(arg, <span class=\"hljs-literal\">undefined</span>)\n\nfunctionWithCallback1(<span class=\"hljs-function\">(<span class=\"hljs-params\">result1, err</span>) =></span> {\n  <span class=\"hljs-keyword\">if</span> (err) {\n    <span class=\"hljs-keyword\">throw</span> err\n  }\n  functionWithCallback2(result1, (result2, err) => {\n    <span class=\"hljs-keyword\">if</span> (err) {\n      <span class=\"hljs-keyword\">throw</span> err\n    }\n    functionWithCallback3(result2, (result3, err) => {\n      <span class=\"hljs-keyword\">if</span> (err) {\n        <span class=\"hljs-keyword\">throw</span> err\n      }\n      functionWithCallback4(result3, (result4, err) => {\n        <span class=\"hljs-keyword\">if</span> (err) {\n          <span class=\"hljs-keyword\">throw</span> err\n        }\n        functionWithCallback5(result4, (result5, err) => {\n          <span class=\"hljs-keyword\">if</span> (err) {\n            <span class=\"hljs-keyword\">throw</span> err\n          }\n          functionWithCallback6(result5, (result6, err) => {\n            <span class=\"hljs-keyword\">if</span> (err) {\n              <span class=\"hljs-keyword\">throw</span> err\n            }\n            <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">`Exemple avec les callback : <span class=\"hljs-subst\">${result6}</span>`</span>)\n          })\n        })\n      })\n    })\n  })\n})\n\n<span class=\"hljs-comment\">// Et maintenant, en utilisant les promesses</span>\n<span class=\"hljs-keyword\">const</span> functionWithPromise1 = <span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =></span> <span class=\"hljs-built_in\">Promise</span>.resolve(<span class=\"hljs-string\">'test'</span>)\n<span class=\"hljs-keyword\">const</span> functionWithPromise2 = <span class=\"hljs-function\">(<span class=\"hljs-params\">arg</span>) =></span> <span class=\"hljs-built_in\">Promise</span>.resolve(arg)\n<span class=\"hljs-keyword\">const</span> functionWithPromise3 = <span class=\"hljs-function\">(<span class=\"hljs-params\">arg</span>) =></span> <span class=\"hljs-built_in\">Promise</span>.resolve(arg)\n<span class=\"hljs-keyword\">const</span> functionWithPromise4 = <span class=\"hljs-function\">(<span class=\"hljs-params\">arg</span>) =></span> <span class=\"hljs-built_in\">Promise</span>.resolve(arg)\n<span class=\"hljs-keyword\">const</span> functionWithPromise5 = <span class=\"hljs-function\">(<span class=\"hljs-params\">arg</span>) =></span> <span class=\"hljs-built_in\">Promise</span>.resolve(arg)\n<span class=\"hljs-keyword\">const</span> functionWithPromise6 = <span class=\"hljs-function\">(<span class=\"hljs-params\">arg</span>) =></span> <span class=\"hljs-built_in\">Promise</span>.resolve(arg)\n\nfunctionWithPromise1()\n  .then(functionWithPromise2)\n  .then(functionWithPromise3)\n  .then(functionWithPromise4)\n  .then(functionWithPromise5)\n  .then(functionWithPromise6)\n  .then(<span class=\"hljs-function\"><span class=\"hljs-params\">result</span> =></span> <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">`Exemple avec les promesses : <span class=\"hljs-subst\">${result}</span>`</span>))\n  .catch(<span class=\"hljs-function\"><span class=\"hljs-params\">err</span> =></span> {\n    <span class=\"hljs-keyword\">throw</span> err\n  })</code></pre>\n<p>Comme vous pouvez le voir, l'exemple avec les promesses est tout de même plus\nlisible !</p>\n<h2 id=\"trop-bien--comment-je-les-utilise-\"><a href=\"#trop-bien--comment-je-les-utilise-\" class=\"phenomic-HeadingAnchor\">#</a>Trop bien ! Comment je les utilise ?</h2>\n<p>Une promesse peut avoir plusieurs états au cours de son existence :</p>\n<ul>\n<li>en cours : la valeur qu'elle contient n'est pas encore arrivée</li>\n<li>résolue : la valeur est arrivée, on peut l'utiliser</li>\n<li>rejetée : une erreur est survenue, on peut y réagir</li>\n</ul>\n<p>Une promesse possède 2 fonctions : <code>then</code> et <code>catch</code>, vous pouvez utiliser\n<code>then</code> pour récupérer le resultat ou l'erreur d'une promesse et <code>catch</code> pour\nrécupérer l'erreur d'une ou plusieurs promesses.</p>\n<p>Voyons comment utiliser les promesses à l'aide de la future implémentation de\n<a href=\"https://fetch.spec.whatwg.org\"><code>fetch</code></a>.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// À ce moment, la promesse est en attente</span>\n<span class=\"hljs-keyword\">const</span> fetchPromise = fetch(<span class=\"hljs-string\">'http://putaindecode.io'</span>)\n\n<span class=\"hljs-comment\">// Quand la requête est terminée la promesse est résolue avec le résultat de</span>\n<span class=\"hljs-comment\">// la requête</span>\n<span class=\"hljs-keyword\">const</span> parsePromise = fetchPromise.then(<span class=\"hljs-function\"><span class=\"hljs-params\">fetchResult</span> =></span> {\n  <span class=\"hljs-comment\">// Je peux retourner une nouvelle promesse à partir d'un then, ici</span>\n  <span class=\"hljs-comment\">// j'appelle .text() qui parse le contenu de la requête et retourne</span>\n  <span class=\"hljs-comment\">// une promesse</span>\n  <span class=\"hljs-keyword\">return</span> fetchResult.text()\n})\n\n<span class=\"hljs-comment\">// Quand le parsing est terminé, je peux recuperer son contenu</span>\nparsePromise.then(<span class=\"hljs-function\"><span class=\"hljs-params\">textResult</span> =></span> {\n  <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">`Voici le résultat : <span class=\"hljs-subst\">${textResult}</span>`</span>)\n})\n\n<span class=\"hljs-comment\">// Si la requête a un problème, la promesse est rejetée avec une erreur</span>\nfetchPromise.catch(<span class=\"hljs-function\"><span class=\"hljs-params\">fetchError</span> =></span> {\n  <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">\"Une erreur a eu lieu pendant la requête\"</span>, fetchError)\n})\n\n<span class=\"hljs-comment\">// S'il y a une erreur pendant le parsing, je peux la récupérer</span>\nparsePromise.catch(<span class=\"hljs-function\"><span class=\"hljs-params\">parseError</span> =></span> {\n  <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">\"Une erreur a eu lieu pendant le parsing\"</span>, parseError)\n})\n\n<span class=\"hljs-comment\">// Cela peut aussi être écrit</span>\nfetch(<span class=\"hljs-string\">'http://putaindecode.io'</span>)\n  .then(<span class=\"hljs-function\"><span class=\"hljs-params\">fetchResult</span> =></span> fetchResult.text())\n  .then(<span class=\"hljs-function\"><span class=\"hljs-params\">textResult</span> =></span> {\n    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">`Voici le résultat : <span class=\"hljs-subst\">${textResult}</span>`</span>)\n  })\n  .catch(<span class=\"hljs-function\"><span class=\"hljs-params\">error</span> =></span> {\n    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">\"Une erreur a eu lieu pendant la requête ou le parsing\"</span>, fetchError)\n  })\n\n<span class=\"hljs-comment\">// Ou encore</span>\nfetch(<span class=\"hljs-string\">'http://putaindecode.io'</span>)\n  .then(\n    <span class=\"hljs-function\"><span class=\"hljs-params\">fetchResult</span> =></span> {\n      <span class=\"hljs-keyword\">return</span> fetchResult.text()\n    },\n    fetchError => {\n      <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">\"Une erreur a eu lieu pendant la requête\"</span>, fetchError)\n    }\n  )\n  .then(\n    <span class=\"hljs-function\"><span class=\"hljs-params\">textResult</span> =></span> {\n      <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">`Voici le résultat : <span class=\"hljs-subst\">${textResult}</span>`</span>)\n    },\n    parseError => {\n      <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">\"Une erreur a eu lieu pendant le parsing\"</span>, parseError)\n    }\n  )</code></pre>\n<h2 id=\"mais-comment-je-crée-mes-propres-promesses-\"><a href=\"#mais-comment-je-cr%C3%A9e-mes-propres-promesses-\" class=\"phenomic-HeadingAnchor\">#</a>Mais comment je crée mes propres promesses ?</h2>\n<p>C'est bien beau d'utiliser les promesses, mais c'est encore mieux de savoir\ncréer les vôtres ! Je vous rassure, c'est très simple.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> functionThatReturnAPromise = <span class=\"hljs-function\">(<span class=\"hljs-params\">success</span>) =></span> {\n  <span class=\"hljs-comment\">// On utilise la classe Promise pour en créer une, le constructeur prend 2</span>\n  <span class=\"hljs-comment\">// fonctions en paramètre :</span>\n  <span class=\"hljs-comment\">// - resolve que l'on pourra appeler avec le résultat de notre fonction</span>\n  <span class=\"hljs-comment\">// - reject que l'on pourra appeler avec une erreur s'il y a une erreur</span>\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Promise</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">resolve, reject</span>) =></span> {\n    <span class=\"hljs-keyword\">if</span> (success) {\n      resolve(<span class=\"hljs-string\">'success'</span>)\n    }\n    <span class=\"hljs-keyword\">else</span> {\n      reject(<span class=\"hljs-string\">'failed'</span>)\n    }\n  })\n}\n\n<span class=\"hljs-comment\">// Vous pouvez maintenant utiliser votre fonction comme vu précédemment</span>\nfunctionThatReturnAPromise(success)\n  .then(<span class=\"hljs-function\"><span class=\"hljs-params\">res</span> =></span> <span class=\"hljs-built_in\">console</span>.log(res))\n  .catch(<span class=\"hljs-function\"><span class=\"hljs-params\">error</span> =></span> <span class=\"hljs-built_in\">console</span>.log(error))\n\n<span class=\"hljs-comment\">// équivalent dans notre cas à</span>\nfunctionThatReturnAPromise(success)\n  .then(\n    <span class=\"hljs-function\">(<span class=\"hljs-params\">res</span>) =></span> <span class=\"hljs-built_in\">console</span>.log(res),\n    (error) => <span class=\"hljs-built_in\">console</span>.log(error)\n  )</code></pre>\n<h2 id=\"et-demain-\"><a href=\"#et-demain-\" class=\"phenomic-HeadingAnchor\">#</a>Et demain ?</h2>\n<p>Une fonctionnalité encore plus pratique que les promesses arrive en JavaScript,\nles mots-clés <code>async</code> et <code>await</code> ! Ces mots-clés vous permettront d'avoir un\ncode encore plus lisible quand vous ferez de l'asynchrone, mais ça ne concerne\npas ES2015 :)</p>\n","rawBody":"\nES2015 apporte une fonctionnalité simplifiant grandement l'asynchrone en\nJavaScript, les promesses ! Visible depuis longtemps dans l'écosystème\nJavaScript grâce a diverses librairies, on peut maintenant utiliser directement\nla spécification officielle.\n\n## C'est quoi une promesse ?\n\nEt bien comme son nom l'indique vous pouvez voir ça comme la promesse que vous\nallez recevoir une valeur. Comme toute promesse, elle peut être tenue,\nla valeur est arrivée et on peut s'en servir, ou ne pas l'être, dans ce cas\nune erreur arrive et on peut réagir en conséquence.\n\nCe mécanisme permet de remplacer les callbacks d'une manière plus élégante. Au\nrevoir, la suite de callbacks qui rend votre code illisible ! Vous ne me croyez\npas ? Voici un exemple pour vous le prouver :\n\n```js\n// En utilisant les callbacks\n// Imaginez que chacune de ces fonctions effectue des tâches asynchrones\n// plus ou moins complexes (requête HTTP, appel à une base de données\n// ou encore lecture de fichier)\nconst functionWithCallback1 = (callback) => callback('test', undefined)\nconst functionWithCallback2 = (arg, callback) => callback(arg, undefined)\nconst functionWithCallback3 = (arg, callback) => callback(arg, undefined)\nconst functionWithCallback4 = (arg, callback) => callback(arg, undefined)\nconst functionWithCallback5 = (arg, callback) => callback(arg, undefined)\nconst functionWithCallback6 = (arg, callback) => callback(arg, undefined)\n\nfunctionWithCallback1((result1, err) => {\n  if (err) {\n    throw err\n  }\n  functionWithCallback2(result1, (result2, err) => {\n    if (err) {\n      throw err\n    }\n    functionWithCallback3(result2, (result3, err) => {\n      if (err) {\n        throw err\n      }\n      functionWithCallback4(result3, (result4, err) => {\n        if (err) {\n          throw err\n        }\n        functionWithCallback5(result4, (result5, err) => {\n          if (err) {\n            throw err\n          }\n          functionWithCallback6(result5, (result6, err) => {\n            if (err) {\n              throw err\n            }\n            console.log(`Exemple avec les callback : ${result6}`)\n          })\n        })\n      })\n    })\n  })\n})\n\n// Et maintenant, en utilisant les promesses\nconst functionWithPromise1 = () => Promise.resolve('test')\nconst functionWithPromise2 = (arg) => Promise.resolve(arg)\nconst functionWithPromise3 = (arg) => Promise.resolve(arg)\nconst functionWithPromise4 = (arg) => Promise.resolve(arg)\nconst functionWithPromise5 = (arg) => Promise.resolve(arg)\nconst functionWithPromise6 = (arg) => Promise.resolve(arg)\n\nfunctionWithPromise1()\n  .then(functionWithPromise2)\n  .then(functionWithPromise3)\n  .then(functionWithPromise4)\n  .then(functionWithPromise5)\n  .then(functionWithPromise6)\n  .then(result => console.log(`Exemple avec les promesses : ${result}`))\n  .catch(err => {\n    throw err\n  })\n```\n\nComme vous pouvez le voir, l'exemple avec les promesses est tout de même plus\nlisible !\n\n## Trop bien ! Comment je les utilise ?\n\nUne promesse peut avoir plusieurs états au cours de son existence :\n- en cours : la valeur qu'elle contient n'est pas encore arrivée\n- résolue : la valeur est arrivée, on peut l'utiliser\n- rejetée : une erreur est survenue, on peut y réagir\n\nUne promesse possède 2 fonctions : `then` et `catch`, vous pouvez utiliser\n`then` pour récupérer le resultat ou l'erreur d'une promesse et `catch` pour\nrécupérer l'erreur d'une ou plusieurs promesses.\n\nVoyons comment utiliser les promesses à l'aide de la future implémentation de\n[`fetch`](https://fetch.spec.whatwg.org).\n\n```js\n// À ce moment, la promesse est en attente\nconst fetchPromise = fetch('http://putaindecode.io')\n\n// Quand la requête est terminée la promesse est résolue avec le résultat de\n// la requête\nconst parsePromise = fetchPromise.then(fetchResult => {\n  // Je peux retourner une nouvelle promesse à partir d'un then, ici\n  // j'appelle .text() qui parse le contenu de la requête et retourne\n  // une promesse\n  return fetchResult.text()\n})\n\n// Quand le parsing est terminé, je peux recuperer son contenu\nparsePromise.then(textResult => {\n  console.log(`Voici le résultat : ${textResult}`)\n})\n\n// Si la requête a un problème, la promesse est rejetée avec une erreur\nfetchPromise.catch(fetchError => {\n  console.log(\"Une erreur a eu lieu pendant la requête\", fetchError)\n})\n\n// S'il y a une erreur pendant le parsing, je peux la récupérer\nparsePromise.catch(parseError => {\n  console.log(\"Une erreur a eu lieu pendant le parsing\", parseError)\n})\n\n// Cela peut aussi être écrit\nfetch('http://putaindecode.io')\n  .then(fetchResult => fetchResult.text())\n  .then(textResult => {\n    console.log(`Voici le résultat : ${textResult}`)\n  })\n  .catch(error => {\n    console.log(\"Une erreur a eu lieu pendant la requête ou le parsing\", fetchError)\n  })\n\n// Ou encore\nfetch('http://putaindecode.io')\n  .then(\n    fetchResult => {\n      return fetchResult.text()\n    },\n    fetchError => {\n      console.log(\"Une erreur a eu lieu pendant la requête\", fetchError)\n    }\n  )\n  .then(\n    textResult => {\n      console.log(`Voici le résultat : ${textResult}`)\n    },\n    parseError => {\n      console.log(\"Une erreur a eu lieu pendant le parsing\", parseError)\n    }\n  )\n```\n\n## Mais comment je crée mes propres promesses ?\n\nC'est bien beau d'utiliser les promesses, mais c'est encore mieux de savoir\ncréer les vôtres ! Je vous rassure, c'est très simple.\n\n```js\nconst functionThatReturnAPromise = (success) => {\n  // On utilise la classe Promise pour en créer une, le constructeur prend 2\n  // fonctions en paramètre :\n  // - resolve que l'on pourra appeler avec le résultat de notre fonction\n  // - reject que l'on pourra appeler avec une erreur s'il y a une erreur\n  return new Promise((resolve, reject) => {\n    if (success) {\n      resolve('success')\n    }\n    else {\n      reject('failed')\n    }\n  })\n}\n\n// Vous pouvez maintenant utiliser votre fonction comme vu précédemment\nfunctionThatReturnAPromise(success)\n  .then(res => console.log(res))\n  .catch(error => console.log(error))\n\n// équivalent dans notre cas à\nfunctionThatReturnAPromise(success)\n  .then(\n    (res) => console.log(res),\n    (error) => console.log(error)\n  )\n```\n\n## Et demain ?\n\nUne fonctionnalité encore plus pratique que les promesses arrive en JavaScript,\nles mots-clés `async` et `await` ! Ces mots-clés vous permettront d'avoir un\ncode encore plus lisible quand vous ferez de l'asynchrone, mais ça ne concerne\npas ES2015 :)\n","__filename":"fr/articles/js/es2015/promises.md","__url":"/fr/articles/js/es2015/promises/","__resourceUrl":"/fr/articles/js/es2015/promises/index.html","__dataUrl":"/fr/articles/js/es2015/promises/index.html.8153c56831e26564536412146985d1e0.json"}