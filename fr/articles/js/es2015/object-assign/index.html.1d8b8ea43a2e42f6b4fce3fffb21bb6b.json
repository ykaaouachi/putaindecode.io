{"head":{"layout":"Post","comments":true,"date":"2015-12-04","title":"ES6, ES2015 : Object.assign","tags":["javascript","ES6","ES2015"],"authors":["naholyr"],"description":"Vous connaissez les méthodes extend d'underscore ou lodash (mais plutôt lodash quand même) ? Comme la plupart de ces fonctions utilitaires,…"},"body":"<p>Vous connaissez les méthodes <code>extend</code> d'underscore ou lodash (mais plutôt\nlodash quand même) ? Comme la plupart de ces fonctions utilitaires, elles sont\nrendues obsolètes par une fonctionnalité d'ES6 (aka ES2015).</p>\n<h1 id=\"objectassign\"><a href=\"#objectassign\" class=\"phenomic-HeadingAnchor\">#</a>Object.assign</h1>\n<p>La nouvelle méthode statique <code>Object.assign</code> prend en paramètres une série\nd'objets :</p>\n<ul>\n<li>le premier objet est la \"cible\" des copies ;</li>\n<li>les suivants sont les sources ;</li>\n<li>toutes les clés propres (<em>own properties</em>, soit les clés énumérables et non\nhéritées, même celles dont la valeur est <code>undefined</code>) des sources sont\ncopiées vers la cible (les suivantes écrasant les précédentes) ;</li>\n<li><strong>l'objet cible est donc modifié</strong> (il doit être mutable) ;</li>\n<li>puis on retourne l'objet cible.</li>\n</ul>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> o = { <span class=\"hljs-attr\">y</span>: <span class=\"hljs-number\">0</span> }\n<span class=\"hljs-keyword\">const</span> o1 = { <span class=\"hljs-attr\">x</span>: <span class=\"hljs-number\">1</span>, <span class=\"hljs-attr\">y</span>: <span class=\"hljs-number\">2</span> }\n<span class=\"hljs-keyword\">const</span> o2 = { <span class=\"hljs-attr\">x</span>: <span class=\"hljs-literal\">undefined</span>, <span class=\"hljs-attr\">z</span>: <span class=\"hljs-number\">3</span> }\n<span class=\"hljs-built_in\">Object</span>.assign(o, o1, o2) <span class=\"hljs-comment\">// { x: undefined, y: 2, z: 3 }</span>\no <span class=\"hljs-comment\">// { x: undefined, y: 2, z: 3 }</span>\no1 <span class=\"hljs-comment\">// non modifié</span>\no2 <span class=\"hljs-comment\">// non modifié</span></code></pre>\n<h2 id=\"attention-à-la-mutabilité\"><a href=\"#attention-%C3%A0-la-mutabilit%C3%A9\" class=\"phenomic-HeadingAnchor\">#</a>Attention à la mutabilité</h2>\n<p>Prenez garde au fait que la source est systématiquement modifiée. Le <em>use-case</em>\ngénéral étant plutôt la création d'un nouvel objet résultant de la fusion des\nsources, on passera habituellement un nouvel objet en premier paramètre.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> o1 = { <span class=\"hljs-attr\">x</span>: <span class=\"hljs-number\">1</span> }\n<span class=\"hljs-keyword\">const</span> o2 = { <span class=\"hljs-attr\">y</span>: <span class=\"hljs-number\">2</span> }\n<span class=\"hljs-keyword\">const</span> o = <span class=\"hljs-built_in\">Object</span>.assign({}, o1, o2)\no <span class=\"hljs-comment\">// { x: 1, y: 2 }</span>\n<span class=\"hljs-comment\">// o1 et o2 n'ont pas été modifiés</span></code></pre>\n<h2 id=\"cas-particuliers\"><a href=\"#cas-particuliers\" class=\"phenomic-HeadingAnchor\">#</a>Cas particuliers</h2>\n<h3 id=\"erreurs-lors-de-la-copie\"><a href=\"#erreurs-lors-de-la-copie\" class=\"phenomic-HeadingAnchor\">#</a>Erreurs lors de la copie</h3>\n<p>Si une propriété de la cible est en lecture seule, <code>Object.assign</code> devrait se\ncomporter comme en mode <em>strict</em> (par opposition au mode <em>WTF</em>), et lever\nl'erreur correspondante avant d'interrompre la copie.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> o = <span class=\"hljs-built_in\">Object</span>.create({}, {\n  <span class=\"hljs-attr\">val</span>: { <span class=\"hljs-attr\">value</span>: <span class=\"hljs-number\">42</span>, <span class=\"hljs-attr\">enumerable</span>: <span class=\"hljs-literal\">true</span>, <span class=\"hljs-attr\">writable</span>: <span class=\"hljs-literal\">false</span> }\n})\n\n<span class=\"hljs-comment\">// En mode \"standard\":</span>\no.val = <span class=\"hljs-number\">0</span> <span class=\"hljs-comment\">// pas d'erreur</span>\no.val <span class=\"hljs-comment\">// 42 (valeur non modifiée)</span>\n<span class=\"hljs-built_in\">Object</span>.assign(o, { <span class=\"hljs-attr\">x</span>: <span class=\"hljs-number\">1</span>, <span class=\"hljs-attr\">val</span>: <span class=\"hljs-number\">0</span>, <span class=\"hljs-attr\">y</span>: <span class=\"hljs-number\">2</span> }) <span class=\"hljs-comment\">// Uncaught TypeError: Cannot assign…</span>\no <span class=\"hljs-comment\">// { val: 42, x: 1 }</span>\n\n<span class=\"hljs-comment\">// En mode \"strict\":</span>\no.val = <span class=\"hljs-number\">0</span> <span class=\"hljs-comment\">// Uncaught TypeError: Cannot assign…</span>\n<span class=\"hljs-built_in\">Object</span>.assign(o, { <span class=\"hljs-attr\">x</span>: <span class=\"hljs-number\">1</span>, <span class=\"hljs-attr\">val</span>: <span class=\"hljs-number\">0</span>, <span class=\"hljs-attr\">y</span>: <span class=\"hljs-number\">2</span> }) <span class=\"hljs-comment\">// Uncaught TypeError: Cannot assign…</span>\no <span class=\"hljs-comment\">// { val: 42, x: 1 }</span></code></pre>\n<p>Les clés déjà copiées avant la levée d'erreur sont conservées dans la cible,\nainsi dans notre exemple <code>x</code> a été copiée mais pas <code>y</code>.</p>\n<p>Note : ça c'est la théorie, lors de mes tests ce comportement a été le plus\nvariable, en fonction de la plate-forme et du contexte, l'erreur n'est pas\ntoujours levée. Le mieux est de travailler en mode <em>strict</em> pour s'assurer d'un\ncomportement prédictible.</p>\n<h3 id=\"sources-scalaires\"><a href=\"#sources-scalaires\" class=\"phenomic-HeadingAnchor\">#</a>Sources scalaires</h3>\n<p>Lorsque les sources sont des valeurs scalaires (nombre, booléen, etc.)\n<code>Object.keys</code> ne listera généralement aucune clé et ces valeurs seront donc\nignorées. Les valeurs <code>null</code> et <code>undefined</code> également.</p>\n<p>Cas particulier : les chaînes de caractères sont traitées comme des tableaux.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> o = {}\n<span class=\"hljs-built_in\">Object</span>.assign(o, <span class=\"hljs-number\">1</span>, <span class=\"hljs-literal\">true</span>, <span class=\"hljs-literal\">null</span>, <span class=\"hljs-string\">\"toto\"</span>, [<span class=\"hljs-string\">\"b\"</span>, <span class=\"hljs-string\">\"a\"</span>], <span class=\"hljs-literal\">undefined</span>)\n<span class=\"hljs-comment\">// 1, true, null, undefined sont ignorées</span>\n<span class=\"hljs-comment\">// \"toto\" est converti en {0: \"t\", 1: \"o\", 2: \"t\", 3: \"o\"}</span>\n<span class=\"hljs-comment\">// [\"b\", \"a\"] est converti en {0: \"b\", 1: \"a\"}</span>\no <span class=\"hljs-comment\">// {0: \"b\", 1: \"a\", 2: \"t\", 3: \"o\"}</span></code></pre>\n<h2 id=\"conclusion\"><a href=\"#conclusion\" class=\"phenomic-HeadingAnchor\">#</a>Conclusion</h2>\n<p>Plus besoin de <code>_.clone</code>, <code>_.extend</code>, etc. avec cette méthode :)</p>\n<p>Pour finir, le topo compatibilité : <code>Object.assign</code> est plutôt bien supportée\npar les navigateurs modernes (donc pas IE) :</p>\n<ul>\n<li>Edge (IE ≥ 12) ;</li>\n<li>Chrome stable (46) ;</li>\n<li>Firefox stable (42) ;</li>\n<li>Node ≥ 4 ;</li>\n<li>et si vous devez supporter IE, il y a bien sûr <a href=\"http://babeljs.io/\">Babel</a>\nou les nombreuses implémentations utilisateur.</li>\n</ul>\n","rawBody":"\nVous connaissez les méthodes ``extend`` d'underscore ou lodash (mais plutôt\nlodash quand même) ? Comme la plupart de ces fonctions utilitaires, elles sont\nrendues obsolètes par une fonctionnalité d'ES6 (aka ES2015).\n\n# Object.assign\n\nLa nouvelle méthode statique ``Object.assign`` prend en paramètres une série\nd'objets :\n\n* le premier objet est la \"cible\" des copies ;\n* les suivants sont les sources ;\n* toutes les clés propres (*own properties*, soit les clés énumérables et non\n  héritées, même celles dont la valeur est ``undefined``) des sources sont\n  copiées vers la cible (les suivantes écrasant les précédentes) ;\n* **l'objet cible est donc modifié** (il doit être mutable) ;\n* puis on retourne l'objet cible.\n\n```js\nconst o = { y: 0 }\nconst o1 = { x: 1, y: 2 }\nconst o2 = { x: undefined, z: 3 }\nObject.assign(o, o1, o2) // { x: undefined, y: 2, z: 3 }\no // { x: undefined, y: 2, z: 3 }\no1 // non modifié\no2 // non modifié\n```\n\n## Attention à la mutabilité\n\nPrenez garde au fait que la source est systématiquement modifiée. Le *use-case*\ngénéral étant plutôt la création d'un nouvel objet résultant de la fusion des\nsources, on passera habituellement un nouvel objet en premier paramètre.\n\n```js\nconst o1 = { x: 1 }\nconst o2 = { y: 2 }\nconst o = Object.assign({}, o1, o2)\no // { x: 1, y: 2 }\n// o1 et o2 n'ont pas été modifiés\n```\n\n## Cas particuliers\n\n### Erreurs lors de la copie\n\nSi une propriété de la cible est en lecture seule, ``Object.assign`` devrait se\ncomporter comme en mode *strict* (par opposition au mode *WTF*), et lever\nl'erreur correspondante avant d'interrompre la copie.\n\n```js\nconst o = Object.create({}, {\n  val: { value: 42, enumerable: true, writable: false }\n})\n\n// En mode \"standard\":\no.val = 0 // pas d'erreur\no.val // 42 (valeur non modifiée)\nObject.assign(o, { x: 1, val: 0, y: 2 }) // Uncaught TypeError: Cannot assign…\no // { val: 42, x: 1 }\n\n// En mode \"strict\":\no.val = 0 // Uncaught TypeError: Cannot assign…\nObject.assign(o, { x: 1, val: 0, y: 2 }) // Uncaught TypeError: Cannot assign…\no // { val: 42, x: 1 }\n```\n\nLes clés déjà copiées avant la levée d'erreur sont conservées dans la cible,\nainsi dans notre exemple ``x`` a été copiée mais pas ``y``.\n\nNote : ça c'est la théorie, lors de mes tests ce comportement a été le plus\nvariable, en fonction de la plate-forme et du contexte, l'erreur n'est pas\ntoujours levée. Le mieux est de travailler en mode *strict* pour s'assurer d'un\ncomportement prédictible.\n\n### Sources scalaires\n\nLorsque les sources sont des valeurs scalaires (nombre, booléen, etc.)\n``Object.keys`` ne listera généralement aucune clé et ces valeurs seront donc\nignorées. Les valeurs ``null`` et ``undefined`` également.\n\nCas particulier : les chaînes de caractères sont traitées comme des tableaux.\n\n```js\nconst o = {}\nObject.assign(o, 1, true, null, \"toto\", [\"b\", \"a\"], undefined)\n// 1, true, null, undefined sont ignorées\n// \"toto\" est converti en {0: \"t\", 1: \"o\", 2: \"t\", 3: \"o\"}\n// [\"b\", \"a\"] est converti en {0: \"b\", 1: \"a\"}\no // {0: \"b\", 1: \"a\", 2: \"t\", 3: \"o\"}\n```\n\n## Conclusion\n\nPlus besoin de ``_.clone``, ``_.extend``, etc. avec cette méthode :)\n\nPour finir, le topo compatibilité : ``Object.assign`` est plutôt bien supportée\npar les navigateurs modernes (donc pas IE) :\n\n* Edge (IE ≥ 12) ;\n* Chrome stable (46) ;\n* Firefox stable (42) ;\n* Node ≥ 4 ;\n* et si vous devez supporter IE, il y a bien sûr [Babel](http://babeljs.io/)\n  ou les nombreuses implémentations utilisateur.\n","__filename":"fr/articles/js/es2015/object-assign.md","__url":"/fr/articles/js/es2015/object-assign/","__resourceUrl":"/fr/articles/js/es2015/object-assign/index.html","__dataUrl":"/fr/articles/js/es2015/object-assign/index.html.1d8b8ea43a2e42f6b4fce3fffb21bb6b.json"}