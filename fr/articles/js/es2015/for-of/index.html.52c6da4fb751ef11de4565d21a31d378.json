{"head":{"layout":"Post","comments":true,"date":"2015-12-16","title":"ES6, ES2015 : la boucle for..of","tags":["javascript","ES6","ES2015","for..of"],"authors":["Freezystem"],"description":"Introduction Avec l'arrivée de nouveaux objets itérables, ECMAScript avait la nécessité de s'enrichir de nouvelles façons de parcourir ces…"},"body":"<h2 id=\"introduction\"><a href=\"#introduction\" class=\"phenomic-HeadingAnchor\">#</a>Introduction</h2>\n<p>Avec l'arrivée de nouveaux objets itérables, ECMAScript avait la nécessité de\ns'enrichir de\nnouvelles façons de parcourir ces derniers. Dans l'unique souci de maintenir la\nrétro-compatibilité\navec l'existant, l'ES6 se devait de garder la boucle <code>for..in</code> intacte.</p>\n<blockquote>\n<p>Mais alors, comment créer une variante de cette même boucle avec des capacités\naméliorées ?  </p>\n</blockquote>\n<p>La solution est simple : \"Bienvenue au mot-clé <code>of</code> !\"</p>\n<p>Mais avant d'en dire plus, et pour comprendre l'utilité de ce nouveau mot-clé,\nrevoyons un peu l'existant.</p>\n<h2 id=\"le-bon-vieux-forin\"><a href=\"#le-bon-vieux-forin\" class=\"phenomic-HeadingAnchor\">#</a>Le bon vieux <code>for..in</code></h2>\n<p>Tout <em>JavaScript enthusiast</em> qui se respecte connaissait déjà la fameuse boucle\n<code>for..in</code>\ndont l'utilité première est d'itérer sur les différentes clés d'un objet ou d'un\ntableau.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> obj = { <span class=\"hljs-attr\">foo</span> : <span class=\"hljs-string\">'hello'</span>, <span class=\"hljs-attr\">bar</span> : <span class=\"hljs-string\">'world'</span> };\n\n<span class=\"hljs-keyword\">for</span> ( <span class=\"hljs-keyword\">const</span> key <span class=\"hljs-keyword\">in</span> obj ) {\n  <span class=\"hljs-built_in\">console</span>.log( key + <span class=\"hljs-string\">'->'</span> + obj[key] );  <span class=\"hljs-comment\">// 'foo->hello', 'bar->world'</span>\n}</code></pre>\n<p>La boucle <code>for..in</code>, malgré son apparente simplicité d'utilisation, cache\ncertains pièges :</p>\n<ul>\n<li>\n<p>Lors de l'itération sur un tableau la valeur de l'index est convertie en\nchaîne\nde caractères : \"0\", \"1\", \"2\", etc. Cela peut potentiellement poser problème\nlors de\nl'utilisation de l'index dans des opérations de calcul.</p>\n</li>\n<li>\n<p>La boucle itère sur l'ensemble des clés du tableau, mais aussi sur chacune de\nses propriétés.</p>\n<pre><code>```js\nconst arr = ['foo', 'bar'];\narr.oups = 'baz';\n\nfor ( const key in arr ) {\n  console.log( key + '->' + arr[key] ); // '0->foo', '1->bar', 'oups->baz'\n}\n```\n</code></pre>\n</li>\n<li>\n<p>L'ordre d'itération sur l'ensemble des clés d'un objet peut varier selon\nl'environnement d'éxecution du code.</p>\n</li>\n</ul>\n<h2 id=\"la-methode-alternative-foreach\"><a href=\"#la-methode-alternative-foreach\" class=\"phenomic-HeadingAnchor\">#</a>La methode alternative <code>.forEach()</code></h2>\n<p>La boucle\n<a href=\"https://developer.mozilla.org/fr/docs/Web/JavaScript/Reference/Objets_globaux/Array/forEach\"><code>Array.prototype.forEach()</code></a>\npermet une itération plus sécurisée, mais présente certains autres inconvénients\ntels que :</p>\n<ul>\n<li>L'impossibilité d'interrompre la boucle avec les instructions traditionnelles\n<code>break;</code> et <code>return;</code></li>\n<li>Il s'agit d'une méthode réservée aux tableaux.</li>\n</ul>\n<h2 id=\"forof-à-la-rescousse\"><a href=\"#forof-%C3%A0-la-rescousse\" class=\"phenomic-HeadingAnchor\">#</a><code>for..of</code> à la rescousse</h2>\n<p>Le consortium ECMA a donc décidé de procéder à la création d'une nouvelle\nversion améliorée\nde la boucle <code>for..in</code>. Ainsi naquit la boucle <code>for..of</code> qui coexistera\ndésormais avec la précédente,\npermettant de maintenir la rétro-compatibilité avec les versions antérieures de\nla norme.</p>\n<p>Le principe est le même : parcourir n'importe quel type <em>d'objet itérable</em>.</p>\n<p>Dans sa forme la plus simple, la boucle <code>for..of</code> permet donc d'itérer sur\nl'ensemble des valeurs des clés d'un tableau.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> arr = [<span class=\"hljs-string\">'hello'</span>, <span class=\"hljs-string\">'world'</span>];\narr.baz = <span class=\"hljs-string\">'and mars'</span>;\n\n<span class=\"hljs-keyword\">for</span> ( <span class=\"hljs-keyword\">const</span> arrValue <span class=\"hljs-keyword\">of</span> arr ) {\n  <span class=\"hljs-built_in\">console</span>.log( arrValue ); <span class=\"hljs-comment\">// 'hello', 'world'</span>\n}</code></pre>\n<p>La boucle <code>for..of</code> peut aussi itérer sur des types plus complexes. Examinons\ncela de plus près.</p>\n<h3 id=\"les-strings\"><a href=\"#les-strings\" class=\"phenomic-HeadingAnchor\">#</a>Les <em>Strings</em></h3>\n<p>Dans ce cas, chaque caractère est traité comme une entité Unicode.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> str = <span class=\"hljs-string\">'sm00th'</span>;\n\n<span class=\"hljs-keyword\">for</span> ( <span class=\"hljs-keyword\">const</span> chr <span class=\"hljs-keyword\">of</span> str ){\n  <span class=\"hljs-built_in\">console</span>.log(chr); <span class=\"hljs-comment\">// 's', 'm', '0', '0', 't', 'h'</span>\n}</code></pre>\n<h3 id=\"les-nodelist\"><a href=\"#les-nodelist\" class=\"phenomic-HeadingAnchor\">#</a>Les <em>NodeList</em></h3>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// <span class=\"hljs-doctag\">Note:</span> cela ne fonctionnera que sur les environnements</span>\n<span class=\"hljs-comment\">// implémentant NodeList.prototype[Symbol.iterator]</span>\n\n<span class=\"hljs-comment\">// ce code ajoute une class \"read\" à toutes les balises &#x3C;p></span>\n<span class=\"hljs-comment\">// contenues dans la(les) balises &#x3C;article></span>\n\n<span class=\"hljs-keyword\">const</span> articleParagraphs = <span class=\"hljs-built_in\">document</span>.querySelectorAll(<span class=\"hljs-string\">\"article > p\"</span>);\n\n<span class=\"hljs-keyword\">for</span> ( <span class=\"hljs-keyword\">const</span> paragraph <span class=\"hljs-keyword\">of</span> articleParagraphs ) {\n  paragraph.classList.add(<span class=\"hljs-string\">\"read\"</span>);\n}</code></pre>\n<h3 id=\"les-maps\"><a href=\"#les-maps\" class=\"phenomic-HeadingAnchor\">#</a>Les <em>Maps</em></h3>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> m = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Map</span>([[<span class=\"hljs-string\">'foo'</span>, <span class=\"hljs-string\">'hello'</span>], [<span class=\"hljs-string\">'bar'</span>, <span class=\"hljs-string\">'world'</span>]]);\n\n<span class=\"hljs-keyword\">for</span> ( <span class=\"hljs-keyword\">const</span> [name, value] <span class=\"hljs-keyword\">of</span> m ) {\n  <span class=\"hljs-built_in\">console</span>.log(name + <span class=\"hljs-string\">\"->\"</span> + value); <span class=\"hljs-comment\">//\"foo->hello\", \"bar->world\"</span>\n}</code></pre>\n<h3 id=\"les-sets\"><a href=\"#les-sets\" class=\"phenomic-HeadingAnchor\">#</a>Les <em>Sets</em></h3>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> s = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Set</span>([<span class=\"hljs-string\">'foo'</span>, <span class=\"hljs-literal\">true</span>, <span class=\"hljs-number\">42</span>]);\n\n<span class=\"hljs-keyword\">for</span> ( <span class=\"hljs-keyword\">const</span> value <span class=\"hljs-keyword\">of</span> s ) {\n  <span class=\"hljs-built_in\">console</span>.log(value); <span class=\"hljs-comment\">// 'foo', true, 42</span>\n}</code></pre>\n<h3 id=\"les-generators\"><a href=\"#les-generators\" class=\"phenomic-HeadingAnchor\">#</a>Les <em>Generators</em></h3>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> *<span class=\"hljs-title\">foo</span>(<span class=\"hljs-params\"></span>) </span>{\n    <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-string\">'foo'</span>;\n    <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-literal\">false</span>;\n    <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-number\">42</span>;\n    <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-string\">'bar'</span>;\n}\n\n<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">const</span> v <span class=\"hljs-keyword\">of</span> foo() ) {\n    <span class=\"hljs-built_in\">console</span>.log( v ); <span class=\"hljs-comment\">// 'foo', false, 42, 'bar'</span>\n}</code></pre>\n<blockquote>\n<p>Et les objets traditionnels dans tout ça ?</p>\n</blockquote>\n<p>Étonnamment, les objets ne peuvent pas être parcourus avec cette nouvelle\nboucle sauf s'ils définissent le symbole <code>Symbol.iterator</code>. Heureusement,\nil existe une solution de contournement par l'utilisation de\n<a href=\"https://developer.mozilla.org/fr/docs/Web/JavaScript/Reference/Objets_globaux/Object/keys\"><code>Object.keys()</code></a>\nou encore\nd'<a href=\"https://developer.mozilla.org/fr/docs/Web/JavaScript/Reference/Objets_globaux/Object/values\"><code>Object.values()</code></a>\net\n<a href=\"https://developer.mozilla.org/fr/docs/Web/JavaScript/Reference/Objets_globaux/Object/entries\"><code>Object.entries()</code></a>\n(ajouts ECMAScript7).</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> obj = { <span class=\"hljs-attr\">foo</span> : <span class=\"hljs-string\">'hello'</span>, <span class=\"hljs-attr\">bar</span> : <span class=\"hljs-string\">'world'</span> };\n\n<span class=\"hljs-keyword\">for</span> ( <span class=\"hljs-keyword\">const</span> key <span class=\"hljs-keyword\">of</span> <span class=\"hljs-built_in\">Object</span>.keys(obj) ) {\n  <span class=\"hljs-built_in\">console</span>.log(key + <span class=\"hljs-string\">\"->\"</span> + obj[key]); <span class=\"hljs-comment\">// 'foo->hello', 'bar->world'</span>\n}</code></pre>\n<p>Exemple définissant un itérateur :</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> iterableObj = {\n  *[<span class=\"hljs-built_in\">Symbol</span>.iterator]() {\n    <span class=\"hljs-keyword\">yield</span>* <span class=\"hljs-built_in\">Object</span>.entries(obj);\n  }\n};\n\n<span class=\"hljs-keyword\">for</span> ( <span class=\"hljs-keyword\">const</span> [key, val] <span class=\"hljs-keyword\">of</span> iterableObj ) {\n  <span class=\"hljs-built_in\">console</span>.log(key + <span class=\"hljs-string\">\"->\"</span> + val); <span class=\"hljs-comment\">// 'foo->hello', 'bar->world'</span>\n}</code></pre>\n<h2 id=\"en-résumé\"><a href=\"#en-r%C3%A9sum%C3%A9\" class=\"phenomic-HeadingAnchor\">#</a>En résumé</h2>\n<p><code>for..of</code> vient compléter les lacunes de <code>for..in</code> et permet\nune itération simplifiée sur les <em>objets itérables</em> tels que :</p>\n<ul>\n<li><a href=\"https://developer.mozilla.org/fr/docs/Web/JavaScript/Reference/Objets_globaux/Array\">Array</a></li>\n<li><a href=\"https://developer.mozilla.org/fr/docs/Web/JavaScript/Reference/Objets_globaux/String\">String</a></li>\n<li><a href=\"http://putaindecode.io/fr/articles/js/es2015/maps-weakmaps/\">Maps &#x26; WeakMaps</a></li>\n<li><a href=\"https://developer.mozilla.org/fr/docs/Web/JavaScript/Reference/Instructions/function*\">Generators</a></li>\n<li><a href=\"https://developer.mozilla.org/fr/docs/Web/API/NodeList\">NodeList</a></li>\n<li><a href=\"https://developer.mozilla.org/fr/docs/Web/JavaScript/Reference/Fonctions/arguments\">arguments</a></li>\n</ul>\n<p>De plus, <code>for..of</code> résout à présent les pièges tels que l'ordre d'itération non\nconstant ou la coercion\nautomatique des index en chaîne de caractères.</p>\n<h2 id=\"pour-aller-plus-loin\"><a href=\"#pour-aller-plus-loin\" class=\"phenomic-HeadingAnchor\">#</a>Pour aller plus loin</h2>\n<p>La boucle <code>for..of</code> est donc une corde de plus à l'arc de l'ES6 qui\npermet de parcourir, de manière native, les tout nouveaux <em>objets itérables</em> du\nlangage.</p>\n<p>Pour en savoir plus sur ses spécificités :</p>\n<ul>\n<li><a href=\"https://developer.mozilla.org/fr/docs/Web/JavaScript/Reference/Instructions/for...of\">Documentation\nMDN</a></li>\n<li><a href=\"https://hacks.mozilla.org/2015/04/es6-in-depth-iterators-and-the-for-of-loop/\">Le post de Jason\nOrendorff</a></li>\n<li><a href=\"http://tc39wiki.calculist.org/es6/for-of/\">Le post de Dave Herman</a></li>\n<li><a href=\"http://people.mozilla.org/~jorendorff/es6-draft.html#sec-for-in-and-for-of-statements\">Specification\nECMA-262</a></li>\n</ul>\n","rawBody":"\n## Introduction\n\nAvec l'arrivée de nouveaux objets itérables, ECMAScript avait la nécessité de\ns'enrichir de\nnouvelles façons de parcourir ces derniers. Dans l'unique souci de maintenir la\nrétro-compatibilité\navec l'existant, l'ES6 se devait de garder la boucle `for..in` intacte.\n\n> Mais alors, comment créer une variante de cette même boucle avec des capacités\naméliorées ?  \n\nLa solution est simple : \"Bienvenue au mot-clé `of` !\"\n\nMais avant d'en dire plus, et pour comprendre l'utilité de ce nouveau mot-clé,\nrevoyons un peu l'existant.\n\n## Le bon vieux `for..in`\n\nTout _JavaScript enthusiast_ qui se respecte connaissait déjà la fameuse boucle\n`for..in`\ndont l'utilité première est d'itérer sur les différentes clés d'un objet ou d'un\ntableau.\n\n```js\nconst obj = { foo : 'hello', bar : 'world' };\n\nfor ( const key in obj ) {\n  console.log( key + '->' + obj[key] );  // 'foo->hello', 'bar->world'\n}\n```\n\nLa boucle `for..in`, malgré son apparente simplicité d'utilisation, cache\ncertains pièges :\n - Lors de l'itération sur un tableau la valeur de l'index est convertie en\nchaîne\n de caractères : \"0\", \"1\", \"2\", etc. Cela peut potentiellement poser problème\nlors de\n l'utilisation de l'index dans des opérations de calcul.\n - La boucle itère sur l'ensemble des clés du tableau, mais aussi sur chacune de\nses propriétés.\n\n    ```js\n    const arr = ['foo', 'bar'];\n    arr.oups = 'baz';\n\n    for ( const key in arr ) {\n      console.log( key + '->' + arr[key] ); // '0->foo', '1->bar', 'oups->baz'\n    }\n    ```\n - L'ordre d'itération sur l'ensemble des clés d'un objet peut varier selon\nl'environnement d'éxecution du code.\n\n## La methode alternative `.forEach()`\n\nLa boucle\n[`Array.prototype.forEach()`](https://developer.mozilla.org/fr/docs/Web/JavaScript/Reference/Objets_globaux/Array/forEach)\npermet une itération plus sécurisée, mais présente certains autres inconvénients\ntels que :\n\n - L'impossibilité d'interrompre la boucle avec les instructions traditionnelles\n`break;` et `return;`\n - Il s'agit d'une méthode réservée aux tableaux.\n\n## `for..of` à la rescousse\n\nLe consortium ECMA a donc décidé de procéder à la création d'une nouvelle\nversion améliorée\nde la boucle `for..in`. Ainsi naquit la boucle `for..of` qui coexistera\ndésormais avec la précédente,\npermettant de maintenir la rétro-compatibilité avec les versions antérieures de\nla norme.\n\nLe principe est le même : parcourir n'importe quel type _d'objet itérable_.\n\nDans sa forme la plus simple, la boucle `for..of` permet donc d'itérer sur\nl'ensemble des valeurs des clés d'un tableau.\n\n```js\nconst arr = ['hello', 'world'];\narr.baz = 'and mars';\n\nfor ( const arrValue of arr ) {\n  console.log( arrValue ); // 'hello', 'world'\n}\n```\n\nLa boucle `for..of` peut aussi itérer sur des types plus complexes. Examinons\ncela de plus près.\n\n### Les _Strings_\n\nDans ce cas, chaque caractère est traité comme une entité Unicode.\n\n```js\nconst str = 'sm00th';\n\nfor ( const chr of str ){\n  console.log(chr); // 's', 'm', '0', '0', 't', 'h'\n}\n```\n\n### Les _NodeList_\n\n```js\n// Note: cela ne fonctionnera que sur les environnements\n// implémentant NodeList.prototype[Symbol.iterator]\n\n// ce code ajoute une class \"read\" à toutes les balises <p>\n// contenues dans la(les) balises <article>\n\nconst articleParagraphs = document.querySelectorAll(\"article > p\");\n\nfor ( const paragraph of articleParagraphs ) {\n  paragraph.classList.add(\"read\");\n}\n```\n\n### Les _Maps_\n\n```js\nconst m = new Map([['foo', 'hello'], ['bar', 'world']]);\n\nfor ( const [name, value] of m ) {\n  console.log(name + \"->\" + value); //\"foo->hello\", \"bar->world\"\n}\n```\n\n### Les _Sets_\n\n```js\nconst s = new Set(['foo', true, 42]);\n\nfor ( const value of s ) {\n  console.log(value); // 'foo', true, 42\n}\n```\n\n### Les _Generators_\n\n```js\nfunction *foo() {\n    yield 'foo';\n    yield false;\n    yield 42;\n    yield 'bar';\n}\n\nfor (const v of foo() ) {\n    console.log( v ); // 'foo', false, 42, 'bar'\n}\n```\n\n> Et les objets traditionnels dans tout ça ?\n\nÉtonnamment, les objets ne peuvent pas être parcourus avec cette nouvelle \nboucle sauf s'ils définissent le symbole `Symbol.iterator`. Heureusement, \nil existe une solution de contournement par l'utilisation de\n[`Object.keys()`](https://developer.mozilla.org/fr/docs/Web/JavaScript/Reference/Objets_globaux/Object/keys)\nou encore \nd'[`Object.values()`](https://developer.mozilla.org/fr/docs/Web/JavaScript/Reference/Objets_globaux/Object/values)\net\n[`Object.entries()`](https://developer.mozilla.org/fr/docs/Web/JavaScript/Reference/Objets_globaux/Object/entries)\n(ajouts ECMAScript7).\n\n```js\nconst obj = { foo : 'hello', bar : 'world' };\n\nfor ( const key of Object.keys(obj) ) {\n  console.log(key + \"->\" + obj[key]); // 'foo->hello', 'bar->world'\n}\n\n```\n\nExemple définissant un itérateur :\n\n```js\nconst iterableObj = {\n  *[Symbol.iterator]() {\n    yield* Object.entries(obj);\n  }\n};\n\nfor ( const [key, val] of iterableObj ) {\n  console.log(key + \"->\" + val); // 'foo->hello', 'bar->world'\n}\n```\n\n## En résumé\n\n`for..of` vient compléter les lacunes de `for..in` et permet\nune itération simplifiée sur les _objets itérables_ tels que :\n\n* [Array](https://developer.mozilla.org/fr/docs/Web/JavaScript/Reference/Objets_globaux/Array)\n* [String](https://developer.mozilla.org/fr/docs/Web/JavaScript/Reference/Objets_globaux/String)\n* [Maps & WeakMaps](http://putaindecode.io/fr/articles/js/es2015/maps-weakmaps/)\n* [Generators](https://developer.mozilla.org/fr/docs/Web/JavaScript/Reference/Instructions/function*)\n* [NodeList](https://developer.mozilla.org/fr/docs/Web/API/NodeList)\n* [arguments](https://developer.mozilla.org/fr/docs/Web/JavaScript/Reference/Fonctions/arguments)\n\nDe plus, `for..of` résout à présent les pièges tels que l'ordre d'itération non\nconstant ou la coercion\nautomatique des index en chaîne de caractères.\n\n## Pour aller plus loin\n\nLa boucle `for..of` est donc une corde de plus à l'arc de l'ES6 qui\npermet de parcourir, de manière native, les tout nouveaux _objets itérables_ du\nlangage.\n\nPour en savoir plus sur ses spécificités :\n\n* [Documentation\nMDN](https://developer.mozilla.org/fr/docs/Web/JavaScript/Reference/Instructions/for...of)\n* [Le post de Jason\nOrendorff](https://hacks.mozilla.org/2015/04/es6-in-depth-iterators-and-the-for-of-loop/)\n* [Le post de Dave Herman](http://tc39wiki.calculist.org/es6/for-of/)\n* [Specification\nECMA-262](http://people.mozilla.org/~jorendorff/es6-draft.html#sec-for-in-and-for-of-statements)\n","__filename":"fr/articles/js/es2015/for-of.md","__url":"/fr/articles/js/es2015/for-of/","__resourceUrl":"/fr/articles/js/es2015/for-of/index.html","__dataUrl":"/fr/articles/js/es2015/for-of/index.html.52c6da4fb751ef11de4565d21a31d378.json"}