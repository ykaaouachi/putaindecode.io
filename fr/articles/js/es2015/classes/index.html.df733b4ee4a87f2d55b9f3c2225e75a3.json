{"head":{"layout":"Post","comments":true,"date":"2015-12-05","title":"ES6, ES2015 : les classes","tags":["javascript","ES6","ES2015"],"authors":["magsout"],"description":"Les classes introduites par ES2015 ne sont clairement que du sucre syntaxique. Elles n'apportent rien de plus en terme de fonctionnalité.…"},"body":"<p>Les classes introduites par <code>ES2015</code> ne sont clairement que du sucre syntaxique.\nElles n'apportent rien de plus en terme de fonctionnalité. Toutefois, l'objectif\nde cette évolution est de rendre le code plus lisible et plus facilement\naccessible.</p>\n<h2 id=\"déclaration-de-classes\"><a href=\"#d%C3%A9claration-de-classes\" class=\"phenomic-HeadingAnchor\">#</a>Déclaration de classes</h2>\n<p>Oubliez les fonctions anonymes et les prototypes, la sémantique a pris le\nrelais, comme vous pouvez le constater dans l'exemple de déclaration de la\nclasse <code>User</code> :</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">User</span> </span>{\n  <span class=\"hljs-comment\">// méthode constructor</span>\n  <span class=\"hljs-keyword\">constructor</span>(firstname, lastname) {\n    <span class=\"hljs-keyword\">this</span>.firstname = firstname;\n    <span class=\"hljs-keyword\">this</span>.lastname = lastname;\n  }\n\n  sayName() {\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">`<span class=\"hljs-subst\">${<span class=\"hljs-keyword\">this</span>.firstname}</span> <span class=\"hljs-subst\">${<span class=\"hljs-keyword\">this</span>.lastname}</span>`</span>\n  }\n}\n\n<span class=\"hljs-comment\">// instanciation</span>\n<span class=\"hljs-keyword\">const</span> user = <span class=\"hljs-keyword\">new</span> User(<span class=\"hljs-string\">\"John\"</span>, <span class=\"hljs-string\">\"Doe\"</span>)\n\n<span class=\"hljs-comment\">// appel de la méthode sayName()</span>\n<span class=\"hljs-built_in\">console</span>.log(user.sayName()) <span class=\"hljs-comment\">// John Doe</span></code></pre>\n<p>Pour rappel, voici une <a href=\"https://gist.github.com/magsout/a876b2fa8240a987e523\">façon possible\nd'écrire</a> cette classe en\n<code>es5</code> :</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">User</span>(<span class=\"hljs-params\">firstname, lastname</span>) </span>{\n  <span class=\"hljs-keyword\">if</span>(!(<span class=\"hljs-keyword\">this</span> <span class=\"hljs-keyword\">instanceof</span> User)) {\n    <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">TypeError</span>(<span class=\"hljs-string\">\"Class constructors cannot be invoked without 'new'\"</span>)\n  }\n  <span class=\"hljs-keyword\">this</span>.firstname = firstname\n  <span class=\"hljs-keyword\">this</span>.lastname = lastname\n}\n\nUser.prototype.sayName = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) </span>{\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">this</span>.firstname + <span class=\"hljs-string\">\" \"</span> + <span class=\"hljs-keyword\">this</span>.lastname\n}\n\n<span class=\"hljs-comment\">// instanciation</span>\n<span class=\"hljs-keyword\">var</span> user = <span class=\"hljs-keyword\">new</span> User(<span class=\"hljs-string\">\"John\"</span>, <span class=\"hljs-string\">\"Doe\"</span>)\n\n<span class=\"hljs-comment\">// appel de la méthode sayName()</span>\n<span class=\"hljs-built_in\">console</span>.log(user.sayName()) <span class=\"hljs-comment\">// John Doe</span></code></pre>\n<h2 id=\"expressions-de-classes\"><a href=\"#expressions-de-classes\" class=\"phenomic-HeadingAnchor\">#</a>Expressions de classes</h2>\n<p>Toutes les méthodes s'écrivent comme de simples fonctions à l'intérieur de la\nclasse. Bien entendu, les getter/setter sont toujours de la partie mais bien\nplus simples à utiliser :</p>\n<pre><code class=\"hljs language-JS\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">User</span> </span>{\n  <span class=\"hljs-comment\">// constructor</span>\n  <span class=\"hljs-keyword\">constructor</span>(firstname, lastname, type) {\n    <span class=\"hljs-keyword\">this</span>.firstname = firstname\n    <span class=\"hljs-keyword\">this</span>.lastname = lastname\n    <span class=\"hljs-keyword\">this</span>.type = type\n  }\n\n  <span class=\"hljs-comment\">// méthode</span>\n  sayName() {\n   <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">`<span class=\"hljs-subst\">${<span class=\"hljs-keyword\">this</span>.firstname}</span>  <span class=\"hljs-subst\">${<span class=\"hljs-keyword\">this</span>.lastname}</span>`</span>\n  }\n\n  <span class=\"hljs-comment\">// getter</span>\n  get role() {\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">this</span>.type\n  }\n\n  <span class=\"hljs-comment\">// setter</span>\n  set role(value) {\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">this</span>.type = value\n  }\n}\n\n<span class=\"hljs-comment\">// le `new` est obligatoire pour appeler une classe</span>\n<span class=\"hljs-keyword\">const</span> user = <span class=\"hljs-keyword\">new</span> User(<span class=\"hljs-string\">\"John\"</span>, <span class=\"hljs-string\">\"Doe\"</span>, <span class=\"hljs-string\">\"Contributor\"</span>)\n\n<span class=\"hljs-built_in\">console</span>.log(user.sayName()) <span class=\"hljs-comment\">// John Doe</span>\n<span class=\"hljs-built_in\">console</span>.log(user.role) <span class=\"hljs-comment\">// Contributor</span>\nuser.role = <span class=\"hljs-string\">\"owner\"</span>\n<span class=\"hljs-built_in\">console</span>.log(user.role) <span class=\"hljs-comment\">// Owner</span></code></pre>\n<h2 id=\"lhéritage\"><a href=\"#lh%C3%A9ritage\" class=\"phenomic-HeadingAnchor\">#</a>L'héritage</h2>\n<p>Pour qu'une sous-classe hérite d'une autre classe on utilisera le mot\nclé <code>extends</code>.</p>\n<p>En utilisant notre exemple précédent :</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Contributor</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">User</span> </span>{\n  <span class=\"hljs-keyword\">constructor</span>(firstname, lastname, numberCommit) {\n\n    <span class=\"hljs-comment\">// le mot clé super est utilisé comme super contructeur. Il permet d'appeler</span>\n    <span class=\"hljs-comment\">// et d'avoir accès aux méthodes du parent</span>\n    <span class=\"hljs-keyword\">super</span>(firstname, lastname)\n    <span class=\"hljs-keyword\">this</span>.numberCommit = numberCommit\n  }\n\n  sayNameWithCommit() {\n    <span class=\"hljs-comment\">// on peut appeler une méthode de la classe parente avec `super.method`</span>\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">super</span>.sayName() + <span class=\"hljs-string\">\" \"</span> + <span class=\"hljs-keyword\">this</span>.sayNumberCommit()\n  }\n\n  sayNumberCommit() {\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">this</span>.numberCommit\n  }\n}\n\n<span class=\"hljs-comment\">// instanciation</span>\n<span class=\"hljs-keyword\">const</span> contributor = <span class=\"hljs-keyword\">new</span> Contributor(<span class=\"hljs-string\">'Jane'</span>, <span class=\"hljs-string\">'Smith'</span>, <span class=\"hljs-number\">10</span>)\n\n<span class=\"hljs-comment\">// appel de la méthode sayName()</span>\n<span class=\"hljs-built_in\">console</span>.log(contributor.sayName())\n<span class=\"hljs-built_in\">console</span>.log(contributor.sayNumberCommit())</code></pre>\n<p><strong>Rappel : <a href=\"https://www.youtube.com/watch?v=wfMtDGfHWpA\">préférez la composition à l'héritage</a>.</strong></p>\n<h2 id=\"thats-it\"><a href=\"#thats-it\" class=\"phenomic-HeadingAnchor\">#</a>That's it</h2>\n<p>Concrètement, tout ce qui est possible de faire avec cette nouvelle notation\nl'était bien entendu\n<a href=\"https://gist.github.com/bloodyowl/7edc9c973d2236ed17e1\">avant</a>.</p>\n<p>Au final, on gagne en clarté, en lisibilité et donc en maintenabilité.</p>\n<p>À l'heure actuelle, il est nécessaire de passer par un transpileur comme\n<a href=\"https://babeljs.io/\">babel</a> pour utiliser les classes.</p>\n<p>Une dernière petite chose, le\n<a href=\"https://developer.mozilla.org/fr/docs/Web/JavaScript/Reference/Strict_mode\">mode strict</a>\nest automatiquement activé dans le corps des classes et leurs déclarations.\nIl n'est donc pas nécessaire de le rajouter manuellement.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">/* Mode strict initial */</span>\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">MyClass</span> </span>{\n  someMethod() {\n    <span class=\"hljs-comment\">/* Ici le mode strict est implicitement activé */</span>\n  }\n}\n<span class=\"hljs-comment\">/* Mode strict inchangé */</span></code></pre>\n","rawBody":"\nLes classes introduites par `ES2015` ne sont clairement que du sucre syntaxique.\nElles n'apportent rien de plus en terme de fonctionnalité. Toutefois, l'objectif\nde cette évolution est de rendre le code plus lisible et plus facilement\naccessible.\n\n## Déclaration de classes\n\nOubliez les fonctions anonymes et les prototypes, la sémantique a pris le\nrelais, comme vous pouvez le constater dans l'exemple de déclaration de la\nclasse `User` :\n\n```js\nclass User {\n  // méthode constructor\n  constructor(firstname, lastname) {\n    this.firstname = firstname;\n    this.lastname = lastname;\n  }\n\n  sayName() {\n    return `${this.firstname} ${this.lastname}`\n  }\n}\n\n// instanciation\nconst user = new User(\"John\", \"Doe\")\n\n// appel de la méthode sayName()\nconsole.log(user.sayName()) // John Doe\n```\n\nPour rappel, voici une [façon possible\nd'écrire](https://gist.github.com/magsout/a876b2fa8240a987e523) cette classe en\n`es5` :\n\n```js\nfunction User(firstname, lastname) {\n  if(!(this instanceof User)) {\n    throw new TypeError(\"Class constructors cannot be invoked without 'new'\")\n  }\n  this.firstname = firstname\n  this.lastname = lastname\n}\n\nUser.prototype.sayName = function() {\n  return this.firstname + \" \" + this.lastname\n}\n\n// instanciation\nvar user = new User(\"John\", \"Doe\")\n\n// appel de la méthode sayName()\nconsole.log(user.sayName()) // John Doe\n```\n\n## Expressions de classes\n\nToutes les méthodes s'écrivent comme de simples fonctions à l'intérieur de la\nclasse. Bien entendu, les getter/setter sont toujours de la partie mais bien\nplus simples à utiliser :\n\n```JS\nclass User {\n  // constructor\n  constructor(firstname, lastname, type) {\n    this.firstname = firstname\n    this.lastname = lastname\n    this.type = type\n  }\n\n  // méthode\n  sayName() {\n   return `${this.firstname}  ${this.lastname}`\n  }\n\n  // getter\n  get role() {\n    return this.type\n  }\n\n  // setter\n  set role(value) {\n    return this.type = value\n  }\n}\n\n// le `new` est obligatoire pour appeler une classe\nconst user = new User(\"John\", \"Doe\", \"Contributor\")\n\nconsole.log(user.sayName()) // John Doe\nconsole.log(user.role) // Contributor\nuser.role = \"owner\"\nconsole.log(user.role) // Owner\n```\n\n## L'héritage\n\nPour qu'une sous-classe hérite d'une autre classe on utilisera le mot\nclé `extends`.\n\nEn utilisant notre exemple précédent :\n\n```js\nclass Contributor extends User {\n  constructor(firstname, lastname, numberCommit) {\n\n    // le mot clé super est utilisé comme super contructeur. Il permet d'appeler\n    // et d'avoir accès aux méthodes du parent\n    super(firstname, lastname)\n    this.numberCommit = numberCommit\n  }\n\n  sayNameWithCommit() {\n    // on peut appeler une méthode de la classe parente avec `super.method`\n    return super.sayName() + \" \" + this.sayNumberCommit()\n  }\n\n  sayNumberCommit() {\n    return this.numberCommit\n  }\n}\n\n// instanciation\nconst contributor = new Contributor('Jane', 'Smith', 10)\n\n// appel de la méthode sayName()\nconsole.log(contributor.sayName())\nconsole.log(contributor.sayNumberCommit())\n\n```\n\n**Rappel : [préférez la composition à l'héritage](https://www.youtube.com/watch?v=wfMtDGfHWpA).**\n\n## That's it\n\nConcrètement, tout ce qui est possible de faire avec cette nouvelle notation\nl'était bien entendu\n[avant](https://gist.github.com/bloodyowl/7edc9c973d2236ed17e1).\n\nAu final, on gagne en clarté, en lisibilité et donc en maintenabilité.\n\nÀ l'heure actuelle, il est nécessaire de passer par un transpileur comme\n[babel](https://babeljs.io/) pour utiliser les classes.\n\nUne dernière petite chose, le \n[mode strict](https://developer.mozilla.org/fr/docs/Web/JavaScript/Reference/Strict_mode) \nest automatiquement activé dans le corps des classes et leurs déclarations.\nIl n'est donc pas nécessaire de le rajouter manuellement.\n\n```js\n/* Mode strict initial */\nclass MyClass {\n  someMethod() {\n    /* Ici le mode strict est implicitement activé */\n  }\n}\n/* Mode strict inchangé */\n```\n","__filename":"fr/articles/js/es2015/classes.md","__url":"/fr/articles/js/es2015/classes/","__resourceUrl":"/fr/articles/js/es2015/classes/index.html","__dataUrl":"/fr/articles/js/es2015/classes/index.html.df733b4ee4a87f2d55b9f3c2225e75a3.json"}