{"head":{"layout":"Post","comments":true,"date":"2015-12-15","title":"ES6, ES2015 : les fonctions fléchées","tags":["JavaScript","ES6","ES2015"],"authors":["MoOx"],"reviewers":["Nyalab"],"description":"ES2015 nous apporte encore du sucre syntaxique qui risque très probablement de vous faire oublier Function.prototype.bind(). Les fonctions…"},"body":"<p>ES2015 nous apporte encore du sucre syntaxique qui risque très probablement de\nvous faire oublier <code>Function.prototype.bind()</code>.</p>\n<p>Les fonctions fléchées offrent une syntaxe raccourcie des fonctions en utilisant\nla syntaxe <code>=></code>.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// es5</span>\n<span class=\"hljs-keyword\">var</span> myFn = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">x</span>) </span>{\n    <span class=\"hljs-keyword\">return</span> x + <span class=\"hljs-number\">1</span>\n}\n\n<span class=\"hljs-comment\">// es6</span>\n<span class=\"hljs-keyword\">const</span> myFn = <span class=\"hljs-function\">(<span class=\"hljs-params\">x</span>) =></span> {\n  <span class=\"hljs-keyword\">return</span> x + <span class=\"hljs-number\">1</span>\n}</code></pre>\n<p>Les fonctions fléchées sont syntaxiquement similaires à ce qu'on trouve déjà dans\nd'autres langages comme CoffeeScript, Java (8+), C#…</p>\n<p>Elles supportent les expressions ou les blocs en tant que corps de fonction.\nDans notre exemple précédent, nous avons utilisé un corps classique.\nPour de simples fonctions, nous pouvons utiliser des expressions, le but étant\nd'avoir quelque chose de concis.\nNotre exemple précédent peut ainsi s'écrire de la sorte :</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> myFn = <span class=\"hljs-function\">(<span class=\"hljs-params\">x</span>) =></span> x + <span class=\"hljs-number\">1</span></code></pre>\n<p>Notez que lorsque l'on a qu'un argument dans notre fonction, on peut omettre les\nparenthèses. Notre exemple peut donc aussi s'écrire ainsi :</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> myFn = <span class=\"hljs-function\"><span class=\"hljs-params\">x</span> =></span> x + <span class=\"hljs-number\">1</span></code></pre>\n<p>Si notre expression mérite d'être sur plusieurs lignes, on peut aussi utiliser des\nparenthèses :</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> myFn = <span class=\"hljs-function\"><span class=\"hljs-params\">x</span> =></span> (\n  x +\n  <span class=\"hljs-number\">1</span> <span class=\"hljs-comment\">// Ici vous pouvez faire du multi lignes tranquille, on peut imaginer du JSX</span>\n)</code></pre>\n<p>Les exemples suivants sont donc tous les mêmes :</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> myFn = <span class=\"hljs-function\">(<span class=\"hljs-params\">x</span>) =></span> {\n  <span class=\"hljs-keyword\">return</span> x + <span class=\"hljs-number\">1</span>\n}\n<span class=\"hljs-comment\">// ===</span>\n<span class=\"hljs-keyword\">const</span> myFn = <span class=\"hljs-function\">(<span class=\"hljs-params\">x</span>) =></span> x + <span class=\"hljs-number\">1</span>\n<span class=\"hljs-comment\">// ===</span>\n<span class=\"hljs-keyword\">const</span> myFn = <span class=\"hljs-function\"><span class=\"hljs-params\">x</span> =></span> x + <span class=\"hljs-number\">1</span>\n<span class=\"hljs-comment\">// ===</span>\n<span class=\"hljs-keyword\">const</span> myFn = <span class=\"hljs-function\"><span class=\"hljs-params\">x</span> =></span> (x + <span class=\"hljs-number\">1</span>)</code></pre>\n<p>Dans la pratique, vous utiliserez souvent cette syntaxe pour des petites méthodes\ncomme par exemple lors de l'utilisation des fonctions de tableau\nreduce/filter/map, etc.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> nums = [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">5</span>]\n<span class=\"hljs-keyword\">const</span> odds = nums.filter(<span class=\"hljs-function\"><span class=\"hljs-params\">v</span> =></span> v%<span class=\"hljs-number\">2</span>) <span class=\"hljs-comment\">// [1, 3, 5]</span>\n<span class=\"hljs-keyword\">const</span> oddsSum = odds.reduce(<span class=\"hljs-function\">(<span class=\"hljs-params\">sum, v</span>) =></span> sum+v, <span class=\"hljs-number\">0</span>) <span class=\"hljs-comment\">// 9</span></code></pre>\n<h2 id=\"les-fonctions-fléchées-nont-pas-de-this\"><a href=\"#les-fonctions-fl%C3%A9ch%C3%A9es-nont-pas-de-this\" class=\"phenomic-HeadingAnchor\">#</a>Les fonctions fléchées n'ont pas de <code>this</code></h2>\n<p>Oui, vous avez bien lu : à l'inverse des fonctions normales, les fonctions\nfléchées partagent le même <code>this</code> lexical que leur scope parent.\nDu coup, le <code>this</code> que vous pourrez utiliser dans votre corps de fonction\nfléchée est celui du code parent :</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> Someone = {\n  <span class=\"hljs-attr\">name</span>: “MoOx”,\n  <span class=\"hljs-attr\">friends</span>: [], <span class=\"hljs-comment\">// Malheureusement, il n'a pas d'amis :(</span>\n  printFriends() {\n    <span class=\"hljs-keyword\">this</span>._friends.forEach(<span class=\"hljs-function\"><span class=\"hljs-params\">f</span> =></span>\n      <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-keyword\">this</span>._name + <span class=\"hljs-string\">\" knows \"</span> + f)\n      <span class=\"hljs-comment\">// `this` ne réfère pas à la fonction fléchée du forEach !</span>\n    )\n  }\n}</code></pre>\n<p>En lisant ce code, vous avez peut être compris qu'il peut être possible de ne\nplus avoir besoin du <code>bind()</code> aussi souvent que ça pouvait être le cas :</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">import</span> React, { Component } <span class=\"hljs-keyword\">from</span> “react”\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Stuff</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">Component</span> </span>{\n\n  <span class=\"hljs-comment\">// à l'ancienne</span>\n  onClick(e) {\n    <span class=\"hljs-keyword\">this</span>.setState({ <span class=\"hljs-attr\">omg</span>: <span class=\"hljs-literal\">false</span> })\n  }\n\n  render() {\n    <span class=\"hljs-keyword\">return</span> (\n      <span class=\"xml\"><span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">div</span>></span>\n        { /* à l'ancienne */ }\n        </span>&#x3C;button onClick={ this.onClick.bind(this) }>\n          Old binded call\n        &#x3C;/button><span class=\"xml\">\n\n        { /* REGARDE MAMAN, JE BIND RIEN */ }\n        </span>&#x3C;button onClick={ (e) => this.onClick(e) }>\n          I don’t need `bind` anymore !\n        &#x3C;/button><span class=\"xml\">\n\n        { /* Encore plus simplement */ }\n        </span>&#x3C;button onClick={ (e) => this.setState({ omg: true }) }>\n          Hell yeah\n        &#x3C;/button><span class=\"xml\">\n      <span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">div</span>></span></span>\n    )\n  }\n}</code></pre>\n<h2 id=\"note-sur-les-expressions-et-les-objets\"><a href=\"#note-sur-les-expressions-et-les-objets\" class=\"phenomic-HeadingAnchor\">#</a>Note sur les expressions et les objets</h2>\n<p>Si vous voulez retourner un objet, vous serez surement supris de ne pas obtenir\nle résultat attendu avec ce code :</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> aFn = <span class=\"hljs-function\">(<span class=\"hljs-params\">obj</span>) =></span> {<span class=\"hljs-attr\">key</span>: obj.value}\n<span class=\"hljs-built_in\">console</span>.log(aFn()) <span class=\"hljs-comment\">// undefined</span></code></pre>\n<p>En effet, l'exemple ci-dessus pourrait être traduit en ES5 de la manière suivante :</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">var</span> aFn = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">obj</span>) </span>{\n  key:         <span class=\"hljs-comment\">// Defines a label named `key`</span>\n    obj.value  <span class=\"hljs-comment\">// Gets `obj.value`</span>\n               <span class=\"hljs-comment\">// Implicit returns `undefined`</span>\n}</code></pre>\n<p>Gardez en tête que dans ce contexte, une accolade ouvre un corps de fonction,\npas un objet.\nVous devrez donc faire comme ceci :</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> aFn = <span class=\"hljs-function\">(<span class=\"hljs-params\">obj</span>) =></span> { <span class=\"hljs-keyword\">return</span> {<span class=\"hljs-attr\">key</span>: obj.value} }</code></pre>\n<p>Mais attendez, avec une simple astuce, on s'en sort avec un couple de\nparenthèses :</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> aFn = <span class=\"hljs-function\">(<span class=\"hljs-params\">obj</span>) =></span> ({<span class=\"hljs-attr\">key</span>: obj.value}) <span class=\"hljs-comment\">// It works !</span></code></pre>\n<h2 id=\"conclusion\"><a href=\"#conclusion\" class=\"phenomic-HeadingAnchor\">#</a>Conclusion</h2>\n<p>Regardez\n<a href=\"https://kangax.github.io/compat-table/es6/#test-arrow_functions\">la table de compatibilité</a>.\nC'est plutôt bien supporté par la plupart des navigateurs, mais vous risquez\nsûrement d'avoir à utiliser <a href=\"http://babeljs.io\">Babel</a> afin d'être tranquille.</p>\n<p>Vous verrez que vous utiliserez les fonctions fléchées de plus en plus.\nMême si le mot clé <code>function</code> n'est pas mort, les fonctions fléchées ont un\navenir certain !</p>\n","rawBody":"\nES2015 nous apporte encore du sucre syntaxique qui risque très probablement de\nvous faire oublier ``Function.prototype.bind()``.\n\nLes fonctions fléchées offrent une syntaxe raccourcie des fonctions en utilisant\nla syntaxe `=>`.\n\n```js\n// es5\nvar myFn = function(x) {\n    return x + 1\n}\n\n// es6\nconst myFn = (x) => {\n  return x + 1\n}\n```\n\nLes fonctions fléchées sont syntaxiquement similaires à ce qu'on trouve déjà dans\nd'autres langages comme CoffeeScript, Java (8+), C#…\n\nElles supportent les expressions ou les blocs en tant que corps de fonction.\nDans notre exemple précédent, nous avons utilisé un corps classique.\nPour de simples fonctions, nous pouvons utiliser des expressions, le but étant\nd'avoir quelque chose de concis.\nNotre exemple précédent peut ainsi s'écrire de la sorte :\n\n```js\nconst myFn = (x) => x + 1\n```\n\nNotez que lorsque l'on a qu'un argument dans notre fonction, on peut omettre les\nparenthèses. Notre exemple peut donc aussi s'écrire ainsi :\n\n```js\nconst myFn = x => x + 1\n```\n\nSi notre expression mérite d'être sur plusieurs lignes, on peut aussi utiliser des\nparenthèses :\n\n```js\nconst myFn = x => (\n  x +\n  1 // Ici vous pouvez faire du multi lignes tranquille, on peut imaginer du JSX\n)\n```\n\nLes exemples suivants sont donc tous les mêmes :\n\n```js\nconst myFn = (x) => {\n  return x + 1\n}\n// ===\nconst myFn = (x) => x + 1\n// ===\nconst myFn = x => x + 1\n// ===\nconst myFn = x => (x + 1)\n```\n\nDans la pratique, vous utiliserez souvent cette syntaxe pour des petites méthodes\ncomme par exemple lors de l'utilisation des fonctions de tableau\nreduce/filter/map, etc.\n\n```js\nconst nums = [1, 2, 3, 4, 5]\nconst odds = nums.filter(v => v%2) // [1, 3, 5]\nconst oddsSum = odds.reduce((sum, v) => sum+v, 0) // 9\n```\n\n## Les fonctions fléchées n'ont pas de `this`\n\nOui, vous avez bien lu : à l'inverse des fonctions normales, les fonctions\nfléchées partagent le même ``this`` lexical que leur scope parent.\nDu coup, le ``this`` que vous pourrez utiliser dans votre corps de fonction\nfléchée est celui du code parent :\n\n```js\nconst Someone = {\n  name: “MoOx”,\n  friends: [], // Malheureusement, il n'a pas d'amis :(\n  printFriends() {\n    this._friends.forEach(f =>\n      console.log(this._name + \" knows \" + f)\n      // `this` ne réfère pas à la fonction fléchée du forEach !\n    )\n  }\n}\n```\n\nEn lisant ce code, vous avez peut être compris qu'il peut être possible de ne\nplus avoir besoin du ``bind()`` aussi souvent que ça pouvait être le cas :\n\n```js\nimport React, { Component } from “react”\nclass Stuff extends Component {\n\n  // à l'ancienne\n  onClick(e) {\n    this.setState({ omg: false })\n  }\n\n  render() {\n    return (\n      <div>\n        { /* à l'ancienne */ }\n        <button onClick={ this.onClick.bind(this) }>\n          Old binded call\n        </button>\n\n        { /* REGARDE MAMAN, JE BIND RIEN */ }\n        <button onClick={ (e) => this.onClick(e) }>\n          I don’t need `bind` anymore !\n        </button>\n\n        { /* Encore plus simplement */ }\n        <button onClick={ (e) => this.setState({ omg: true }) }>\n          Hell yeah\n        </button>\n      </div>\n    )\n  }\n}\n```\n\n## Note sur les expressions et les objets\n\nSi vous voulez retourner un objet, vous serez surement supris de ne pas obtenir\nle résultat attendu avec ce code :\n\n```js\nconst aFn = (obj) => {key: obj.value}\nconsole.log(aFn()) // undefined\n```\n\nEn effet, l'exemple ci-dessus pourrait être traduit en ES5 de la manière suivante :\n\n```js\nvar aFn = function (obj) {\n  key:         // Defines a label named `key`\n    obj.value  // Gets `obj.value`\n               // Implicit returns `undefined`\n}\n```\n\nGardez en tête que dans ce contexte, une accolade ouvre un corps de fonction,\npas un objet.\nVous devrez donc faire comme ceci :\n\n```js\nconst aFn = (obj) => { return {key: obj.value} }\n```\n\nMais attendez, avec une simple astuce, on s'en sort avec un couple de\nparenthèses :\n\n```js\nconst aFn = (obj) => ({key: obj.value}) // It works !\n```\n\n## Conclusion\n\nRegardez\n[la table de compatibilité](https://kangax.github.io/compat-table/es6/#test-arrow_functions).\nC'est plutôt bien supporté par la plupart des navigateurs, mais vous risquez\nsûrement d'avoir à utiliser [Babel](http://babeljs.io) afin d'être tranquille.\n\nVous verrez que vous utiliserez les fonctions fléchées de plus en plus.\nMême si le mot clé ``function`` n'est pas mort, les fonctions fléchées ont un\navenir certain !\n","__filename":"fr/articles/js/es2015/arrow-functions.md","__url":"/fr/articles/js/es2015/arrow-functions/","__resourceUrl":"/fr/articles/js/es2015/arrow-functions/index.html","__dataUrl":"/fr/articles/js/es2015/arrow-functions/index.html.008520ebf43868d79ca3e1515f86323a.json"}