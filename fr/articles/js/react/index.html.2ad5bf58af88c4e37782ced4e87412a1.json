{"head":{"layout":"Post","comments":true,"date":"2014-06-04","title":"Introduction à ReactJS","tags":["javascript","reactjs"],"authors":["bloodyowl"],"description":"Cela fait maintenant un an que ReactJS est open-sourced. C'est l'occasion de présenter le petit dernier de la vague MV\\*. Les différentes…"},"body":"<p>Cela fait maintenant un an que ReactJS est open-sourced.\nC'est l'occasion de présenter le petit dernier de la vague MV*.</p>\n<h2 id=\"les-différentes-approches-dui\"><a href=\"#les-diff%C3%A9rentes-approches-dui\" class=\"phenomic-HeadingAnchor\">#</a>Les différentes approches d'UI</h2>\n<h3 id=\"backbone\"><a href=\"#backbone\" class=\"phenomic-HeadingAnchor\">#</a>Backbone</h3>\n<p><a href=\"http://backbonejs.org\">Backbone</a> apporte une simplification dans la\ndéclaration d'évenements,\nil reste cependant très peu impliqué dans le rendering.\nLe choix de laisser l'utilisateur décider de tout concernant\n<code>Backbone.View</code> est positif pour de nombreux projets, mais rend\nla gestion du DOM pénible.</p>\n<p>Pour faire du data-binding, <code>Backbone</code> ne propose naturellement rien,\net l'on doit faire appel à des mixins supplémentaires pour le mettre\nen place sans s'arracher les cheveux.</p>\n<p>De plus, c'est souvent un moteur de templating comme\nHandlebars ou Jade qui génére la vue originale. On se retrouve donc avec\nun joli <code>this.$el.html(this.template(data))</code> dans la méthode <code>render()</code>\nqui va provoquer des jolies horreurs visuelles\n(ie. les images se rechargent, les videos sont réinitialisées).</p>\n<p>En somme, Backbone est très sympathique pour structurer\nson code proprement, mais concernant l'UI, n'aide absolument pas à réduire\nla compléxité liée aux états du DOM.</p>\n<h3 id=\"angular\"><a href=\"#angular\" class=\"phenomic-HeadingAnchor\">#</a>Angular</h3>\n<p><a href=\"https://angularjs.org\">Angular</a> propose une approche beaucoup plus travaillée,\nen imposant un moteur de templating HTML (on peut utiliser du preprocessing)\net on déclare ses bindings très simplement avec une syntaxe <code>{{mustache}}</code>.</p>\n<p>On déclare les évenements à l'aide d'attributs <code>ng-{eventName}</code>.</p>\n<p>Sur le papier, angular est donc très sympathique (je ne prendrais pas parti sur le dirty checking).</p>\n<h3 id=\"ember\"><a href=\"#ember\" class=\"phenomic-HeadingAnchor\">#</a>Ember</h3>\n<p><a href=\"http://emberjs.com\">Ember</a> est un framework très bien pensé et très travaillé.\nIl intègre très bien les concepts de <code>data-binding</code> à l'aide de <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/range\">DOM Ranges</a>.\nIl propose des conventions fortes, et contrairement à la plupart des <em>a priori</em>,\nest très simple à prendre en main.\nLes subviews sont très simples à utiliser à l'aide d'<code>{{outlet}}</code>.</p>\n<p>Pour résumer, ember et angular proposent de vraies solutions pour la gestion\nde l'UI. Cependant les deux conservent cette démarche :</p>\n<ul>\n<li>on <em>render</em> (génère et insère le bout de DOM) une fois</li>\n<li>on update les bindings</li>\n</ul>\n<h3 id=\"react\"><a href=\"#react\" class=\"phenomic-HeadingAnchor\">#</a>React</h3>\n<p><a href=\"http://facebook.github.io/react/\">React</a> change complètement d'approche.\nIl part d'un constat simple :\nle fait que le DOM ait constamment un état différent, c'est chiant à gérer.</p>\n<p>Du coup, et si on appelait <code>.render()</code> à chaque modification ?\nÇa a l'air stupide, hein ? Pas tant que ça en fait.</p>\n<p>React implémente un <strong>DOM virtuel</strong>, une représentation interne du DOM\nextrêmement rapide. Il inclut par ailleurs son propre système d'événements,\nce qui permet à React de faire bénéficier de la phase de capturing aux navigateurs\nn'implémentant pas <code>EventTarget</code> (oui, IE8, c'est toi que je regarde).</p>\n<p>La méthode <code>render</code> retourne des objets correspondant à la représentation\ninterne du DOM virtuel.</p>\n<p>Les classes React se définissent par leur <code>state</code>.\nLorsque l'on crée une classe, on définit une méthode <code>getInitialState</code> qui\nretournera un état initial.</p>\n<p>Après cela, le seul moyen de changer l'état est d'indiquer à <code>this.setState</code>\nquelles valeurs de l'état ont changé afin de mettre à jour le DOM.</p>\n<p>Une classe React se voit passer des propriétés au moment d'être instanciée : les\n<code>props</code>. À ne pas confondre avec le <code>state</code>, son contenu ne doit être\nmanipulé que par l'extérieur de la classe (bien que celle-ci puisse obtenir\ndes valeurs par défaut en définissant une méthode <code>getDefaultProps</code> qui les\nretourne).</p>\n<p>Le <code>state</code>, en revanche, ne doit être modifié qu'au sein des méthodes propres\nà la classe.</p>\n<p>Le principal avantage est que l'on est certain, du fait de l'appel systématique\nà <code>render</code>, que notre composant React aura la représentation attendue pour un état donné.</p>\n<p>Un des autres avantages de React est son algorithme de diff interne.\nLe DOM virtuel va être comparé avec la version visible, et React effectue\nà l'aide d'opérations simples les seuls changements nécessaires.</p>\n<p>Cela résoud des problématiques comme la position du curseur dans un champ texte\nqui effectue du two-way data-binding; puisque l'algorithme n'y voit pas de\nchangement nécessaire, le champ texte n'est pas modifié et l'on garde donc le focus.\nDu même fait, si vous avez un gif qui boucle, il ne se relancera pas\ninopinément.</p>\n<p>React est idéalement utilisé avec jsx, un pré-processeur js qui permet\nd'écrire les templates avec une syntaxe xml (voir l'exemple plus bas),\nce qui permet à des novices de le prendre en main très rapidement.</p>\n<h2 id=\"créons-un-component-react-\"><a href=\"#cr%C3%A9ons-un-component-react-\" class=\"phenomic-HeadingAnchor\">#</a>Créons un component react :</h2>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-keyword\">var</span> View = React.createClass({\n  <span class=\"hljs-attr\">getInitialState</span> : <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>)</span>{\n    <span class=\"hljs-comment\">// état initial</span>\n    <span class=\"hljs-keyword\">return</span> {\n      <span class=\"hljs-attr\">checked</span> : <span class=\"hljs-literal\">false</span>\n    }\n  },\n  <span class=\"hljs-attr\">getDefaultProps</span> : <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>)</span>{\n    <span class=\"hljs-comment\">// si `this.props.label` n'est pas présent, ce sera `\"?\"`</span>\n    <span class=\"hljs-keyword\">return</span> {\n      <span class=\"hljs-attr\">label</span> : <span class=\"hljs-string\">\"?\"</span>\n    }\n  },\n  <span class=\"hljs-attr\">toggle</span> : <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>)</span>{\n    <span class=\"hljs-comment\">// on crée un nouvel état (les états de react sont immutable)</span>\n    <span class=\"hljs-comment\">// et on déclenche le render</span>\n    <span class=\"hljs-keyword\">this</span>.setState({\n      <span class=\"hljs-attr\">checked</span> : !<span class=\"hljs-keyword\">this</span>.state.checked\n    })\n  },\n  <span class=\"hljs-attr\">render</span> : <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>)</span>{\n    <span class=\"hljs-comment\">// petit addon pour se simplifier la vie</span>\n    <span class=\"hljs-keyword\">var</span> classes = React.addons.classSet({\n      <span class=\"hljs-string\">\"list-item\"</span> : <span class=\"hljs-literal\">true</span>,\n      <span class=\"hljs-string\">\"list-item--valid\"</span> : <span class=\"hljs-keyword\">this</span>.state.checked\n    })\n    <span class=\"hljs-keyword\">return</span> (\n      <span class=\"xml\"><span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">className</span>=<span class=\"hljs-string\">{classes}</span>></span>\n        {/* notre binding tout simple */}\n        </span>&#x3C;input checked={this.state.checked} type=\"checkbox\" onChange={this.toggle} />\n        {this.props.label}\n      &#x3C;/div><span class=\"xml\">\n    )\n  }\n})\n\n// on mount le component, et l'on passe le label\nvar view = React.render(</span>&#x3C;View label=\"helloworld\" />, document.getElementById(\"id\"))\n// et hop\nview.toggle()</code></pre>\n<h2 id=\"sum-up-des-avantages-de-react\"><a href=\"#sum-up-des-avantages-de-react\" class=\"phenomic-HeadingAnchor\">#</a>Sum up des avantages de React</h2>\n<p>React a bien compris ces points :</p>\n<ul>\n<li>le DOM est lent, du moins en écriture, et limiter les interactions avec\nce dernier est essentiel ;</li>\n<li>devoir continuellement penser à l'état du DOM à l'instant <code>n</code> n'est pas\nune préoccupation que nous devrions avoir en développant l'UI de nos\ncomposants ;</li>\n<li>les concepts d'immutabilité (un objet ne change pas, on en crée un nouveau à\nchaque changement) et de composition (composer une classe de différentes\nfonctionnalités sans devoir créer des chaînes d'héritage complexes) ont de\ngrands intérêts, trop peu utilisés en front-end.</li>\n</ul>\n<p>En bonus, React, même s'il n'impose pas de bibliothèque pour les\ndata et la communication des modules, offre une approche nommée\n<a href=\"http://facebook.github.io/flux/docs/overview.html\">flux</a> très\nintéressante et vous offrant des clés pour concevoir une app avec en\ntête les paradigmes pensés pour React.</p>\n<p>Last but not least, vous pouvez render vos composants React depuis le serveur\net la lib sera assez intelligente pour reconnaitre les composants déjà générés\npour ne pas les render systématiquement, c'est pas beau, ça ?</p>\n","rawBody":"\nCela fait maintenant un an que ReactJS est open-sourced.\nC'est l'occasion de présenter le petit dernier de la vague MV*.\n\n## Les différentes approches d'UI\n\n### Backbone\n\n[Backbone](http://backbonejs.org) apporte une simplification dans la\ndéclaration d'évenements,\nil reste cependant très peu impliqué dans le rendering.\nLe choix de laisser l'utilisateur décider de tout concernant\n`Backbone.View` est positif pour de nombreux projets, mais rend\nla gestion du DOM pénible.\n\nPour faire du data-binding, `Backbone` ne propose naturellement rien,\net l'on doit faire appel à des mixins supplémentaires pour le mettre\nen place sans s'arracher les cheveux.\n\nDe plus, c'est souvent un moteur de templating comme\nHandlebars ou Jade qui génére la vue originale. On se retrouve donc avec\nun joli `this.$el.html(this.template(data))` dans la méthode `render()`\nqui va provoquer des jolies horreurs visuelles\n(ie. les images se rechargent, les videos sont réinitialisées).\n\nEn somme, Backbone est très sympathique pour structurer\nson code proprement, mais concernant l'UI, n'aide absolument pas à réduire\nla compléxité liée aux états du DOM.\n\n### Angular\n\n[Angular](https://angularjs.org) propose une approche beaucoup plus travaillée,\nen imposant un moteur de templating HTML (on peut utiliser du preprocessing)\net on déclare ses bindings très simplement avec une syntaxe `{{mustache}}`.\n\nOn déclare les évenements à l'aide d'attributs `ng-{eventName}`.\n\nSur le papier, angular est donc très sympathique (je ne prendrais pas parti sur le dirty checking).\n\n### Ember\n\n[Ember](http://emberjs.com) est un framework très bien pensé et très travaillé.\nIl intègre très bien les concepts de `data-binding` à l'aide de [DOM Ranges](https://developer.mozilla.org/en-US/docs/Web/API/range).\nIl propose des conventions fortes, et contrairement à la plupart des _a priori_,\nest très simple à prendre en main.\nLes subviews sont très simples à utiliser à l'aide d'`{{outlet}}`.\n\nPour résumer, ember et angular proposent de vraies solutions pour la gestion\nde l'UI. Cependant les deux conservent cette démarche :\n\n- on _render_ (génère et insère le bout de DOM) une fois\n- on update les bindings\n\n### React\n\n[React](http://facebook.github.io/react/) change complètement d'approche.\nIl part d'un constat simple :\nle fait que le DOM ait constamment un état différent, c'est chiant à gérer.\n\nDu coup, et si on appelait `.render()` à chaque modification ?\nÇa a l'air stupide, hein ? Pas tant que ça en fait.\n\nReact implémente un __DOM virtuel__, une représentation interne du DOM\nextrêmement rapide. Il inclut par ailleurs son propre système d'événements,\nce qui permet à React de faire bénéficier de la phase de capturing aux navigateurs\nn'implémentant pas `EventTarget` (oui, IE8, c'est toi que je regarde).\n\nLa méthode `render` retourne des objets correspondant à la représentation\ninterne du DOM virtuel.\n\nLes classes React se définissent par leur `state`.\nLorsque l'on crée une classe, on définit une méthode `getInitialState` qui\nretournera un état initial.\n\nAprès cela, le seul moyen de changer l'état est d'indiquer à `this.setState`\nquelles valeurs de l'état ont changé afin de mettre à jour le DOM.\n\nUne classe React se voit passer des propriétés au moment d'être instanciée : les\n`props`. À ne pas confondre avec le `state`, son contenu ne doit être\nmanipulé que par l'extérieur de la classe (bien que celle-ci puisse obtenir\ndes valeurs par défaut en définissant une méthode `getDefaultProps` qui les\nretourne).\n\nLe `state`, en revanche, ne doit être modifié qu'au sein des méthodes propres\nà la classe.\n\nLe principal avantage est que l'on est certain, du fait de l'appel systématique\nà `render`, que notre composant React aura la représentation attendue pour un état donné.\n\nUn des autres avantages de React est son algorithme de diff interne.\nLe DOM virtuel va être comparé avec la version visible, et React effectue\nà l'aide d'opérations simples les seuls changements nécessaires.\n\nCela résoud des problématiques comme la position du curseur dans un champ texte\nqui effectue du two-way data-binding; puisque l'algorithme n'y voit pas de\nchangement nécessaire, le champ texte n'est pas modifié et l'on garde donc le focus.\nDu même fait, si vous avez un gif qui boucle, il ne se relancera pas\ninopinément.\n\nReact est idéalement utilisé avec jsx, un pré-processeur js qui permet\nd'écrire les templates avec une syntaxe xml (voir l'exemple plus bas),\nce qui permet à des novices de le prendre en main très rapidement.\n\n## Créons un component react :\n\n\n```javascript\nvar View = React.createClass({\n  getInitialState : function(){\n    // état initial\n    return {\n      checked : false\n    }\n  },\n  getDefaultProps : function(){\n    // si `this.props.label` n'est pas présent, ce sera `\"?\"`\n    return {\n      label : \"?\"\n    }\n  },\n  toggle : function(){\n    // on crée un nouvel état (les états de react sont immutable)\n    // et on déclenche le render\n    this.setState({\n      checked : !this.state.checked\n    })\n  },\n  render : function(){\n    // petit addon pour se simplifier la vie\n    var classes = React.addons.classSet({\n      \"list-item\" : true,\n      \"list-item--valid\" : this.state.checked\n    })\n    return (\n      <div className={classes}>\n        {/* notre binding tout simple */}\n        <input checked={this.state.checked} type=\"checkbox\" onChange={this.toggle} />\n        {this.props.label}\n      </div>\n    )\n  }\n})\n\n// on mount le component, et l'on passe le label\nvar view = React.render(<View label=\"helloworld\" />, document.getElementById(\"id\"))\n// et hop\nview.toggle()\n```\n\n## Sum up des avantages de React\n\nReact a bien compris ces points :\n\n- le DOM est lent, du moins en écriture, et limiter les interactions avec\nce dernier est essentiel ;\n- devoir continuellement penser à l'état du DOM à l'instant `n` n'est pas\nune préoccupation que nous devrions avoir en développant l'UI de nos\ncomposants ;\n- les concepts d'immutabilité (un objet ne change pas, on en crée un nouveau à\nchaque changement) et de composition (composer une classe de différentes\nfonctionnalités sans devoir créer des chaînes d'héritage complexes) ont de\ngrands intérêts, trop peu utilisés en front-end.\n\nEn bonus, React, même s'il n'impose pas de bibliothèque pour les\ndata et la communication des modules, offre une approche nommée\n[flux](http://facebook.github.io/flux/docs/overview.html) très\nintéressante et vous offrant des clés pour concevoir une app avec en\ntête les paradigmes pensés pour React.\n\nLast but not least, vous pouvez render vos composants React depuis le serveur\net la lib sera assez intelligente pour reconnaitre les composants déjà générés\npour ne pas les render systématiquement, c'est pas beau, ça ?\n","__filename":"fr/articles/js/react/index.md","__url":"/fr/articles/js/react/","__resourceUrl":"/fr/articles/js/react/index.html","__dataUrl":"/fr/articles/js/react/index.html.2ad5bf58af88c4e37782ced4e87412a1.json"}