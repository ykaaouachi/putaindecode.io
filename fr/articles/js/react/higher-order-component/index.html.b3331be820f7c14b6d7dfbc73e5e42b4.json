{"head":{"layout":"Post","comments":true,"date":"2016-06-14","title":"Les patterns Provider & Higher-Order Component avec React","tags":["javascript","react","higher-order-component"],"authors":["bloodyowl"],"description":"Le pattern provider Beaucoup de bibliotèques React ont besoin de faire passer des data au travers de tout l'arbre de composants de votre…"},"body":"<h2 id=\"le-pattern-provider\"><a href=\"#le-pattern-provider\" class=\"phenomic-HeadingAnchor\">#</a>Le pattern provider</h2>\n<p>Beaucoup de bibliotèques React ont besoin de faire passer des data au travers de tout l'arbre de composants de votre app. Par exemple Redux a besoin de passer son <em>store</em> et React Router doit passer l'objet <em>location</em>. Tout ça pourrait possiblement passer par du <em>shared mutable state</em> (état global mutable, ce qui est rarement une bonne idée). Le <em>shared mutable state</em> rend impossible une application à plus d'un contexte. En d'autres mots, ça ne marcherait que sur le client, où l'état global correspond à celui de l'utilisateur. Si vous décidez de rendre la page côté serveur, c'est impossible de reposer sur une telle implémentation : cet état ne doit pas dépasser le scope de la requête courante au serveur.</p>\n<p>Coup de bol, l'API de React nous offre une solution à ce problème: le <a href=\"http://facebook.github.io/react/docs/context.html\"><code>context</code></a>. Si l'on résume sa nature, c'est comme l'objet global de votre arbre de composants.</p>\n<p>Le <code>context</code> fonctionne de la façon suivante:</p>\n<ul>\n<li>On définit haut dans notre app un <code>context</code> que l'on donne aux composants descendants de l'app</li>\n<li>On récupère ce contexte dans les composants descendants.</li>\n</ul>\n<p>Du coup, pour <em>donner</em> ce <code>context</code>, on doit avoir un <code>Provider</code>. Son rôle est simplement de fournir un <code>context</code> pour que les composants enfants y aient accès.</p>\n<p>On va illustrer ce pattern avec un use-case très simple : dans notre app, les utilisateurs peuvent customiser le thème.</p>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-keyword\">import</span> React, { Component, PropTypes, Children } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\"react\"</span>\n\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">ThemeProvider</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">Component</span> </span>{\n  <span class=\"hljs-comment\">// la méthode getChildContext est appelée pour fournir le `context`</span>\n  <span class=\"hljs-comment\">// dans notre cas, on le récupère des `props`</span>\n  getChildContext() {\n    <span class=\"hljs-keyword\">return</span> {\n      <span class=\"hljs-attr\">theme</span>: <span class=\"hljs-keyword\">this</span>.props.theme,\n    }\n  }\n  <span class=\"hljs-comment\">// on render l'enfant</span>\n  render() {\n    <span class=\"hljs-keyword\">return</span> Children.only(<span class=\"hljs-keyword\">this</span>.props.children)\n  }\n}\n\nThemeProvider.propTypes = {\n  <span class=\"hljs-attr\">theme</span>: PropTypes.object.isRequired,\n}\n\n<span class=\"hljs-comment\">// pour que React prenne en compte le context fourni,</span>\n<span class=\"hljs-comment\">// on doit définir les types des propriétés que l'on passe</span>\nThemeProvider.childContextTypes = {\n  <span class=\"hljs-attr\">theme</span>: PropTypes.object.isRequired,\n}\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> ThemeProvider</code></pre>\n<p>Pour utiliser le provider, il suffit de wrapper notre app avec:</p>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-keyword\">import</span> React <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\"react\"</span>\n<span class=\"hljs-keyword\">import</span> ReactDOM <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\"react-dom\"</span>\n\n<span class=\"hljs-keyword\">import</span> ThemeProvider <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\"ThemeProvider\"</span>\n<span class=\"hljs-keyword\">import</span> App <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\"App\"</span>\n\n<span class=\"hljs-keyword\">const</span> theme = {\n  <span class=\"hljs-attr\">color</span>: <span class=\"hljs-string\">\"#cc3300\"</span>,\n  <span class=\"hljs-attr\">fontFamily</span>: <span class=\"hljs-string\">\"Georgia\"</span>,\n}\n\nReactDOM.render(\n  <span class=\"xml\"><span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">ThemeProvider</span> <span class=\"hljs-attr\">theme</span>=<span class=\"hljs-string\">{theme}</span>></span>\n    </span>&#x3C;App /><span class=\"xml\">\n  <span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">ThemeProvider</span>></span></span>,\n  <span class=\"hljs-built_in\">document</span>.querySelector(<span class=\"hljs-string\">\"#App\"</span>)\n)</code></pre>\n<p>Maintenant que notre <code>theme</code> est bien ajouté au <code>context</code>, on a besoin d'un moyen simple pour que nos composants dans l'app puissent le consommer. Ça nous amène au second pattern.</p>\n<h2 id=\"le-pattern-higher-order-component\"><a href=\"#le-pattern-higher-order-component\" class=\"phenomic-HeadingAnchor\">#</a>Le pattern Higher-Order Component</h2>\n<p>Afin de consommer le <code>context</code>, un component doit définir une propriété statique <code>contextTypes</code> stipulant quelles propriétés le composant souhaite récupérer. On pourrait le définir sur chaque composant, mais cela serait une mauvaise idée pour deux raisons :</p>\n<ul>\n<li><strong>La maintenabilité</strong> : si à un moment, on a besoin de refacto, avoir tous ces <code>contextTypes</code> éparpillés dans notre repository peut faire bien mal.</li>\n<li><strong>La complexité</strong>: L'API des <code>context</code> étant encore obscure pour beaucoup, il est préférable de faire une abstraction pour la masquer.</li>\n</ul>\n<p>Une autre solution serait d'utiliser l'héritage d'une sous-classe de <code>ReactComponent</code>. Ça ne marche pas pour deux raisons:</p>\n<ul>\n<li>Plus d'un niveau d'héritage est en général une idée de merde. Cela mène souvent à des conflits entre méthodes, et force à vérifier toute la chaîne d'héritage à chaque fois que l'on souhaite modifier quelque chose. L'API des <code>mixins</code> de <code>React.createClass</code> réglait ce souci en définissant des comportements de merge selon les méthodes, mais cela rend encore plus obscure la compréhension du fonctionnement de nos composants.</li>\n<li>Si l'on veut des APIs <strong>interopérables</strong>, on ne peut pas partir de l'héritage. React offre trois moyens de définir un composant: <code>class extends React.Component {}</code>, <code>React.createClass({})</code> et <code>(props) => ReactElement</code>. Les deux derniers ne peuvent pas bénéficier de l'héritage.</li>\n</ul>\n<p>La meilleure façon de créer une fonctionnalité réutilisable est d'utiliser le pattern du <strong>Higher Order Component</strong> (ou <em>HOC</em>). Ce que ça veut dire, c'est qu'on va simplement wrapper un composant dans un autre, lequel a pour unique rôle d'injecter la fonctionnalité et de la passer via les <code>props</code>. Il s'agit tout bêtement du principe de composition : au lieu d'exporter <code>A</code>, vous exportez <code>Wrapped(A)</code>, et ce dernier retourne un composant React qui va appeler <code>A</code> dans sa méthode <code>render</code>.</p>\n<p>Pour le voir simplement, il s'agit d'un point intermédiaire dans l'arbre de vos composants, qui injecte quelques <code>props</code>. Il existe beaucoup d'avantages apportés par ce pattern :</p>\n<ul>\n<li><strong>Isolation</strong> : Il n'y a pas de risque de collision de propriétés au sein du composant.</li>\n<li><strong>Interopérabilité</strong> : Ce principe s'adapte à tout composant React, peu importe la façon dont il a été défini.</li>\n<li><strong>Maintenabilité</strong> : Le wrapper n'aura qu'une seule fonctionnalité, ce qui le rend plus simple à comprendre. De plus, si l'on utilise le <code>context</code>, on ne trouvera le mapping <code>contextTypes</code> qu'à un seul endroit dans l'app.</li>\n</ul>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-keyword\">import</span> React, { Component, PropTypes } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\"react\"</span>\n\n<span class=\"hljs-keyword\">const</span> themed = <span class=\"hljs-function\">(<span class=\"hljs-params\">ComponentToWrap</span>) =></span> {\n  <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">ThemeComponent</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">Component</span> </span>{\n    render() {\n      <span class=\"hljs-keyword\">const</span> { theme } = <span class=\"hljs-keyword\">this</span>.context\n      <span class=\"hljs-comment\">// le component va render `ComponentToWrap`</span>\n      <span class=\"hljs-comment\">// mais il va y ajouter la prop `theme`, qu'il récupère du `context`</span>\n      <span class=\"hljs-keyword\">return</span> (\n        <span class=\"xml\"><span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">ComponentToWrap</span> {…<span class=\"hljs-attr\">this.props</span>} <span class=\"hljs-attr\">theme</span>=<span class=\"hljs-string\">{theme}</span> /></span>\n      )\n    }\n  }\n  // on définit ce qu'on veut consommer du `context`\n  ThemeComponent.contextTypes = {\n    theme: PropTypes.object.isRequired,\n  }\n\n  // on retourne notre wrapper\n  return ThemeComponent\n}\nexport default themed</span></code></pre>\n<p>Pour utiliser notre HOC, il suffira d'exporter nos composants wrappés :</p>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-keyword\">import</span> React <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\"React\"</span>\n<span class=\"hljs-keyword\">import</span> themed <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\"themed\"</span>\n\n<span class=\"hljs-keyword\">const</span> MyStatelessComponent = <span class=\"hljs-function\">(<span class=\"hljs-params\">{ text, theme }</span>) =></span> (\n  <span class=\"xml\"><span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">style</span>=<span class=\"hljs-string\">{{</span> <span class=\"hljs-attr\">color:</span> <span class=\"hljs-attr\">theme.color</span> }}></span>\n    {text}\n  <span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">div</span>></span></span>\n)\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> themed(MyStatelessComponent)</code></pre>\n<p>Puisqu'il s'agit simplement d'une fonction, on peut y passer des options à l'aide d'une simple closure.</p>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-keyword\">const</span> defaultMergeProps = <span class=\"hljs-function\">(<span class=\"hljs-params\">ownProps, themeProps</span>) =></span> ({  ...ownProps, ...themeProps })\n\n<span class=\"hljs-keyword\">const</span> theme = <span class=\"hljs-function\">(<span class=\"hljs-params\">mergeProps = defaultMergeProps</span>) =></span>\n  (ComponentToWrap) => {\n    <span class=\"hljs-comment\">// …</span>\n    render() {\n      <span class=\"hljs-keyword\">const</span> { theme } = <span class=\"hljs-keyword\">this</span>.context\n      <span class=\"hljs-keyword\">const</span> props = mergeProps(<span class=\"hljs-keyword\">this</span>.props, { theme })\n      <span class=\"hljs-keyword\">return</span> (\n        <span class=\"xml\"><span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">ComponentToWrap</span> {…<span class=\"hljs-attr\">props</span>} /></span>\n      )\n    }\n    // …\n  }</span></code></pre>\n<p>et l'utiliser de cette façon :</p>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-keyword\">const</span> mergeProps = <span class=\"hljs-function\">(<span class=\"hljs-params\">ownProps, themeProps</span>) =></span> ({ ...themeProps, <span class=\"hljs-attr\">color</span>: themeProps.theme.color })\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> theme(mergeProps)(MyComponent)</code></pre>\n<p>Une astuce sympathique lorsque vous utilisez plusieurs HOC, c'est de les composer, puisque <code>compose(A, B, C)(props)</code> vaudra <code>A(B(C(props)))</code>, par exemple :</p>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-keyword\">const</span> composed = compose(\n  connect(mapStateToProps),\n  theme()\n)\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> composed(MyComponent)</code></pre>\n<p>Bisous bisous.</p>\n","rawBody":"\n## Le pattern provider\n\nBeaucoup de bibliotèques React ont besoin de faire passer des data au travers de tout l'arbre de composants de votre app. Par exemple Redux a besoin de passer son *store* et React Router doit passer l'objet *location*. Tout ça pourrait possiblement passer par du *shared mutable state* (état global mutable, ce qui est rarement une bonne idée). Le *shared mutable state* rend impossible une application à plus d'un contexte. En d'autres mots, ça ne marcherait que sur le client, où l'état global correspond à celui de l'utilisateur. Si vous décidez de rendre la page côté serveur, c'est impossible de reposer sur une telle implémentation : cet état ne doit pas dépasser le scope de la requête courante au serveur.\n\nCoup de bol, l'API de React nous offre une solution à ce problème: le [`context`](http://facebook.github.io/react/docs/context.html). Si l'on résume sa nature, c'est comme l'objet global de votre arbre de composants.\n\nLe `context` fonctionne de la façon suivante:\n\n- On définit haut dans notre app un `context` que l'on donne aux composants descendants de l'app\n- On récupère ce contexte dans les composants descendants.\n\nDu coup, pour *donner* ce `context`, on doit avoir un `Provider`. Son rôle est simplement de fournir un `context` pour que les composants enfants y aient accès.\n\nOn va illustrer ce pattern avec un use-case très simple : dans notre app, les utilisateurs peuvent customiser le thème.\n\n```javascript\nimport React, { Component, PropTypes, Children } from \"react\"\n\nclass ThemeProvider extends Component {\n  // la méthode getChildContext est appelée pour fournir le `context`\n  // dans notre cas, on le récupère des `props`\n  getChildContext() {\n    return {\n      theme: this.props.theme,\n    }\n  }\n  // on render l'enfant\n  render() {\n    return Children.only(this.props.children)\n  }\n}\n\nThemeProvider.propTypes = {\n  theme: PropTypes.object.isRequired,\n}\n\n// pour que React prenne en compte le context fourni,\n// on doit définir les types des propriétés que l'on passe\nThemeProvider.childContextTypes = {\n  theme: PropTypes.object.isRequired,\n}\n\nexport default ThemeProvider\n```\n\nPour utiliser le provider, il suffit de wrapper notre app avec:\n\n```javascript\nimport React from \"react\"\nimport ReactDOM from \"react-dom\"\n\nimport ThemeProvider from \"ThemeProvider\"\nimport App from \"App\"\n\nconst theme = {\n  color: \"#cc3300\",\n  fontFamily: \"Georgia\",\n}\n\nReactDOM.render(\n  <ThemeProvider theme={theme}>\n    <App />\n  </ThemeProvider>,\n  document.querySelector(\"#App\")\n)\n```\n\nMaintenant que notre `theme` est bien ajouté au `context`, on a besoin d'un moyen simple pour que nos composants dans l'app puissent le consommer. Ça nous amène au second pattern.\n\n## Le pattern Higher-Order Component\n\nAfin de consommer le `context`, un component doit définir une propriété statique `contextTypes` stipulant quelles propriétés le composant souhaite récupérer. On pourrait le définir sur chaque composant, mais cela serait une mauvaise idée pour deux raisons :\n\n- **La maintenabilité** : si à un moment, on a besoin de refacto, avoir tous ces `contextTypes` éparpillés dans notre repository peut faire bien mal.\n- **La complexité**: L'API des `context` étant encore obscure pour beaucoup, il est préférable de faire une abstraction pour la masquer.\n\nUne autre solution serait d'utiliser l'héritage d'une sous-classe de `ReactComponent`. Ça ne marche pas pour deux raisons:\n\n- Plus d'un niveau d'héritage est en général une idée de merde. Cela mène souvent à des conflits entre méthodes, et force à vérifier toute la chaîne d'héritage à chaque fois que l'on souhaite modifier quelque chose. L'API des `mixins` de `React.createClass` réglait ce souci en définissant des comportements de merge selon les méthodes, mais cela rend encore plus obscure la compréhension du fonctionnement de nos composants.\n- Si l'on veut des APIs **interopérables**, on ne peut pas partir de l'héritage. React offre trois moyens de définir un composant: `class extends React.Component {}`, `React.createClass({})` et `(props) => ReactElement`. Les deux derniers ne peuvent pas bénéficier de l'héritage.\n\nLa meilleure façon de créer une fonctionnalité réutilisable est d'utiliser le pattern du **Higher Order Component** (ou *HOC*). Ce que ça veut dire, c'est qu'on va simplement wrapper un composant dans un autre, lequel a pour unique rôle d'injecter la fonctionnalité et de la passer via les `props`. Il s'agit tout bêtement du principe de composition : au lieu d'exporter `A`, vous exportez `Wrapped(A)`, et ce dernier retourne un composant React qui va appeler `A` dans sa méthode `render`.\n\nPour le voir simplement, il s'agit d'un point intermédiaire dans l'arbre de vos composants, qui injecte quelques `props`. Il existe beaucoup d'avantages apportés par ce pattern :\n\n- **Isolation** : Il n'y a pas de risque de collision de propriétés au sein du composant.\n- **Interopérabilité** : Ce principe s'adapte à tout composant React, peu importe la façon dont il a été défini.\n- **Maintenabilité** : Le wrapper n'aura qu'une seule fonctionnalité, ce qui le rend plus simple à comprendre. De plus, si l'on utilise le `context`, on ne trouvera le mapping `contextTypes` qu'à un seul endroit dans l'app.\n\n```javascript\nimport React, { Component, PropTypes } from \"react\"\n\nconst themed = (ComponentToWrap) => {\n  class ThemeComponent extends Component {\n    render() {\n      const { theme } = this.context\n      // le component va render `ComponentToWrap`\n      // mais il va y ajouter la prop `theme`, qu'il récupère du `context`\n      return (\n        <ComponentToWrap {…this.props} theme={theme} />\n      )\n    }\n  }\n  // on définit ce qu'on veut consommer du `context`\n  ThemeComponent.contextTypes = {\n    theme: PropTypes.object.isRequired,\n  }\n\n  // on retourne notre wrapper\n  return ThemeComponent\n}\nexport default themed\n```\n\nPour utiliser notre HOC, il suffira d'exporter nos composants wrappés :\n\n```javascript\nimport React from \"React\"\nimport themed from \"themed\"\n\nconst MyStatelessComponent = ({ text, theme }) => (\n  <div style={{ color: theme.color }}>\n    {text}\n  </div>\n)\n\nexport default themed(MyStatelessComponent)\n```\n\nPuisqu'il s'agit simplement d'une fonction, on peut y passer des options à l'aide d'une simple closure.\n\n```javascript\nconst defaultMergeProps = (ownProps, themeProps) => ({  ...ownProps, ...themeProps })\n\nconst theme = (mergeProps = defaultMergeProps) =>\n  (ComponentToWrap) => {\n    // …\n    render() {\n      const { theme } = this.context\n      const props = mergeProps(this.props, { theme })\n      return (\n        <ComponentToWrap {…props} />\n      )\n    }\n    // …\n  }\n```\n\net l'utiliser de cette façon :\n\n```javascript\nconst mergeProps = (ownProps, themeProps) => ({ ...themeProps, color: themeProps.theme.color })\nexport default theme(mergeProps)(MyComponent)\n```\n\nUne astuce sympathique lorsque vous utilisez plusieurs HOC, c'est de les composer, puisque `compose(A, B, C)(props)` vaudra `A(B(C(props)))`, par exemple :\n\n```javascript\nconst composed = compose(\n  connect(mapStateToProps),\n  theme()\n)\n\nexport default composed(MyComponent)\n```\n\nBisous bisous.\n","__filename":"fr/articles/js/react/higher-order-component/index.md","__url":"/fr/articles/js/react/higher-order-component/","__resourceUrl":"/fr/articles/js/react/higher-order-component/index.html","__dataUrl":"/fr/articles/js/react/higher-order-component/index.html.b3331be820f7c14b6d7dfbc73e5e42b4.json"}