{"head":{"layout":"Post","comments":true,"date":"2016-06-09","title":"Redux, comment ça marche ?","tags":["javascript","redux"],"authors":["bloodyowl"],"description":"Alors si vous faites du développement web et que vous ne vivez pas dans une cave, vous avez certainement déjà entendu parler de Redux.…"},"body":"<p>Alors si vous faites du développement web et que vous ne vivez pas dans une cave, vous avez certainement déjà entendu parler de <a href=\"http://redux.js.org\">Redux</a>.</p>\n<h2 id=\"kesako-\"><a href=\"#kesako-\" class=\"phenomic-HeadingAnchor\">#</a>Kesako ?</h2>\n<p>Redux est une implémentation dérivée de Flux. Ça permet de créer un <strong>Store</strong> qui contient un <strong>état</strong>, réagit à des <strong>actions dispatchées</strong>, et auquel on peut <strong>souscrire</strong> pour être notifié des changements. Il permet également l'ajout de <strong>middlewares</strong>, qui peuvent en quelque sorte <em>pre-process</em> les actions.</p>\n<p>Du coup, on va écrire une implémentation de Redux pour mieux décomposer son fonctionnement.</p>\n<h2 id=\"1-gérer-létat\"><a href=\"#1-g%C3%A9rer-l%C3%A9tat\" class=\"phenomic-HeadingAnchor\">#</a>1. Gérer l'état</h2>\n<p>Redux se distingue par son mécanisme d'update de l'état, puisqu'il est décrit dans des <strong>reducers</strong>. Vous connaissez <a href=\"/fr/articles/js/array-reduce/\"><code>Array.prototype.reduce</code></a> ? Eh ben votre <strong>reducer</strong> a exactement la même signature que la fonction de <code>reduce</code>.</p>\n<p>Pour faire simple, votre état vaudra toujours :</p>\n<pre><code class=\"hljs language-javascript\">dispatchedActions.reduce(reducer, <span class=\"hljs-literal\">undefined</span>)</code></pre>\n<p>Si ça vous paraît un peu abstrait, prenons un exemple tout con de reducer :</p>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-comment\">// on part de 0</span>\n<span class=\"hljs-keyword\">const</span> initialState = { <span class=\"hljs-attr\">counter</span>: <span class=\"hljs-number\">0</span> }\n\n<span class=\"hljs-keyword\">const</span> counter = <span class=\"hljs-function\">(<span class=\"hljs-params\">state = initialState, action</span>) =></span> {\n  <span class=\"hljs-keyword\">switch</span>(action.type) {\n    <span class=\"hljs-comment\">// selon l'action …</span>\n    <span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">\"INCREMENT\"</span>:\n      <span class=\"hljs-comment\">// … on retourne un nouvel état incrémenté</span>\n      <span class=\"hljs-keyword\">return</span> { <span class=\"hljs-attr\">counter</span>: state.counter + <span class=\"hljs-number\">1</span> }\n    <span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">\"DECREMENT\"</span>:\n      <span class=\"hljs-comment\">// … ou décrémenté</span>\n      <span class=\"hljs-keyword\">return</span> { <span class=\"hljs-attr\">counter</span>: state.counter - <span class=\"hljs-number\">1</span> }\n    <span class=\"hljs-keyword\">default</span>:\n      <span class=\"hljs-comment\">// ou l'état actuel, si l'on n'y touche pas</span>\n      <span class=\"hljs-keyword\">return</span> state\n  }\n}</code></pre>\n<p>Le petit <code>state = initialState</code> c'est un <a href=\"/fr/articles/js/es2015/defaults/\">paramètre avec une valeur par défaut</a>, si vous avez bien vu le bout de code avec le <code>reduce</code> un peu plus haut, on passe la valeur <code>undefined</code> comme accumulateur initial, ça permet d'avoir un state valant <code>initialState</code> au passage de la première action.</p>\n<p>Le <code>switch</code> permet de retourner un nouvel état selon les actions passées, avec un <code>default</code> qui retourne l'état actuel, dans le cas où on se fout de l'action dans ce reducer.</p>\n<p>C'est parti pour implémenter ça :</p>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-keyword\">const</span> createStore = <span class=\"hljs-function\">(<span class=\"hljs-params\">reducer</span>) =></span> {\n  <span class=\"hljs-comment\">// on balance une première action \"opaque\",</span>\n  <span class=\"hljs-comment\">// qui ne sera pas traitée par le reducer, histoire de commencer avec un état</span>\n  <span class=\"hljs-keyword\">let</span> state = reducer(<span class=\"hljs-literal\">undefined</span>, { <span class=\"hljs-attr\">type</span>: <span class=\"hljs-string\">\"@@INIT\"</span> })\n  <span class=\"hljs-keyword\">return</span> {\n    <span class=\"hljs-comment\">// une méthode pour dispatcher les actions</span>\n    dispatch: <span class=\"hljs-function\">(<span class=\"hljs-params\">action</span>) =></span> {\n      state = reducer(state, action)\n    },\n    <span class=\"hljs-comment\">// une méthode pour récupérer le state</span>\n    getState: <span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =></span> state\n  }\n}</code></pre>\n<p>Super, on peut écrire et lire notre état.</p>\n<h2 id=\"2-le-mécanisme-de-souscription\"><a href=\"#2-le-m%C3%A9canisme-de-souscription\" class=\"phenomic-HeadingAnchor\">#</a>2. Le mécanisme de souscription</h2>\n<p>Pour pouvoir signaler aux intéressés que des updates ont eu lieu sur l'état, on doit ajouter un mécanisme de souscription : un bête event emitter.</p>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-keyword\">const</span> createStore = <span class=\"hljs-function\">(<span class=\"hljs-params\">reducer</span>) =></span> {\n  <span class=\"hljs-keyword\">let</span> state = reducer(<span class=\"hljs-literal\">undefined</span>, { <span class=\"hljs-attr\">type</span>: <span class=\"hljs-string\">\"@@INIT\"</span> })\n  <span class=\"hljs-comment\">// on crée un `Set` où l'on va stocker les listeners</span>\n  <span class=\"hljs-keyword\">const</span> subscribers = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Set</span>()\n  <span class=\"hljs-keyword\">return</span> {\n    <span class=\"hljs-attr\">dispatch</span>: <span class=\"hljs-function\">(<span class=\"hljs-params\">action</span>) =></span> {\n      state = reducer(state, action)\n      <span class=\"hljs-comment\">// à chaque dispatch, on appelle les subscribers</span>\n      subscribers.forEach(<span class=\"hljs-function\">(<span class=\"hljs-params\">func</span>) =></span> func())\n    },\n    <span class=\"hljs-attr\">subscribe</span>: <span class=\"hljs-function\">(<span class=\"hljs-params\">func</span>) =></span> {\n      <span class=\"hljs-comment\">// on ajoute `func` à la liste de subscribers</span>\n      subscribers.add(func)\n      <span class=\"hljs-comment\">// et on retourne une fonction permettant d'unsubscribe</span>\n      <span class=\"hljs-keyword\">return</span> <span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =></span> {\n        subscribers.delete(func)\n      }\n    },\n    <span class=\"hljs-attr\">getState</span>: <span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =></span> state\n  }\n}</code></pre>\n<p>Ayé, le mécanisme est en place.</p>\n<h2 id=\"3-combiner-les-reducers\"><a href=\"#3-combiner-les-reducers\" class=\"phenomic-HeadingAnchor\">#</a>3. Combiner les reducers</h2>\n<p>Maintenant ce qui serait pas mal, ce serait de permettre d'avoir plusieurs reducers, afin de pouvoir les découper et d'éviter d'avoir du gros code bloated qui tâche. Pour ce faire, on va créer la fonction <code>combineReducers</code> qui va prendre un objet contenant des reducers, et transformer ça en un seul reducer qui va retourner un objet de la même forme, avec l'état retourné par le reducer de la même clé.</p>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-keyword\">const</span> combineReducers = <span class=\"hljs-function\">(<span class=\"hljs-params\">reducers</span>) =></span> {\n  <span class=\"hljs-keyword\">const</span> reducersKeys = <span class=\"hljs-built_in\">Object</span>.keys(reducers)\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-function\">(<span class=\"hljs-params\">state = {}, action</span>) =></span> {\n    <span class=\"hljs-keyword\">return</span> reducersKeys.reduce(<span class=\"hljs-function\">(<span class=\"hljs-params\">acc, key</span>) =></span> {\n      acc[key] = reducers[key](state[key], action)\n      <span class=\"hljs-keyword\">return</span> acc\n    }, {})\n  }\n}</code></pre>\n<p>Maintenant, on peut bien séparer ses reducers :</p>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-keyword\">import</span> { users } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\"./reducers/user\"</span>\n<span class=\"hljs-keyword\">import</span> { tweets } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\"./reducers/tweets\"</span>\n\n<span class=\"hljs-keyword\">const</span> reducer = combineReducers({\n  users,\n  tweets,\n})\n\n<span class=\"hljs-keyword\">const</span> store = createStore(reducer)</code></pre>\n<h2 id=\"4-permettre-lajout-de-middlewares\"><a href=\"#4-permettre-lajout-de-middlewares\" class=\"phenomic-HeadingAnchor\">#</a>4. Permettre l'ajout de middlewares</h2>\n<p>Les middlewares apportent toute la liberté de personalisation de Redux. L'un des plus populaires est le <a href=\"https://github.com/gaearon/redux-thunk\"><em>thunk middleware</em></a>, qui permet de passer une fonction à la place d'une action, et de dispatcher depuis cette fonction, ce qui peut s'avérer très utile pour gérer des réponses asynchrones.</p>\n<p>On va donc créer une fonction <code>applyMiddleware</code>, qui va enrichir un store en ajoutant une sorte de hook sur sa méthode dispatch.</p>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-comment\">// compose(a, b, c) équivaut à (...args) => a(b(c(...args)))</span>\n<span class=\"hljs-keyword\">const</span> compose = <span class=\"hljs-function\">(<span class=\"hljs-params\">...funcs</span>) =></span> {\n  <span class=\"hljs-keyword\">const</span> last = funcs[funcs.length - <span class=\"hljs-number\">1</span>]\n  <span class=\"hljs-keyword\">const</span> rest = funcs.slice(<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">-1</span>)\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-function\">(<span class=\"hljs-params\">...args</span>) =></span> rest.reduceRight(<span class=\"hljs-function\">(<span class=\"hljs-params\">composed, f</span>) =></span> f(composed), last(...args))\n}\n\n<span class=\"hljs-keyword\">const</span> applyMiddleware = <span class=\"hljs-function\">(<span class=\"hljs-params\">...middlewares</span>) =></span> {\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-function\">(<span class=\"hljs-params\">store</span>) =></span> {\n    <span class=\"hljs-comment\">// cette API sera passée à chaque middleware, afin qu'il puisse récupérer</span>\n    <span class=\"hljs-comment\">// l'état en cours et dispatcher des actions</span>\n    <span class=\"hljs-keyword\">const</span> middlewareAPI = {\n      <span class=\"hljs-attr\">getState</span>: store.getState,\n      <span class=\"hljs-attr\">dispatch</span>: <span class=\"hljs-function\">(<span class=\"hljs-params\">action</span>) =></span> dispatch(action)\n    }\n    <span class=\"hljs-keyword\">const</span> chain = middlewares.map(<span class=\"hljs-function\">(<span class=\"hljs-params\">middleware</span>) =></span> middleware(middlewareAPI))\n    <span class=\"hljs-keyword\">let</span> dispatch = compose(...chain)(store.dispatch)\n    <span class=\"hljs-keyword\">return</span> {\n      ...store,\n      dispatch,\n    }\n  }\n}</code></pre>\n<blockquote>\n<p>NOTE: l'API de Redux prend <code>createStore</code> plutôt que <code>store</code> en paramètre, la différence est volontaire dans cette démarche de simplification</p>\n</blockquote>\n<p>Voilà, maintenant on peut faire</p>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-keyword\">const</span> thunk = <span class=\"hljs-function\">(<span class=\"hljs-params\">{ dispatch, getState }</span>) =></span> (next) => <span class=\"hljs-function\">(<span class=\"hljs-params\">action</span>) =></span> {\n  <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">typeof</span> action === <span class=\"hljs-string\">\"function\"</span>) {\n    <span class=\"hljs-keyword\">return</span> action(dispatch, getState)\n  }\n  <span class=\"hljs-keyword\">return</span> next(action)\n}\n\n<span class=\"hljs-keyword\">const</span> store = applyMiddleware(thunk)(createStore(reducer))\n\n<span class=\"hljs-comment\">// et maintenant on peut faire</span>\nstore.dispatch(<span class=\"hljs-function\">(<span class=\"hljs-params\">dispatch, getState</span>) =></span> {\n  dispatch({ <span class=\"hljs-attr\">type</span>: <span class=\"hljs-string\">\"FOO\"</span> })\n  setTimeout(<span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =></span> {\n    dispatch({ <span class=\"hljs-attr\">type</span>: <span class=\"hljs-string\">\"BAR\"</span> })\n  })\n})</code></pre>\n<p>Voilà voilà, j'espère que cet article a pu vous éclairer un petit peu sur le fonctionnement de Redux et vous permettra de l'aborder avec plus de serénité.</p>\n<p>Zoub'</p>\n","rawBody":"\nAlors si vous faites du développement web et que vous ne vivez pas dans une cave, vous avez certainement déjà entendu parler de [Redux](http://redux.js.org).\n\n## Kesako ?\n\nRedux est une implémentation dérivée de Flux. Ça permet de créer un **Store** qui contient un **état**, réagit à des **actions dispatchées**, et auquel on peut **souscrire** pour être notifié des changements. Il permet également l'ajout de **middlewares**, qui peuvent en quelque sorte *pre-process* les actions.\n\nDu coup, on va écrire une implémentation de Redux pour mieux décomposer son fonctionnement.\n\n## 1. Gérer l'état\n\nRedux se distingue par son mécanisme d'update de l'état, puisqu'il est décrit dans des **reducers**. Vous connaissez [`Array.prototype.reduce`](/fr/articles/js/array-reduce/) ? Eh ben votre **reducer** a exactement la même signature que la fonction de `reduce`.\n\nPour faire simple, votre état vaudra toujours :\n\n```javascript\ndispatchedActions.reduce(reducer, undefined)\n```\n\nSi ça vous paraît un peu abstrait, prenons un exemple tout con de reducer :\n\n```javascript\n// on part de 0\nconst initialState = { counter: 0 }\n\nconst counter = (state = initialState, action) => {\n  switch(action.type) {\n    // selon l'action …\n    case \"INCREMENT\":\n      // … on retourne un nouvel état incrémenté\n      return { counter: state.counter + 1 }\n    case \"DECREMENT\":\n      // … ou décrémenté\n      return { counter: state.counter - 1 }\n    default:\n      // ou l'état actuel, si l'on n'y touche pas\n      return state\n  }\n}\n```\n\nLe petit `state = initialState` c'est un [paramètre avec une valeur par défaut](/fr/articles/js/es2015/defaults/), si vous avez bien vu le bout de code avec le `reduce` un peu plus haut, on passe la valeur `undefined` comme accumulateur initial, ça permet d'avoir un state valant `initialState` au passage de la première action.\n\nLe `switch` permet de retourner un nouvel état selon les actions passées, avec un `default` qui retourne l'état actuel, dans le cas où on se fout de l'action dans ce reducer.\n\nC'est parti pour implémenter ça :\n\n```javascript\nconst createStore = (reducer) => {\n  // on balance une première action \"opaque\",\n  // qui ne sera pas traitée par le reducer, histoire de commencer avec un état\n  let state = reducer(undefined, { type: \"@@INIT\" })\n  return {\n    // une méthode pour dispatcher les actions\n    dispatch: (action) => {\n      state = reducer(state, action)\n    },\n    // une méthode pour récupérer le state\n    getState: () => state\n  }\n}\n```\n\nSuper, on peut écrire et lire notre état.\n\n## 2. Le mécanisme de souscription\n\nPour pouvoir signaler aux intéressés que des updates ont eu lieu sur l'état, on doit ajouter un mécanisme de souscription : un bête event emitter.\n\n```javascript\nconst createStore = (reducer) => {\n  let state = reducer(undefined, { type: \"@@INIT\" })\n  // on crée un `Set` où l'on va stocker les listeners\n  const subscribers = new Set()\n  return {\n    dispatch: (action) => {\n      state = reducer(state, action)\n      // à chaque dispatch, on appelle les subscribers\n      subscribers.forEach((func) => func())\n    },\n    subscribe: (func) => {\n      // on ajoute `func` à la liste de subscribers\n      subscribers.add(func)\n      // et on retourne une fonction permettant d'unsubscribe\n      return () => {\n        subscribers.delete(func)\n      }\n    },\n    getState: () => state\n  }\n}\n```\n\nAyé, le mécanisme est en place.\n\n## 3. Combiner les reducers\n\nMaintenant ce qui serait pas mal, ce serait de permettre d'avoir plusieurs reducers, afin de pouvoir les découper et d'éviter d'avoir du gros code bloated qui tâche. Pour ce faire, on va créer la fonction `combineReducers` qui va prendre un objet contenant des reducers, et transformer ça en un seul reducer qui va retourner un objet de la même forme, avec l'état retourné par le reducer de la même clé.\n\n```javascript\nconst combineReducers = (reducers) => {\n  const reducersKeys = Object.keys(reducers)\n  return (state = {}, action) => {\n    return reducersKeys.reduce((acc, key) => {\n      acc[key] = reducers[key](state[key], action)\n      return acc\n    }, {})\n  }\n}\n```\n\nMaintenant, on peut bien séparer ses reducers :\n\n```javascript\nimport { users } from \"./reducers/user\"\nimport { tweets } from \"./reducers/tweets\"\n\nconst reducer = combineReducers({\n  users,\n  tweets,\n})\n\nconst store = createStore(reducer)\n```\n\n## 4. Permettre l'ajout de middlewares\n\nLes middlewares apportent toute la liberté de personalisation de Redux. L'un des plus populaires est le [*thunk middleware*](https://github.com/gaearon/redux-thunk), qui permet de passer une fonction à la place d'une action, et de dispatcher depuis cette fonction, ce qui peut s'avérer très utile pour gérer des réponses asynchrones.\n\nOn va donc créer une fonction `applyMiddleware`, qui va enrichir un store en ajoutant une sorte de hook sur sa méthode dispatch.\n\n```javascript\n// compose(a, b, c) équivaut à (...args) => a(b(c(...args)))\nconst compose = (...funcs) => {\n  const last = funcs[funcs.length - 1]\n  const rest = funcs.slice(0, -1)\n  return (...args) => rest.reduceRight((composed, f) => f(composed), last(...args))\n}\n\nconst applyMiddleware = (...middlewares) => {\n  return (store) => {\n    // cette API sera passée à chaque middleware, afin qu'il puisse récupérer\n    // l'état en cours et dispatcher des actions\n    const middlewareAPI = {\n      getState: store.getState,\n      dispatch: (action) => dispatch(action)\n    }\n    const chain = middlewares.map((middleware) => middleware(middlewareAPI))\n    let dispatch = compose(...chain)(store.dispatch)\n    return {\n      ...store,\n      dispatch,\n    }\n  }\n}\n```\n\n> NOTE: l'API de Redux prend `createStore` plutôt que `store` en paramètre, la différence est volontaire dans cette démarche de simplification\n\nVoilà, maintenant on peut faire\n\n```javascript\nconst thunk = ({ dispatch, getState }) => (next) => (action) => {\n  if (typeof action === \"function\") {\n    return action(dispatch, getState)\n  }\n  return next(action)\n}\n\nconst store = applyMiddleware(thunk)(createStore(reducer))\n\n// et maintenant on peut faire\nstore.dispatch((dispatch, getState) => {\n  dispatch({ type: \"FOO\" })\n  setTimeout(() => {\n    dispatch({ type: \"BAR\" })\n  })\n})\n```\n\nVoilà voilà, j'espère que cet article a pu vous éclairer un petit peu sur le fonctionnement de Redux et vous permettra de l'aborder avec plus de serénité.\n\nZoub'\n","__filename":"fr/articles/js/redux/index.md","__url":"/fr/articles/js/redux/","__resourceUrl":"/fr/articles/js/redux/index.html","__dataUrl":"/fr/articles/js/redux/index.html.81262574971394c269221406d425c15a.json"}