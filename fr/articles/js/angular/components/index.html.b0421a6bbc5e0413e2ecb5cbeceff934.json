{"head":{"layout":"Post","comments":true,"date":"2016-04-12","title":"Angular 1.5 : un pas de plus vers les web-components","tags":["javascript","angular","web-component"],"authors":["Freezystem"],"description":"Ce post a été écrit à la lumière du  changelog d'Angular 1.5.0 rc1.   Toutes information est succeptible d'évoluer au cours des…"},"body":"<p>Ce post a été écrit à la lumière du\n<a href=\"https://github.com/angular/angular.js/blob/master/CHANGELOG.md#150-rc1-quantum-fermentation-2016-01-15\">changelog d'Angular 1.5.0 rc1</a>.<br>\nToutes information est succeptible d'évoluer au cours des publications de\nnouvelles versions du framework.</p>\n<h2 id=\"le-petit-nouveau--component\"><a href=\"#le-petit-nouveau--component\" class=\"phenomic-HeadingAnchor\">#</a>Le petit nouveau : <code>.component()</code></h2>\n<p>Avec l'arrivée imminente de la version 2, Angular commence lentement à préparer la\ntransition et apporte de nombreux changements à la v1 pour tenter de\ncombler l'écart entre les deux et rendre les changements moins pénibles.  </p>\n<p>On voit donc progressivement apparaitre de nouvelles fonctionnalités comme :</p>\n<ul>\n<li><del>un <a href=\"https://angular.github.io/router/\">nouveau router</a> ?</del> </li>\n<li>la possibilité d'<a href=\"https://docs.angularjs.org/api/ngResource/service/$resource#cancelling-requests\">annuler une resource</a></li>\n<li>les transclusions multiples</li>\n<li>la compilation paresseuse des transclusions</li>\n</ul>\n<p>Mais le point qui nous intéresse particulièrement ici n'est autre que\nle nouveau <em>helper</em> permettant la déclaration de similis\n<a href=\"https://fr.wikipedia.org/wiki/Composants_web\">composants web</a>, aka web-components.</p>\n<p>Les habitués connaissaient déjà <a href=\"https://docs.angularjs.org/api/ng/service/$compile\"><code>angular.directive()</code></a>,\nun <em>helper</em> permettant la déclaration de composants réutilisables.\n<code>angular.directive()</code> s'est donc enrichi au cours des années en faisant un atout\nincontournable du framework de par sa flexibilité et sa simplicité.  </p>\n<p>Mais toutes ces possibilités de déclaration n'étaient plus vraiment en phase avec\nles spécifications du W3C, <code>angular.component()</code> se présente donc un retour aux sources.</p>\n<h2 id=\"de-directive-à-component\"><a href=\"#de-directive-%C3%A0-component\" class=\"phenomic-HeadingAnchor\">#</a>De <code>.directive()</code> à <code>.component()</code></h2>\n<p>Pour comprendre à quoi on arrive, il faut savoir de quoi on est parti.\nDe toute évidence vous ne pourrez pas transformer toutes vos vieilles directives\nen composants web, du moins, pas sans compromis. </p>\n<p>Pour rappel une directive Angular est définie par un objet JavaScript pouvant comporter\nles attributs suivants :</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">var</span> directiveObj = {\n  <span class=\"hljs-attr\">template</span>          : <span class=\"hljs-string\">'&#x3C;div>&#x3C;/div>'</span>,\n  <span class=\"hljs-attr\">transclude</span>        : <span class=\"hljs-literal\">false</span>,\n  <span class=\"hljs-attr\">restrict</span>          : <span class=\"hljs-string\">'EA'</span>,\n  <span class=\"hljs-attr\">scope</span>             : <span class=\"hljs-literal\">false</span>,\n  <span class=\"hljs-attr\">bindToController</span>  : <span class=\"hljs-literal\">false</span>,\n  <span class=\"hljs-attr\">controller</span>        : <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>{ },\n  <span class=\"hljs-attr\">controllerAs</span>      : <span class=\"hljs-string\">'stringIdentifier'</span>,\n}</code></pre>\n<h3 id=\"restriction-à-la-forme-élémentaire\"><a href=\"#restriction-%C3%A0-la-forme-%C3%A9l%C3%A9mentaire\" class=\"phenomic-HeadingAnchor\">#</a>Restriction à la forme élémentaire</h3>\n<p>Ceux qui utilisent les directives Angular de manière régulière ne sont pas sans savoir\nqu'il est possible de les instancier de 4 manières différentes dans son HTML en\nmodifiant l'attribut <code>restrict</code> :</p>\n<ul>\n<li>comme un élément avec <code>restrict : 'E'</code></li>\n<li>comme un attribut avec <code>restrict : 'A'</code></li>\n<li>comme une classe avec <code>restrict : 'C'</code> (déconseillé)</li>\n<li>comme un commentaire avec <code>restrict : 'M'</code> (fortement déconseillé)</li>\n</ul>\n<p>On peut aussi autoriser l'utilisation mixe en combinant les lettres : <code>restrict : 'EAC'</code></p>\n<p><code>restrict</code> n'est donc plus configurable et est restreint <em>(sans mauvais jeu de mot)</em>\nà la forme <code>'E'</code> en faisant un composant de façon claire.</p>\n<h3 id=\"isolement-du-scope\"><a href=\"#isolement-du-scope\" class=\"phenomic-HeadingAnchor\">#</a>Isolement du scope</h3>\n<p>Contrairement à <code>.directive()</code>, <code>.component()</code> force l'isolement du scope,\nainsi on colle à la specification : le composant web est agnostique du contexte.</p>\n<p>l'attribut <code>scope</code> est donc forcé à <code>{}</code> et n'est plus configurable.</p>\n<h3 id=\"passage-de-paramètres-via-bindings\"><a href=\"#passage-de-param%C3%A8tres-via-bindings\" class=\"phenomic-HeadingAnchor\">#</a>Passage de paramètres via <code>bindings</code></h3>\n<p>La propriété <code>scope</code> n'étant plus disponible <code>component</code>. Il faut à présent utiliser la propriété <code>bindings</code>. La syntaxe de celle-ci est équivalent à celle de la propriété <code>scope</code>. Mais les éléments passés sont automatiquement attachés à l'instance du contrôleur lié au <code>component</code>.</p>\n<p>Notons, que s'il reste possible d'utiliser la syntaxe <code>=</code> (two-way data binding), celle-ci est déconseillée au profit de la syntaxe <code>&#x3C;</code> (one-way data binding).</p>\n<h3 id=\"utilisation-forcée-de-controlleras\"><a href=\"#utilisation-forc%C3%A9e-de-controlleras\" class=\"phenomic-HeadingAnchor\">#</a>Utilisation <em>forcée</em> de <code>controllerAs</code></h3>\n<p>Déjà présenté comme une <em><a href=\"https://toddmotto.com/digging-into-angulars-controller-as-syntax/\">best practice</a></em>,\n<code>controllerAs</code> fait son chemin de manière évidente jusqu'au nouveau <em>helper</em>\n<code>.component()</code> son utilisation va de pair avec celle de <code>bindings</code>.</p>\n<p>L'attribut, qui prend une chaine de caractères pour valeur, est à présent facultatif.\nS'il est omit le controller est automatiquement aliassé par l'objet <code>$ctrl</code>.</p>\n<h2 id=\"exemple-de-migration\"><a href=\"#exemple-de-migration\" class=\"phenomic-HeadingAnchor\">#</a>Exemple de migration</h2>\n<p>Prenons l'exemple d'une directive simple et transformons la en composant Angular pour\nmettre en évidence l'ensemble des changements :</p>\n<pre><code class=\"hljs language-html\"><span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">hello-world</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">\"World\"</span>></span><span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">hello-world</span>></span></code></pre>\n<p>La syntaxe <em>directive</em> :</p>\n<pre><code class=\"hljs language-js\">angular.directive(<span class=\"hljs-string\">'helloWorld'</span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">helloWorld</span> (<span class=\"hljs-params\"></span>) </span>{\n  <span class=\"hljs-keyword\">return</span> {\n    <span class=\"hljs-attr\">restrict</span>          : <span class=\"hljs-string\">'E'</span>,\n    <span class=\"hljs-attr\">scope</span>             : {},\n    <span class=\"hljs-attr\">bindToController</span>  : {\n      <span class=\"hljs-attr\">name</span> : <span class=\"hljs-string\">'@'</span>\n    },\n    <span class=\"hljs-attr\">controller</span>        : <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">helloWorldCtrl</span> (<span class=\"hljs-params\"></span>) </span>{\n      <span class=\"hljs-keyword\">this</span>.logName = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>{\n        <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-keyword\">this</span>.name);\n      }\n    },\n    <span class=\"hljs-attr\">controllerAs</span>      : <span class=\"hljs-string\">'hw'</span>,\n    <span class=\"hljs-attr\">template</span>          : <span class=\"hljs-string\">'&#x3C;div>&#x3C;span ng-click=\"hw.logName()\">Hello {{hw.name}}!&#x3C;/span>&#x3C;/div>'</span>\n  }\n});</code></pre>\n<p>La syntaxe <em>component</em> :</p>\n<pre><code class=\"hljs language-js\">angular.component(<span class=\"hljs-string\">'helloWorld'</span>, {\n  <span class=\"hljs-attr\">bindings</span>: {\n    <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">'@'</span>\n  },\n  <span class=\"hljs-attr\">controller</span> : <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">helloWorldCtrl</span> (<span class=\"hljs-params\"></span>) </span>{\n    <span class=\"hljs-keyword\">this</span>.logName = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>{\n      <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-keyword\">this</span>.name);\n    }\n  },\n  <span class=\"hljs-attr\">template</span> : <span class=\"hljs-string\">'&#x3C;div>&#x3C;span ng-click=\"$ctrl.logName()\">Hi {{$ctrl.name}}!&#x3C;/span>&#x3C;/div>'</span>\n});</code></pre>\n<p>Les changements sont légers mais permettent une lecture améliorée des attributs.\nLe composant est donc une version simplifiée de la directive, plus en phase avec\nla logique d'Angular 2.</p>\n<p>Ce nouveau <em>helper</em> permet donc l'introduction progressive des <em>web-components</em> au\nsein d'Angular en vue de leur intégration et utilisation active dans la version 2.</p>\n","rawBody":"\nCe post a été écrit à la lumière du \n[changelog d'Angular 1.5.0 rc1](https://github.com/angular/angular.js/blob/master/CHANGELOG.md#150-rc1-quantum-fermentation-2016-01-15).  \nToutes information est succeptible d'évoluer au cours des publications de \nnouvelles versions du framework.\n\n## Le petit nouveau : `.component()`\n\nAvec l'arrivée imminente de la version 2, Angular commence lentement à préparer la\ntransition et apporte de nombreux changements à la v1 pour tenter de \ncombler l'écart entre les deux et rendre les changements moins pénibles.  \n\nOn voit donc progressivement apparaitre de nouvelles fonctionnalités comme :\n - ~~un [nouveau router](https://angular.github.io/router/) ?~~ \n - la possibilité d'[annuler une resource](https://docs.angularjs.org/api/ngResource/service/$resource#cancelling-requests)\n - les transclusions multiples\n - la compilation paresseuse des transclusions\n\nMais le point qui nous intéresse particulièrement ici n'est autre que \nle nouveau _helper_ permettant la déclaration de similis \n[composants web](https://fr.wikipedia.org/wiki/Composants_web), aka web-components.\n\nLes habitués connaissaient déjà [`angular.directive()`](https://docs.angularjs.org/api/ng/service/$compile), \nun _helper_ permettant la déclaration de composants réutilisables. \n`angular.directive()` s'est donc enrichi au cours des années en faisant un atout \nincontournable du framework de par sa flexibilité et sa simplicité.  \n\nMais toutes ces possibilités de déclaration n'étaient plus vraiment en phase avec \nles spécifications du W3C, `angular.component()` se présente donc un retour aux sources.\n\n## De `.directive()` à `.component()`\n\nPour comprendre à quoi on arrive, il faut savoir de quoi on est parti.\nDe toute évidence vous ne pourrez pas transformer toutes vos vieilles directives\nen composants web, du moins, pas sans compromis. \n\nPour rappel une directive Angular est définie par un objet JavaScript pouvant comporter\nles attributs suivants :\n\n```js\nvar directiveObj = {\n  template          : '<div></div>',\n  transclude        : false,\n  restrict          : 'EA',\n  scope             : false,\n  bindToController  : false,\n  controller        : function () { },\n  controllerAs      : 'stringIdentifier',\n}\n```\n\n### Restriction à la forme élémentaire\n\nCeux qui utilisent les directives Angular de manière régulière ne sont pas sans savoir \nqu'il est possible de les instancier de 4 manières différentes dans son HTML en\nmodifiant l'attribut `restrict` :\n - comme un élément avec `restrict : 'E'`\n - comme un attribut avec `restrict : 'A'`\n - comme une classe avec `restrict : 'C'` (déconseillé)\n - comme un commentaire avec `restrict : 'M'` (fortement déconseillé)\n\nOn peut aussi autoriser l'utilisation mixe en combinant les lettres : `restrict : 'EAC'`\n\n`restrict` n'est donc plus configurable et est restreint _(sans mauvais jeu de mot)_ \nà la forme `'E'` en faisant un composant de façon claire.\n\n### Isolement du scope\n\nContrairement à `.directive()`, `.component()` force l'isolement du scope, \nainsi on colle à la specification : le composant web est agnostique du contexte.\n\nl'attribut `scope` est donc forcé à `{}` et n'est plus configurable.\n\n### Passage de paramètres via `bindings`\n\nLa propriété `scope` n'étant plus disponible `component`. Il faut à présent utiliser la propriété `bindings`. La syntaxe de celle-ci est équivalent à celle de la propriété `scope`. Mais les éléments passés sont automatiquement attachés à l'instance du contrôleur lié au `component`.\n\nNotons, que s'il reste possible d'utiliser la syntaxe `=` (two-way data binding), celle-ci est déconseillée au profit de la syntaxe `<` (one-way data binding).\n\n### Utilisation _forcée_ de `controllerAs`\n\nDéjà présenté comme une _[best practice](https://toddmotto.com/digging-into-angulars-controller-as-syntax/)_,\n`controllerAs` fait son chemin de manière évidente jusqu'au nouveau _helper_ \n`.component()` son utilisation va de pair avec celle de `bindings`.\n\nL'attribut, qui prend une chaine de caractères pour valeur, est à présent facultatif. \nS'il est omit le controller est automatiquement aliassé par l'objet `$ctrl`.\n\n## Exemple de migration\n\nPrenons l'exemple d'une directive simple et transformons la en composant Angular pour\nmettre en évidence l'ensemble des changements :\n\n```html\n<hello-world name=\"World\"></hello-world>\n```\n\nLa syntaxe _directive_ :\n\n```js\nangular.directive('helloWorld', function helloWorld () {\n  return {\n    restrict          : 'E',\n    scope             : {},\n    bindToController  : {\n      name : '@'\n    },\n    controller        : function helloWorldCtrl () {\n      this.logName = function () {\n        console.log(this.name);\n      }\n    },\n    controllerAs      : 'hw',\n    template          : '<div><span ng-click=\"hw.logName()\">Hello {{hw.name}}!</span></div>'\n  }\n});\n```\n\nLa syntaxe _component_ :\n\n```js\nangular.component('helloWorld', {\n  bindings: {\n    name: '@'\n  },\n  controller : function helloWorldCtrl () {\n    this.logName = function () {\n      console.log(this.name);\n    }\n  },\n  template : '<div><span ng-click=\"$ctrl.logName()\">Hi {{$ctrl.name}}!</span></div>'\n});\n```\n\nLes changements sont légers mais permettent une lecture améliorée des attributs.\nLe composant est donc une version simplifiée de la directive, plus en phase avec \nla logique d'Angular 2.\n\nCe nouveau _helper_ permet donc l'introduction progressive des _web-components_ au\nsein d'Angular en vue de leur intégration et utilisation active dans la version 2.\n","__filename":"fr/articles/js/angular/components/index.md","__url":"/fr/articles/js/angular/components/","__resourceUrl":"/fr/articles/js/angular/components/index.html","__dataUrl":"/fr/articles/js/angular/components/index.html.b0421a6bbc5e0413e2ecb5cbeceff934.json"}