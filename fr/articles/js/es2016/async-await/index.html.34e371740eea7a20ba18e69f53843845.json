{"head":{"layout":"Post","comments":true,"date":"2015-12-14","title":"ES2016 (?): fonctions asynchrones (async/await)","tags":["JavaScript","ES2016"],"authors":["naholyr"],"description":"Aujourd'hui, une fonctionnalité peut-être abusivement taggée \"ES6\" puisqu'elle ne fait pas partie des propositions acceptées cette année :…"},"body":"<p>Aujourd'hui, une fonctionnalité peut-être abusivement taggée \"ES6\" puisqu'elle ne\nfait pas partie des propositions acceptées cette année : les fonctions asynchrones (async/await).\nLa <a href=\"https://tc39.github.io/ecmascript-asyncawait/\">spécification</a> est encore au\nstade 3 (candidate) à l'heure de cet article. Mais il ne fait plus aucun doute\nqu'elle (ou une variante) fera partie de la spécification ES2016.</p>\n<h2 id=\"fonctions-asynchrones\"><a href=\"#fonctions-asynchrones\" class=\"phenomic-HeadingAnchor\">#</a>Fonctions asynchrones</h2>\n<p>Pour les traitements asynchrones, vous connaissez déjà\n<a href=\"/fr/articles/js/es2015/promises/\">les promesses</a> qui ont\névidemment remplacé les callbacks dans votre code. Si vous n'avez pas déjà fait\nla bascule vers les promesses (ne serait-ce que pour la propagation d'erreur),\n<a href=\"/fr/articles/js/es2015/generators/\">les générateurs</a> ont\ndû finir de vous convaincre grâce aux <a href=\"/fr/articles/js/es2015/generators/#use-case-co-routines\">coroutines</a>.</p>\n<p>Nous allons voir aujourd'hui une nouvelle manière de traiter les fonctions\nasynchrones. Mais ne jetez pas vos promesses, tout tourne encore autour d'elles.</p>\n<h2 id=\"exemple-de-traitement-asynchrone-promise\"><a href=\"#exemple-de-traitement-asynchrone-promise\" class=\"phenomic-HeadingAnchor\">#</a>Exemple de traitement asynchrone : Promise</h2>\n<p>Partons du programme suivant exécuté le\n6 décembre dernier dont l'API est basée sur les promesses :</p>\n<ul>\n<li>Il récupère tous les utilisateurs prénommés Nicolas</li>\n<li>Il envoie un mail à chacun pour souhaiter bonne fête</li>\n</ul>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">sendEmails</span> (<span class=\"hljs-params\">query</span>) </span>{\n  <span class=\"hljs-keyword\">const</span> usersP = getUsers(query)\n  <span class=\"hljs-comment\">// On récupère le champ \"email\" de tous les utilisateurs</span>\n  <span class=\"hljs-keyword\">const</span> emailsP = usersP.then(<span class=\"hljs-function\">(<span class=\"hljs-params\">users</span>) =></span> users.map(<span class=\"hljs-function\"><span class=\"hljs-params\">u</span> =></span> u.email))\n  <span class=\"hljs-comment\">// Pour chaque email…</span>\n  <span class=\"hljs-keyword\">const</span> sentP = emailsP.then(<span class=\"hljs-function\">(<span class=\"hljs-params\">emails</span>) =></span> emails.map(<span class=\"hljs-function\">(<span class=\"hljs-params\">email</span>) =></span> {\n    <span class=\"hljs-comment\">// … on envoie un mail</span>\n    <span class=\"hljs-keyword\">return</span> sendMail(email, <span class=\"hljs-string\">'Bonne fête'</span>)\n  }))\n  <span class=\"hljs-comment\">// On attend que tous les envois soient résolus</span>\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">Promise</span>.all(sentP)\n}\n\nsendEmails({ <span class=\"hljs-attr\">firstName</span>: <span class=\"hljs-string\">'Nicolas'</span> })\n  .then(<span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =></span> <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'OK'</span>))\n  .catch(<span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =></span> <span class=\"hljs-built_in\">console</span>.error(<span class=\"hljs-string\">'FAIL'</span>))</code></pre>\n<h2 id=\"nouveaux-mot-clés-async-et-await\"><a href=\"#nouveaux-mot-cl%C3%A9s-async-et-await\" class=\"phenomic-HeadingAnchor\">#</a>Nouveaux mot-clés <code>async</code> et <code>await</code></h2>\n<p>Une fonction peut être marquée comme asynchrone lorsque préfixée par <code>async</code> :</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">async</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">myFunction</span> (<span class=\"hljs-params\"></span>) </span>{\n  <span class=\"hljs-comment\">// …</span>\n}</code></pre>\n<p>Dans une fonction asynchrone, et <strong>seulement</strong> dans une fonction asynchrone, le\nmot-clé <code>await</code> devient disponible. Lorsqu'il est utilisé en préfixe d'une\npromesse, l'évaluation de l'expression est \"mise en pause\" jusqu'à la résolution\n(ou le rejet) de la promesse :</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">async</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">myFunction</span> (<span class=\"hljs-params\"></span>) </span>{\n  <span class=\"hljs-keyword\">await</span> aPromise\n  <span class=\"hljs-comment\">// on n'arrivera à cette ligne que lorsque \"aPromise\" sera résolue</span>\n}</code></pre>\n<p>Évidemment, l'expression a alors pour valeur celle de résolution de la\npromesse, et en cas d'erreur l'expression va lever (<code>throw</code>) une erreur :</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">async</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">myFunction</span> (<span class=\"hljs-params\"></span>) </span>{\n  <span class=\"hljs-keyword\">try</span> {\n    <span class=\"hljs-keyword\">const</span> result = <span class=\"hljs-keyword\">await</span> aPromise\n    <span class=\"hljs-comment\">// Ici \"aPromise\" est résolue avec la valeur \"result\"</span>\n  } <span class=\"hljs-keyword\">catch</span> (err) {\n    <span class=\"hljs-comment\">// Ici \"aPromise\" est rejetée avec l'erreur \"err\"</span>\n  }\n\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">42</span> <span class=\"hljs-comment\">// cette ligne n'est atteinte qu'après résolution/rejet</span>\n}</code></pre>\n<p>Concrètement, si vous vous souvenez de l'article sur les générateurs et de la\npartie sur les coroutines, remplacez <code>async function</code> par <code>function *</code> et\n<code>await</code> par <code>yield</code>, et vous avez compris le principe. ;)</p>\n<h2 id=\"notre-premier-exemple-avec-les-fonctions-asynchrones\"><a href=\"#notre-premier-exemple-avec-les-fonctions-asynchrones\" class=\"phenomic-HeadingAnchor\">#</a>Notre premier exemple, avec les fonctions asynchrones</h2>\n<p>Réécrivons notre premier exemple avec des fonctions asynchrones :</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">async</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">sendEmails</span> (<span class=\"hljs-params\">query</span>) </span>{\n  <span class=\"hljs-keyword\">const</span> users = <span class=\"hljs-keyword\">await</span> getUsers(query)\n  <span class=\"hljs-keyword\">const</span> emails = users.map(<span class=\"hljs-function\"><span class=\"hljs-params\">u</span> =></span> u.email)\n  <span class=\"hljs-keyword\">const</span> sentP = emails.map(<span class=\"hljs-function\">(<span class=\"hljs-params\">email</span>) =></span> sendMail(email, <span class=\"hljs-string\">'Bonne fête'</span>))\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">await</span> <span class=\"hljs-built_in\">Promise</span>.all(sentP)\n}\n\n<span class=\"hljs-comment\">// Attention, on ne peut pas utiliser \"await\" hors d'une fonction \"async\"</span>\n<span class=\"hljs-comment\">// il faut donc \"wrapper\" notre code autour d'une fonction asynchrone</span>\n<span class=\"hljs-keyword\">async</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">main</span> (<span class=\"hljs-params\"></span>) </span>{\n  <span class=\"hljs-keyword\">try</span> {\n    <span class=\"hljs-keyword\">await</span> sendEmails({ <span class=\"hljs-attr\">firstName</span>: <span class=\"hljs-string\">'Nicolas'</span> })\n    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'OK'</span>)\n  } <span class=\"hljs-keyword\">catch</span> (e) {\n    <span class=\"hljs-built_in\">console</span>.error(<span class=\"hljs-string\">'FAIL'</span>)\n  }\n}\n\nmain()</code></pre>\n<p>Mieux ? Moins bien ? Question de goût, mais on retrouve un code impératif plus\nhabituel.</p>\n<h2 id=\"attention-au-piège-de-lexécution-en-série\"><a href=\"#attention-au-pi%C3%A8ge-de-lex%C3%A9cution-en-s%C3%A9rie\" class=\"phenomic-HeadingAnchor\">#</a>Attention au piège de l'exécution en série !</h2>\n<p>Prenons l'exemple de requêtes qu'on exécute en concurrence avant d'utiliser\nleurs résultats :</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> xP = getX() <span class=\"hljs-comment\">// Requête Ajax</span>\n<span class=\"hljs-keyword\">const</span> yP = getY() <span class=\"hljs-comment\">// Requête BDD</span>\n<span class=\"hljs-keyword\">const</span> resultP = <span class=\"hljs-built_in\">Promise</span>.all([xP, yP]).then(sum)</code></pre>\n<p>Dans cet exemple, les requêtes sont lancées, exécutées en parallèle puis leurs\nretours attendus avant de passer à la suite.</p>\n<p>Si on le traduit bêtement ainsi, on perd l'aspect concurrentiel :</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> x = <span class=\"hljs-keyword\">await</span> getX() <span class=\"hljs-comment\">// Requête Ajax…</span>\n<span class=\"hljs-comment\">// … requête terminée !</span>\n<span class=\"hljs-keyword\">const</span> y = <span class=\"hljs-keyword\">await</span> getY() <span class=\"hljs-comment\">// Requête BDD…</span>\n<span class=\"hljs-comment\">// … requête terminée !</span>\n<span class=\"hljs-keyword\">const</span> result = sum([x, y])</code></pre>\n<p>Il faudra bien distinguer le moment où on souhaite <strong>démarrer l'action</strong> et le\nmoment où l'on souhaite <strong>disposer de son résultat</strong>, il y a plusieurs manières\nde résoudre le problème, qui dépendent essentiellement du goût du développeur ;)</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> xP = getX() <span class=\"hljs-comment\">// Requête Ajax démarrée…</span>\n<span class=\"hljs-keyword\">const</span> yP = getY() <span class=\"hljs-comment\">// Requête BDD démarrée…</span>\n\n<span class=\"hljs-comment\">// Version 1 :</span>\n<span class=\"hljs-keyword\">const</span> x = <span class=\"hljs-keyword\">await</span> xP <span class=\"hljs-comment\">// …requête Ajax terminée !</span>\n<span class=\"hljs-keyword\">const</span> y = <span class=\"hljs-keyword\">await</span> yP <span class=\"hljs-comment\">// …requête BDD terminée !</span>\n<span class=\"hljs-keyword\">const</span> result = sum([x, y])\n\n<span class=\"hljs-comment\">// Version 2 avec un tableau :</span>\n<span class=\"hljs-keyword\">const</span> vars = [<span class=\"hljs-keyword\">await</span> xP, <span class=\"hljs-keyword\">await</span> yP]\n<span class=\"hljs-keyword\">const</span> result = sum(vars)\n\n<span class=\"hljs-comment\">// Version 3 avec Promise.all :</span>\n<span class=\"hljs-keyword\">const</span> vars = <span class=\"hljs-keyword\">await</span> <span class=\"hljs-built_in\">Promise</span>.all([xP, yP])\n<span class=\"hljs-keyword\">const</span> result = sum(vars)</code></pre>\n<h2 id=\"et-aujourdhui\"><a href=\"#et-aujourdhui\" class=\"phenomic-HeadingAnchor\">#</a>Et aujourd'hui ?</h2>\n<p>On peut utiliser Babel pour compiler son code utilisant <code>async/await</code> en un\ncode basé sur les générateurs : il vous suffira d'ajouter les plugins Babel\n<code>syntax-async-functions</code> et <code>transform-async-to-generator</code> (attention à\ninclure <code>babel-polyfill</code> en fichier d'entrée).</p>\n<h2 id=\"conclusion\"><a href=\"#conclusion\" class=\"phenomic-HeadingAnchor\">#</a>Conclusion</h2>\n<p>Grâce aux fonctions asynchrones, la refactorisation d'un code bloquant vers un\ncode non bloquant devient vraiment aisée. Les promesses simplifiaient déjà le\nprocessus mais on n'était pas débarassé des callbacks. Là, à deux mot-clés près,\nc'est exactement la même chose !</p>\n<p>D'un certain côté, c'est un retour en arrière : l'asynchrone mène aux promesses,\nqui mènent à la programmation fonctionnelle, qui apporte tant de bienfaits… Il\ns'agira de trouver le bon équilibre, je ne suis pas convaincu d'abandonner mes\n<code>.then</code> tout de suite, mais il est certain que c'est une véritable avancée\npour ce langage : la courbe d'apprentissage des traitements asynchrones va être\ndrastiquement aplanie ;)</p>\n","rawBody":"\nAujourd'hui, une fonctionnalité peut-être abusivement taggée \"ES6\" puisqu'elle ne\nfait pas partie des propositions acceptées cette année : les fonctions asynchrones (async/await).\nLa [spécification](https://tc39.github.io/ecmascript-asyncawait/) est encore au\nstade 3 (candidate) à l'heure de cet article. Mais il ne fait plus aucun doute\nqu'elle (ou une variante) fera partie de la spécification ES2016.\n\n## Fonctions asynchrones\n\nPour les traitements asynchrones, vous connaissez déjà\n[les promesses](/fr/articles/js/es2015/promises/) qui ont\névidemment remplacé les callbacks dans votre code. Si vous n'avez pas déjà fait\nla bascule vers les promesses (ne serait-ce que pour la propagation d'erreur),\n[les générateurs](/fr/articles/js/es2015/generators/) ont\ndû finir de vous convaincre grâce aux [coroutines](/fr/articles/js/es2015/generators/#use-case-co-routines).\n\nNous allons voir aujourd'hui une nouvelle manière de traiter les fonctions\nasynchrones. Mais ne jetez pas vos promesses, tout tourne encore autour d'elles.\n\n## Exemple de traitement asynchrone : Promise\n\nPartons du programme suivant exécuté le\n6 décembre dernier dont l'API est basée sur les promesses :\n\n* Il récupère tous les utilisateurs prénommés Nicolas\n* Il envoie un mail à chacun pour souhaiter bonne fête\n\n```js\nfunction sendEmails (query) {\n  const usersP = getUsers(query)\n  // On récupère le champ \"email\" de tous les utilisateurs\n  const emailsP = usersP.then((users) => users.map(u => u.email))\n  // Pour chaque email…\n  const sentP = emailsP.then((emails) => emails.map((email) => {\n    // … on envoie un mail\n    return sendMail(email, 'Bonne fête')\n  }))\n  // On attend que tous les envois soient résolus\n  return Promise.all(sentP)\n}\n\nsendEmails({ firstName: 'Nicolas' })\n  .then(() => console.log('OK'))\n  .catch(() => console.error('FAIL'))\n```\n\n## Nouveaux mot-clés ``async`` et ``await``\n\nUne fonction peut être marquée comme asynchrone lorsque préfixée par ``async`` :\n\n```js\nasync function myFunction () {\n  // …\n}\n```\n\nDans une fonction asynchrone, et **seulement** dans une fonction asynchrone, le\nmot-clé ``await`` devient disponible. Lorsqu'il est utilisé en préfixe d'une\npromesse, l'évaluation de l'expression est \"mise en pause\" jusqu'à la résolution\n(ou le rejet) de la promesse :\n\n```js\nasync function myFunction () {\n  await aPromise\n  // on n'arrivera à cette ligne que lorsque \"aPromise\" sera résolue\n}\n```\n\nÉvidemment, l'expression a alors pour valeur celle de résolution de la\npromesse, et en cas d'erreur l'expression va lever (``throw``) une erreur :\n\n```js\nasync function myFunction () {\n  try {\n    const result = await aPromise\n    // Ici \"aPromise\" est résolue avec la valeur \"result\"\n  } catch (err) {\n    // Ici \"aPromise\" est rejetée avec l'erreur \"err\"\n  }\n\n  return 42 // cette ligne n'est atteinte qu'après résolution/rejet\n}\n```\n\nConcrètement, si vous vous souvenez de l'article sur les générateurs et de la\npartie sur les coroutines, remplacez ``async function`` par ``function *`` et\n``await`` par ``yield``, et vous avez compris le principe. ;)\n\n## Notre premier exemple, avec les fonctions asynchrones\n\nRéécrivons notre premier exemple avec des fonctions asynchrones :\n\n```js\nasync function sendEmails (query) {\n  const users = await getUsers(query)\n  const emails = users.map(u => u.email)\n  const sentP = emails.map((email) => sendMail(email, 'Bonne fête'))\n  return await Promise.all(sentP)\n}\n\n// Attention, on ne peut pas utiliser \"await\" hors d'une fonction \"async\"\n// il faut donc \"wrapper\" notre code autour d'une fonction asynchrone\nasync function main () {\n  try {\n    await sendEmails({ firstName: 'Nicolas' })\n    console.log('OK')\n  } catch (e) {\n    console.error('FAIL')\n  }\n}\n\nmain()\n```\n\nMieux ? Moins bien ? Question de goût, mais on retrouve un code impératif plus\nhabituel.\n\n## Attention au piège de l'exécution en série !\n\nPrenons l'exemple de requêtes qu'on exécute en concurrence avant d'utiliser\nleurs résultats :\n\n```js\nconst xP = getX() // Requête Ajax\nconst yP = getY() // Requête BDD\nconst resultP = Promise.all([xP, yP]).then(sum)\n```\n\nDans cet exemple, les requêtes sont lancées, exécutées en parallèle puis leurs\nretours attendus avant de passer à la suite.\n\nSi on le traduit bêtement ainsi, on perd l'aspect concurrentiel :\n\n```js\nconst x = await getX() // Requête Ajax…\n// … requête terminée !\nconst y = await getY() // Requête BDD…\n// … requête terminée !\nconst result = sum([x, y])\n```\n\nIl faudra bien distinguer le moment où on souhaite **démarrer l'action** et le\nmoment où l'on souhaite **disposer de son résultat**, il y a plusieurs manières\nde résoudre le problème, qui dépendent essentiellement du goût du développeur ;)\n\n```js\nconst xP = getX() // Requête Ajax démarrée…\nconst yP = getY() // Requête BDD démarrée…\n\n// Version 1 :\nconst x = await xP // …requête Ajax terminée !\nconst y = await yP // …requête BDD terminée !\nconst result = sum([x, y])\n\n// Version 2 avec un tableau :\nconst vars = [await xP, await yP]\nconst result = sum(vars)\n\n// Version 3 avec Promise.all :\nconst vars = await Promise.all([xP, yP])\nconst result = sum(vars)\n```\n\n## Et aujourd'hui ?\n\nOn peut utiliser Babel pour compiler son code utilisant ``async/await`` en un\ncode basé sur les générateurs : il vous suffira d'ajouter les plugins Babel\n``syntax-async-functions`` et ``transform-async-to-generator`` (attention à\ninclure ``babel-polyfill`` en fichier d'entrée).\n\n## Conclusion\n\nGrâce aux fonctions asynchrones, la refactorisation d'un code bloquant vers un\ncode non bloquant devient vraiment aisée. Les promesses simplifiaient déjà le\nprocessus mais on n'était pas débarassé des callbacks. Là, à deux mot-clés près,\nc'est exactement la même chose !\n\nD'un certain côté, c'est un retour en arrière : l'asynchrone mène aux promesses,\nqui mènent à la programmation fonctionnelle, qui apporte tant de bienfaits… Il\ns'agira de trouver le bon équilibre, je ne suis pas convaincu d'abandonner mes\n``.then`` tout de suite, mais il est certain que c'est une véritable avancée\npour ce langage : la courbe d'apprentissage des traitements asynchrones va être\ndrastiquement aplanie ;)\n","__filename":"fr/articles/js/es2016/async-await.md","__url":"/fr/articles/js/es2016/async-await/","__resourceUrl":"/fr/articles/js/es2016/async-await/index.html","__dataUrl":"/fr/articles/js/es2016/async-await/index.html.34e371740eea7a20ba18e69f53843845.json"}