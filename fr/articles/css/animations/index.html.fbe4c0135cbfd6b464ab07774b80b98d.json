{"head":{"layout":"Post","comments":true,"date":"2016-12-20","title":"Petit tour d'horizon de l'animation sur le web (et ailleurs)","tags":["animation","css","easing","spring"],"authors":["bloodyowl"],"description":"Les animations prennent une grande place dans les interfaces utilisateur. Loin de n'apporter qu'un côté esthétique, elles augmentent la…"},"body":"<p>Les animations prennent une grande place dans les interfaces utilisateur. Loin de n'apporter qu'un côté esthétique, elles augmentent la performance perçue, améliorent notre expérience en nous aidant à nous repérer et en guidant notre attention. Sur les applications natives, ces animations sont souvent plus naturelles que sur le web, et pour cause, beaucoup de leurs animations sont des <em>springs</em>.</p>\n<p>Qu'est-ce qu'une animation <em>spring</em> ? Pour arriver à le définir, voyons comment on a l'habitude de créer des animations avec les technologies web.</p>\n<p>CSS possède deux propriétés permettant d'animer des valeurs: les <code>animation</code> et les <code>transition</code>. Au delà de la différence entre leurs capacités au sein de CSS (propriété VS ensemble de propriétés avec des étapes), les deux reposent sur le même mécanisme. On va donc étudier le plus simple: <code>transition</code>.</p>\n<pre><code class=\"hljs language-css\"><span class=\"hljs-selector-class\">.block</span> {\n  <span class=\"hljs-attribute\">transition</span>: <span class=\"hljs-number\">300ms</span> linear transform;\n}\n\n<span class=\"hljs-selector-class\">.block</span><span class=\"hljs-selector-pseudo\">:hover</span> {\n  <span class=\"hljs-attribute\">transform</span>: <span class=\"hljs-built_in\">scale</span>(1.05);\n}</code></pre>\n<p>Cette transition est définie sur un modèle simple : on fixe une durée d'animation (ici <code>300ms</code>) et un easing —<em>ou </em>zizine<em> si vous écoutez <a href=\"http://putaindecode.io/fr/articles/podcast/1/\">le podcast</a></em>— qui est une fonction d'interpolation (ici <code>linear</code>).</p>\n<p>L'easing est une fonction toute bête comme vous avez pu en voir au collège et les avez dessinées sur votre calculatrice Casio ou Texas (si comme moi vous étiez le seul péquin de la classe à avoir l'autre modèle, à devoir toujours se démerder parce que les profs savaient pas comment la vôtre marchait).</p>\n<p>Bref, une fonction d'easing est assez simple. Par exemple, la <code>linear</code> ça revient à :</p>\n<p><img src=\"./Linear.png\"></p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> linear = <span class=\"hljs-function\"><span class=\"hljs-params\">x</span> =></span> x <span class=\"hljs-comment\">// such complicated</span>\n    <span class=\"hljs-comment\">// didn't even import `lodash.identity` from npm</span></code></pre>\n<p>Le paramètre <code>x</code> varie entre <code>0</code> et <code>1</code>, c'est la progression de l'animation. Ce paramètre vaut <code>0</code> quand vous êtes au début de l'animation et <code>1</code> à la fin.</p>\n<p>En faisant à la main une version du système gérant l'animation, ça donne quelque chose dans ce style :</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> transition = <span class=\"hljs-function\">(<span class=\"hljs-params\">{ duration, easing, onUpdate, startValue, endValue }</span>) =></span> {\n  <span class=\"hljs-keyword\">const</span> startDate = <span class=\"hljs-built_in\">Date</span>.now() <span class=\"hljs-comment\">// le moment où commence l'animation</span>\n  <span class=\"hljs-comment\">// la fonction tick sera executée périodiquement</span>\n  <span class=\"hljs-keyword\">const</span> tick = <span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =></span> {\n    <span class=\"hljs-keyword\">const</span> absoluteProgress = (<span class=\"hljs-built_in\">Date</span>.now() - startDate) / duration <span class=\"hljs-comment\">// on calcule `x`</span>\n    <span class=\"hljs-keyword\">const</span> progress = <span class=\"hljs-built_in\">Math</span>.min(absoluteProgress, <span class=\"hljs-number\">1</span>) <span class=\"hljs-comment\">// on fait gaffe de pas déborder</span>\n    <span class=\"hljs-keyword\">const</span> progressWithEasing = easing(progress) <span class=\"hljs-comment\">// on applique la fonction d'easing</span>\n    <span class=\"hljs-comment\">// pour calculer la valeur, on diminue progressivement la valeur initiale et l'on accroit la valeur finale</span>\n    onUpdate((<span class=\"hljs-number\">1</span> - progressWithEasing) * startValue + progressWithEasing * endValue)\n    <span class=\"hljs-keyword\">if</span>(progress &#x3C; <span class=\"hljs-number\">1</span>) {\n      <span class=\"hljs-comment\">// si c'est pas fini, on repart pour un tour</span>\n      requestAnimationFrame(tick)\n    }\n  }\n  tick()\n}\n\n\nmyElement.onclick = <span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =></span> transition({\n  <span class=\"hljs-attr\">duration</span>: <span class=\"hljs-number\">500</span>,\n  <span class=\"hljs-attr\">easing</span>: <span class=\"hljs-function\"><span class=\"hljs-params\">x</span> =></span> x,\n  <span class=\"hljs-attr\">onUpdate</span>: <span class=\"hljs-function\">(<span class=\"hljs-params\">value</span>) =></span> myElement.style.transform = <span class=\"hljs-string\">`translateY(<span class=\"hljs-subst\">${ value + <span class=\"hljs-string\">\"px\"</span> }</span>)`</span>,\n  <span class=\"hljs-attr\">startValue</span>: <span class=\"hljs-number\">0</span>,\n  <span class=\"hljs-attr\">endValue</span>: <span class=\"hljs-number\">200</span>,\n})</code></pre>\n<p>Pour définir cette fonction d'easing, CSS vous permet également de configurer des courbes de Bézier cubiques.</p>\n<p>Une courbe de Bézier cubique se définit avec 4 points : <code>P0</code>, <code>P1</code>, <code>P2</code> et <code>P3</code>. Il en est ensuite dérivé une courbe à partir de ces quatre points. C'est avec ce mécanisme que fonctionne la plume de la plupart des logiciels d'édition d'image.  </p>\n<p><img src=\"./Bezier.png\"></p>\n<p>Vu que votre animation commence et finit à des valeurs définies à l'avance, deux points sont fixés à l'avance : <code>P0</code> sera toujours <code>(0, 0)</code> et <code>P3</code> <code>(1, 1)</code>.</p>\n<p>Vous avez avec CSS la liberté de définir <code>P1</code> et <code>P2</code> sous la forme <code>cubic-bezier(P1x, P1y, P2x, P2y)</code>. Pour visualiser le fonctionnement, je vous conseille de faire un tour sur <a href=\"http://cubic-bezier.com\">cubic-bezier</a> de <a href=\"https://twitter.com/leaverou\">Lea Verou</a>.</p>\n<p>Tout ce que nous avons vu jusque-là sont des animations <em>timées</em> (vive les anglicismes). Leur durée est connue à l'avance et est immuable, les variations possibles se feront dans les limites de ces contraintes.</p>\n<p>Ces animations sont très pratiques pour certaines animations basiques et rempliront très bien leur mission, mais elles peuvent rapidement avoir des limites :</p>\n<p>Avec CSS :</p>\n<ul>\n<li>On n'a aucun contrôle sur l'exécution de l'animation</li>\n<li>Configurer des animations complexes complique la maintenance</li>\n</ul>\n<p>Avec un easing basique en général :</p>\n<ul>\n<li><code>cubic-bezier</code> limite énormément les possibilités d'évolution de la valeur animée (e.g. on souhaite que l'animation ait de l'élasticité, les timing-functions ne permettent de faire qu'un seul débord qui ne parait pas \"naturel\").</li>\n<li>Avoir des animations cohérentes dans toute notre UI est extrêmement contraignant avec CSS</li>\n</ul>\n<p>Pour l'élasticité, vous pouvez vous débrouiller avec <code>@keyframes</code>, hardcoder toutes les valeurs, les <em>timer</em> à la main, y passer des heures pour vous retrouver avec 60 étapes dans votre animation et au final de ne pas être satisfait du résultat, claquer la porte de votre boulot et partir élever des brebis dans les Pyrénées.</p>\n<p>C'est là qu'interviennent les <em>springs</em>.</p>\n<p>Une animation spring vous expose en général deux paramètres : <code>tension</code> et <code>friction</code> (ou <code>stiffness</code>, pour rigidité &#x26; <code>damping</code>, pour amortissement, selon les systèmes). Ce sont des valeurs logiques dans ce contexte, puisqu'elles viennent des lois de la physique (big up Newton).</p>\n<p>Quelques exemples sur les <a href=\"http://facebook.github.io/rebound-js/examples/\">demos de Rebound.js</a> peuvent vous aider à visualiser ce que représentent ces paramètres au sein de l'animation.</p>\n<p>Afin d'obéir à des lois \"logiques\" de la physique, l'animation spring doit prendre en compte à chaque <code>tick</code> non seulement la valeur actuelle et celle d'arrivée mais aussi sa rapidité actuelle : c'est ce qui lui permet d'enchaîner naturellement les animations.</p>\n<p>À chaque frame, il va exécuter la fonction suivante pour déterminer la <code>value</code> et <code>velocity</code> à venir (note : ce côté est une simplification du code utilisé par <a href=\"https://github.com/chenglou/react-motion\">react-motion</a>).</p>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-keyword\">const</span> unitOfTime = <span class=\"hljs-number\">1</span> / <span class=\"hljs-number\">60</span> <span class=\"hljs-comment\">// the number of seconds in a frame</span>\n<span class=\"hljs-keyword\">const</span> precision = <span class=\"hljs-number\">0.01</span>\n\n<span class=\"hljs-keyword\">const</span> step = (\n  lastValue,\n  lastVelocity,\n  toValue,\n  stiffness,\n  damping\n) => {\n  <span class=\"hljs-keyword\">const</span> spring = -stiffness * (lastValue - toValue)\n  <span class=\"hljs-keyword\">const</span> damper = -damping * lastVelocity\n\n  <span class=\"hljs-keyword\">const</span> all = spring + damper\n  <span class=\"hljs-keyword\">const</span> nextVelocity = lastVelocity + all * unitOfTime\n  <span class=\"hljs-keyword\">const</span> nextValue = lastValue + nextVelocity * unitOfTime\n\n  <span class=\"hljs-keyword\">const</span> shouldRest = <span class=\"hljs-built_in\">Math</span>.abs(nextVelocity) &#x3C; precision &#x26;&#x26; <span class=\"hljs-built_in\">Math</span>.abs(nextValue - toValue) &#x3C; precision\n\n  <span class=\"hljs-keyword\">return</span> {\n    <span class=\"hljs-attr\">velocity</span>: shouldRest ? <span class=\"hljs-number\">0</span> : nextVelocity,\n    <span class=\"hljs-attr\">value</span>: shouldRest ? toValue : nextValue,\n  }\n}</code></pre>\n<p>Ensuite, une simple fonction <code>spring</code> qui reproduit à peu de choses près la mécanique de notre <code>createTransition</code> vu plus haut :</p>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-keyword\">const</span> spring = <span class=\"hljs-function\">(<span class=\"hljs-params\">{ stiffness = <span class=\"hljs-number\">180</span>, damping = <span class=\"hljs-number\">12</span>, onRest = ((</span>) =></span> {}), toValue }) => <span class=\"hljs-function\"><span class=\"hljs-params\">onUpdate</span> =></span> {\n  <span class=\"hljs-keyword\">let</span> frame\n  <span class=\"hljs-keyword\">const</span> tick = <span class=\"hljs-function\">(<span class=\"hljs-params\">curr</span>) =></span> {\n    <span class=\"hljs-comment\">// on calcule l'état</span>\n    <span class=\"hljs-keyword\">const</span> { velocity, value } = step(curr.value, curr.velocity, toValue, stiffness, damping)\n    onUpdate({ velocity, value })\n    <span class=\"hljs-comment\">// si l'animation n'est pas terminée</span>\n    <span class=\"hljs-keyword\">if</span>(velocity !== <span class=\"hljs-number\">0</span> || value !== toValue) {\n      <span class=\"hljs-comment\">// on programme la prochaine frame</span>\n      frame = requestAnimationFrame(<span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =></span> tick({ value, velocity }))\n    } <span class=\"hljs-keyword\">else</span> {\n      <span class=\"hljs-comment\">// sinon on prévient que l'animation est au repos</span>\n      onRest()\n    }\n  }\n  <span class=\"hljs-keyword\">return</span> {\n    <span class=\"hljs-comment\">// afin de permettre aux animations de s'enchaîner, la fonction `start` prend l'état actuel de la valeur</span>\n    start: <span class=\"hljs-function\">(<span class=\"hljs-params\">value</span>) =></span> {\n      frame = requestAnimationFrame(<span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =></span> tick(value))\n    },\n    <span class=\"hljs-attr\">stop</span>: <span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =></span> {\n      cancelAnimationFrame(frame)\n    },\n  }\n}</code></pre>\n<p>Il nous reste à créer une classe \"observable\" <code>Value</code> qui conserve l'état et l'animation active. Cela permet de stopper l'animation en cours avant de lancer la suivante lorsque cela arrive.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Value</span> </span>{\n  <span class=\"hljs-keyword\">constructor</span>(initialValue) {\n    <span class=\"hljs-keyword\">this</span>.value = {\n      <span class=\"hljs-attr\">value</span>: initialValue,\n      <span class=\"hljs-attr\">velocity</span>: <span class=\"hljs-number\">0</span>,\n    }\n    <span class=\"hljs-keyword\">this</span>.listeners = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Set</span>()\n    <span class=\"hljs-keyword\">this</span>.animation = <span class=\"hljs-literal\">null</span>\n  }\n  addListener(listener) {\n    <span class=\"hljs-keyword\">this</span>.listeners.add(listener)\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =></span> {\n      <span class=\"hljs-keyword\">this</span>.listeners.delete(listener)\n    }\n  }\n  updateValue(nextValue) {\n    <span class=\"hljs-keyword\">this</span>.value = nextValue\n    <span class=\"hljs-keyword\">this</span>.listeners.forEach(<span class=\"hljs-function\"><span class=\"hljs-params\">listener</span> =></span> listener(<span class=\"hljs-keyword\">this</span>.value.value))\n  }\n  animate(animation) {\n    <span class=\"hljs-keyword\">if</span>(<span class=\"hljs-keyword\">this</span>.animation) {\n      <span class=\"hljs-keyword\">this</span>.animation.stop()\n    }\n    <span class=\"hljs-keyword\">this</span>.animation = animation(<span class=\"hljs-function\">(<span class=\"hljs-params\">v</span>) =></span> <span class=\"hljs-keyword\">this</span>.updateValue(v))\n    <span class=\"hljs-keyword\">this</span>.animation.start(<span class=\"hljs-keyword\">this</span>.value)\n  }\n}</code></pre>\n<p>Et voilà, vous avez une animation :</p>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-keyword\">const</span> scale = <span class=\"hljs-keyword\">new</span> Value(<span class=\"hljs-number\">1</span>)\n\nscale.addListener(<span class=\"hljs-function\"><span class=\"hljs-params\">value</span> =></span> myElement.style.transform = <span class=\"hljs-string\">`scale(<span class=\"hljs-subst\">${ value }</span>)`</span>)\n\nmyElement.onmousedown = <span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =></span> {\n  scale.animate(spring({ <span class=\"hljs-attr\">toValue</span>: <span class=\"hljs-number\">2</span> }))\n}\n\nmyElement.onmouseup = <span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =></span> {\n  scale.animate(spring({ <span class=\"hljs-attr\">toValue</span>: <span class=\"hljs-number\">1</span> }))\n}</code></pre>\n<iframe width=\"100%\" height=\"300\" src=\"//jsfiddle.net/bloodyowl/36d0nc7r/embedded/\" allowfullscreen=\"allowfullscreen\" frameborder=\"0\"></iframe>\n<p>Les animations spring ont de nombreux avantages. Elles vous permettent d'utiliser un vocabulaire cohérent avec celui du mouvement. Elles vous permettent aussi de gérer de manière intelligente le timing de vos animations : plus besoin de <em>hardcoder</em> le temps qu'elles doivent mettre ; seule la description du mouvement compte. Aussi, vous n'avez plus à vous soucier des changements de valeurs et de ses conséquences sur la cohérence globale d'une animation : le système les gère et s'adapte.</p>\n<p>Il existe plusieurs solutions pour les gérer :</p>\n<ul>\n<li>JS: <a href=\"http://facebook.github.io/rebound-js/examples/\">Rebound.js</a></li>\n<li>JS spécifique React: <a href=\"https://github.com/chenglou/react-motion\">react-motion</a></li>\n<li>JS spécifique React, utilisé par react-native: <a href=\"https://github.com/animatedjs/animated\">Animated</a></li>\n<li>Java (Android): <a href=\"http://facebook.github.io/rebound/\">Rebound</a></li>\n<li>Objective-C/Swift (iOS): <a href=\"https://github.com/facebook/pop\">Pop</a></li>\n</ul>\n<p>La team WebKit <a href=\"https://twitter.com/webkit/status/748573524734812161\">a également proposé</a> l'ajout d'une fonction <code>spring</code> à CSS mais la discussion stagne (à tester dans Safari Technology Preview).</p>\n<p>En espérant que ça vous donne des idées d'animations cool à faire.</p>\n<p>Bisous bisous.</p>\n","rawBody":"\nLes animations prennent une grande place dans les interfaces utilisateur. Loin de n'apporter qu'un côté esthétique, elles augmentent la performance perçue, améliorent notre expérience en nous aidant à nous repérer et en guidant notre attention. Sur les applications natives, ces animations sont souvent plus naturelles que sur le web, et pour cause, beaucoup de leurs animations sont des *springs*.\n\nQu'est-ce qu'une animation *spring* ? Pour arriver à le définir, voyons comment on a l'habitude de créer des animations avec les technologies web.\n\nCSS possède deux propriétés permettant d'animer des valeurs: les `animation` et les `transition`. Au delà de la différence entre leurs capacités au sein de CSS (propriété VS ensemble de propriétés avec des étapes), les deux reposent sur le même mécanisme. On va donc étudier le plus simple: `transition`.\n\n```css\n.block {\n  transition: 300ms linear transform;\n}\n\n.block:hover {\n  transform: scale(1.05);\n}\n```\n\nCette transition est définie sur un modèle simple : on fixe une durée d'animation (ici `300ms`) et un easing —*ou *zizine* si vous écoutez [le podcast](http://putaindecode.io/fr/articles/podcast/1/)*— qui est une fonction d'interpolation (ici `linear`).\n\nL'easing est une fonction toute bête comme vous avez pu en voir au collège et les avez dessinées sur votre calculatrice Casio ou Texas (si comme moi vous étiez le seul péquin de la classe à avoir l'autre modèle, à devoir toujours se démerder parce que les profs savaient pas comment la vôtre marchait).\n\nBref, une fonction d'easing est assez simple. Par exemple, la `linear` ça revient à :\n\n![](./Linear.png)\n\n```js\nconst linear = x => x // such complicated\n    // didn't even import `lodash.identity` from npm\n```\n\nLe paramètre `x` varie entre `0` et `1`, c'est la progression de l'animation. Ce paramètre vaut `0` quand vous êtes au début de l'animation et `1` à la fin.\n\nEn faisant à la main une version du système gérant l'animation, ça donne quelque chose dans ce style :\n\n```js\nconst transition = ({ duration, easing, onUpdate, startValue, endValue }) => {\n  const startDate = Date.now() // le moment où commence l'animation\n  // la fonction tick sera executée périodiquement\n  const tick = () => {\n    const absoluteProgress = (Date.now() - startDate) / duration // on calcule `x`\n    const progress = Math.min(absoluteProgress, 1) // on fait gaffe de pas déborder\n    const progressWithEasing = easing(progress) // on applique la fonction d'easing\n    // pour calculer la valeur, on diminue progressivement la valeur initiale et l'on accroit la valeur finale\n    onUpdate((1 - progressWithEasing) * startValue + progressWithEasing * endValue)\n    if(progress < 1) {\n      // si c'est pas fini, on repart pour un tour\n      requestAnimationFrame(tick)\n    }\n  }\n  tick()\n}\n\n\nmyElement.onclick = () => transition({\n  duration: 500,\n  easing: x => x,\n  onUpdate: (value) => myElement.style.transform = `translateY(${ value + \"px\" })`,\n  startValue: 0,\n  endValue: 200,\n})\n```\n\nPour définir cette fonction d'easing, CSS vous permet également de configurer des courbes de Bézier cubiques.\n\nUne courbe de Bézier cubique se définit avec 4 points : `P0`, `P1`, `P2` et `P3`. Il en est ensuite dérivé une courbe à partir de ces quatre points. C'est avec ce mécanisme que fonctionne la plume de la plupart des logiciels d'édition d'image.  \n\n![](./Bezier.png)\n\nVu que votre animation commence et finit à des valeurs définies à l'avance, deux points sont fixés à l'avance : `P0` sera toujours `(0, 0)` et `P3` `(1, 1)`.\n\nVous avez avec CSS la liberté de définir `P1` et `P2` sous la forme `cubic-bezier(P1x, P1y, P2x, P2y)`. Pour visualiser le fonctionnement, je vous conseille de faire un tour sur [cubic-bezier](http://cubic-bezier.com) de [Lea Verou](https://twitter.com/leaverou).\n\nTout ce que nous avons vu jusque-là sont des animations *timées* (vive les anglicismes). Leur durée est connue à l'avance et est immuable, les variations possibles se feront dans les limites de ces contraintes.\n\nCes animations sont très pratiques pour certaines animations basiques et rempliront très bien leur mission, mais elles peuvent rapidement avoir des limites :\n\nAvec CSS :\n\n- On n'a aucun contrôle sur l'exécution de l'animation\n- Configurer des animations complexes complique la maintenance\n\nAvec un easing basique en général :\n\n- `cubic-bezier` limite énormément les possibilités d'évolution de la valeur animée (e.g. on souhaite que l'animation ait de l'élasticité, les timing-functions ne permettent de faire qu'un seul débord qui ne parait pas \"naturel\").\n-  Avoir des animations cohérentes dans toute notre UI est extrêmement contraignant avec CSS\n\nPour l'élasticité, vous pouvez vous débrouiller avec `@keyframes`, hardcoder toutes les valeurs, les *timer* à la main, y passer des heures pour vous retrouver avec 60 étapes dans votre animation et au final de ne pas être satisfait du résultat, claquer la porte de votre boulot et partir élever des brebis dans les Pyrénées.\n\nC'est là qu'interviennent les *springs*.\n\nUne animation spring vous expose en général deux paramètres : `tension` et `friction` (ou `stiffness`, pour rigidité & `damping`, pour amortissement, selon les systèmes). Ce sont des valeurs logiques dans ce contexte, puisqu'elles viennent des lois de la physique (big up Newton).\n\nQuelques exemples sur les [demos de Rebound.js](http://facebook.github.io/rebound-js/examples/) peuvent vous aider à visualiser ce que représentent ces paramètres au sein de l'animation.\n\nAfin d'obéir à des lois \"logiques\" de la physique, l'animation spring doit prendre en compte à chaque `tick` non seulement la valeur actuelle et celle d'arrivée mais aussi sa rapidité actuelle : c'est ce qui lui permet d'enchaîner naturellement les animations.\n\nÀ chaque frame, il va exécuter la fonction suivante pour déterminer la `value` et `velocity` à venir (note : ce côté est une simplification du code utilisé par [react-motion](https://github.com/chenglou/react-motion)).\n\n```javascript\nconst unitOfTime = 1 / 60 // the number of seconds in a frame\nconst precision = 0.01\n\nconst step = (\n  lastValue,\n  lastVelocity,\n  toValue,\n  stiffness,\n  damping\n) => {\n  const spring = -stiffness * (lastValue - toValue)\n  const damper = -damping * lastVelocity\n\n  const all = spring + damper\n  const nextVelocity = lastVelocity + all * unitOfTime\n  const nextValue = lastValue + nextVelocity * unitOfTime\n\n  const shouldRest = Math.abs(nextVelocity) < precision && Math.abs(nextValue - toValue) < precision\n\n  return {\n    velocity: shouldRest ? 0 : nextVelocity,\n    value: shouldRest ? toValue : nextValue,\n  }\n}\n```\n\nEnsuite, une simple fonction `spring` qui reproduit à peu de choses près la mécanique de notre `createTransition` vu plus haut :\n\n```javascript\nconst spring = ({ stiffness = 180, damping = 12, onRest = (() => {}), toValue }) => onUpdate => {\n  let frame\n  const tick = (curr) => {\n    // on calcule l'état\n    const { velocity, value } = step(curr.value, curr.velocity, toValue, stiffness, damping)\n    onUpdate({ velocity, value })\n    // si l'animation n'est pas terminée\n    if(velocity !== 0 || value !== toValue) {\n      // on programme la prochaine frame\n      frame = requestAnimationFrame(() => tick({ value, velocity }))\n    } else {\n      // sinon on prévient que l'animation est au repos\n      onRest()\n    }\n  }\n  return {\n    // afin de permettre aux animations de s'enchaîner, la fonction `start` prend l'état actuel de la valeur\n    start: (value) => {\n      frame = requestAnimationFrame(() => tick(value))\n    },\n    stop: () => {\n      cancelAnimationFrame(frame)\n    },\n  }\n}\n```\n\nIl nous reste à créer une classe \"observable\" `Value` qui conserve l'état et l'animation active. Cela permet de stopper l'animation en cours avant de lancer la suivante lorsque cela arrive.\n\n```js\nclass Value {\n  constructor(initialValue) {\n    this.value = {\n      value: initialValue,\n      velocity: 0,\n    }\n    this.listeners = new Set()\n    this.animation = null\n  }\n  addListener(listener) {\n    this.listeners.add(listener)\n    return () => {\n      this.listeners.delete(listener)\n    }\n  }\n  updateValue(nextValue) {\n    this.value = nextValue\n    this.listeners.forEach(listener => listener(this.value.value))\n  }\n  animate(animation) {\n    if(this.animation) {\n      this.animation.stop()\n    }\n    this.animation = animation((v) => this.updateValue(v))\n    this.animation.start(this.value)\n  }\n}\n```\n\nEt voilà, vous avez une animation :\n\n```javascript\nconst scale = new Value(1)\n\nscale.addListener(value => myElement.style.transform = `scale(${ value })`)\n\nmyElement.onmousedown = () => {\n  scale.animate(spring({ toValue: 2 }))\n}\n\nmyElement.onmouseup = () => {\n  scale.animate(spring({ toValue: 1 }))\n}\n```\n\n<iframe width=\"100%\" height=\"300\" src=\"//jsfiddle.net/bloodyowl/36d0nc7r/embedded/\" allowfullscreen=\"allowfullscreen\" frameborder=\"0\"></iframe>\n\nLes animations spring ont de nombreux avantages. Elles vous permettent d'utiliser un vocabulaire cohérent avec celui du mouvement. Elles vous permettent aussi de gérer de manière intelligente le timing de vos animations : plus besoin de *hardcoder* le temps qu'elles doivent mettre ; seule la description du mouvement compte. Aussi, vous n'avez plus à vous soucier des changements de valeurs et de ses conséquences sur la cohérence globale d'une animation : le système les gère et s'adapte.\n\nIl existe plusieurs solutions pour les gérer :\n\n- JS: [Rebound.js](http://facebook.github.io/rebound-js/examples/)\n- JS spécifique React: [react-motion](https://github.com/chenglou/react-motion)\n- JS spécifique React, utilisé par react-native: [Animated](https://github.com/animatedjs/animated)\n- Java (Android): [Rebound](http://facebook.github.io/rebound/)\n- Objective-C/Swift (iOS): [Pop](https://github.com/facebook/pop)\n\nLa team WebKit [a également proposé](https://twitter.com/webkit/status/748573524734812161) l'ajout d'une fonction `spring` à CSS mais la discussion stagne (à tester dans Safari Technology Preview).\n\nEn espérant que ça vous donne des idées d'animations cool à faire.\n\nBisous bisous.\n","__filename":"fr/articles/css/animations/index.md","__url":"/fr/articles/css/animations/","__resourceUrl":"/fr/articles/css/animations/index.html","__dataUrl":"/fr/articles/css/animations/index.html.fbe4c0135cbfd6b464ab07774b80b98d.json"}